template<>
llvm::Function *create_function_from_symbol_impl<abi::platform_abi::microsoft_x64>(
	ast::function_body &func_body,
	ctx::bitcode_context &context
)
{
	if (func_body.cc == abi::calling_convention::bozon)
	{
		return create_function_from_symbol_impl<abi::platform_abi::generic>(
			func_body, context
		);
	}

	auto const result_t = get_llvm_type(func_body.return_type, context);
	bz::vector<llvm::Type *> args = {};
	for (auto &p : func_body.params)
	{
		auto const t = get_llvm_type(p.var_type, context);
		if (context.get_size(t) > context.get_register_size())
		{
			args.push_back(llvm::PointerType::get(t, 0));
		}
		else
		{
			args.push_back(t);
		}
	}
	auto const func_t = llvm::FunctionType::get(result_t, llvm::ArrayRef(args.data(), args.size()), false);
	auto const name = llvm::StringRef(func_body.symbol_name.data_as_char_ptr(), func_body.symbol_name.size());
	auto const fn = llvm::Function::Create(
		func_t, llvm::Function::ExternalLinkage,
		name, context.get_module()
	);

	switch (func_body.cc)
	{
	case abi::calling_convention::bozon:
		fn->setCallingConv(llvm::CallingConv::Fast);
		break;
	case abi::calling_convention::c:
		fn->setCallingConv(llvm::CallingConv::C);
		break;
	case abi::calling_convention::fast:
		fn->setCallingConv(llvm::CallingConv::Fast);
		break;
	case abi::calling_convention::std:
		fn->setCallingConv(llvm::CallingConv::X86_StdCall);
		break;
	}

	for (auto &arg : fn->args())
	{
		auto const t = arg.getType();
		if (
			auto const ptr_t = llvm::dyn_cast<llvm::PointerType>(t);
			ptr_t && context.get_size(ptr_t->getElementType()) > context.get_register_size()
		)
		{
			arg.addAttr(llvm::Attribute::ByVal);
		}
	}
	return fn;
}

template<>
val_ptr emit_bitcode<abi::platform_abi::microsoft_x64>(
	ast::expr_function_call const &func_call,
	ctx::bitcode_context &context
)
{
	constexpr auto abi = abi::platform_abi::microsoft_x64;
	bz_assert(func_call.func_body != nullptr);
	auto const fn = context.get_function(func_call.func_body);
	bz_assert(fn != nullptr);

	bz::vector<llvm::Value *> params = {};
	params.reserve(func_call.params.size());

	for (size_t i = 0; i < func_call.params.size(); ++i)
	{
		auto &p = func_call.params[i];
		auto &p_t = func_call.func_body->params[i].var_type;
		if (p_t.is<ast::ts_lvalue_reference>())
		{
			auto const val = emit_bitcode<abi>(p, context);
			bz_assert(val.kind == val_ptr::reference);
			params.push_back(val.val);
		}
		else
		{
			auto const val = emit_bitcode<abi>(p, context).get_value(context);
			auto const arg = fn->getArg(i);
			if (arg->hasAttribute(llvm::Attribute::ByVal))
			{
				bz_assert(arg->hasAttribute(llvm::Attribute::ByVal));
				auto const alloca = context.create_alloca(val->getType());
				context.builder.CreateStore(val, alloca);
				params.push_back(alloca);
			}
			else
			{
				params.push_back(val);
			}
		}
	}
	auto const res = context.builder.CreateCall(fn, llvm::ArrayRef(params.data(), params.size()));

	if (res->getType()->isVoidTy())
	{
		return {};
	}

	if (func_call.func_body->return_type.is<ast::ts_lvalue_reference>())
	{
		return { val_ptr::reference, res };
	}
	else
	{
		return { val_ptr::value, res };
	}
}
