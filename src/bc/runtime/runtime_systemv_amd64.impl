namespace systemv_amd64
{

static llvm::Value *create_cast_to_int(
	val_ptr val,
	ctx::bitcode_context &context
)
{
	auto const dest_type = [&]() {
		auto const val_t = val.get_type();
		switch (context.get_size(val_t))
		{
		case 1:
			return context.get_int8_t();
		case 2:
			return context.get_int16_t();
		case 4:
			return context.get_int32_t();
		case 8:
			return context.get_int64_t();
		default:
			bz_unreachable;
		}
	}();
	return context.create_bitcast(val, dest_type);
}

} // namespace systemv_amd64

template<>
val_ptr emit_bitcode<abi::platform_abi::systemv_amd64>(
	ast::expr_function_call const &func_call,
	ctx::bitcode_context &context,
	llvm::Value *result_address
)
{
	constexpr auto abi = abi::platform_abi::systemv_amd64;
	bz_assert(func_call.func_body != nullptr);

	auto const fn = context.get_function(func_call.func_body);
	bz_assert(fn != nullptr);

	auto const result_type = get_llvm_type(func_call.func_body->return_type, context);

	bz::vector<llvm::Value *> params = {};
	params.reserve(func_call.params.size());

	auto param_it = func_call.params.begin();
	auto param_t_it = func_call.func_body->params.begin();
	auto arg_it = fn->arg_begin();
	auto const arg_end = fn->arg_end();

	auto const result_output_ptr = arg_it != arg_end && arg_it->hasAttribute(llvm::Attribute::StructRet);
	auto const result_int_cast = !result_output_ptr && !result_type->isIntegerTy() && fn->getReturnType()->isIntegerTy();

	if (result_output_ptr)
	{
		auto const ptr_t = llvm::dyn_cast<llvm::PointerType>(arg_it->getType());
		bz_assert(ptr_t != nullptr);
		auto const output_ptr = result_address != nullptr ? result_address : context.create_alloca(ptr_t->getElementType());
		params.push_back(output_ptr);
		++arg_it;
	}

	for (; arg_it != arg_end; ++param_it, ++param_t_it, ++arg_it)
	{
		auto const &p = *param_it;
		auto const &p_t = param_t_it->var_type;
		auto &arg = *arg_it;
		if (p_t.is<ast::ts_lvalue_reference>())
		{
			auto const val = emit_bitcode<abi>(p, context, nullptr);
			bz_assert(val.kind == val_ptr::reference);
			params.push_back(val.val);
		}
		else
		{
			auto const val_ref = emit_bitcode<abi>(p, context, nullptr);
			auto const t = val_ref.get_type();
			if (abi::pass_by_reference<abi>(t, context))
			{
				bz_assert(arg.hasAttribute(llvm::Attribute::ByVal));
				auto const val = val_ref.get_value(context.builder);
				auto const alloca = context.create_alloca(t, 16);
				context.builder.CreateStore(val, alloca);
				params.push_back(alloca);
			}
			else if (abi::pass_as_int_cast<abi>(t, context))
			{
				params.push_back(systemv_amd64::create_cast_to_int(val_ref, context));
			}
			else
			{
				auto const val = val_ref.get_value(context.builder);
				params.push_back(val);
			}
		}
	}
	auto const res = [&]() -> llvm::Value * {
		if (result_output_ptr)
		{
			auto const call = context.builder.CreateCall(fn, llvm::ArrayRef(params.data(), params.size()));
			call->setCallingConv(fn->getCallingConv());
			return params.front();
		}
		else if (result_int_cast)
		{
			auto const int_val = context.builder.CreateCall(fn, llvm::ArrayRef(params.data(), params.size()));
			int_val->setCallingConv(fn->getCallingConv());
			auto const val_ptr = result_address != nullptr ? result_address : context.create_alloca(result_type);
			auto const int_ptr = context.builder.CreateBitCast(val_ptr, llvm::PointerType::get(int_val->getType(), 0));
			context.builder.CreateStore(int_val, int_ptr);
			return result_address != nullptr ? result_address : context.builder.CreateLoad(val_ptr);
		}
		else
		{
			auto const val = context.builder.CreateCall(fn, llvm::ArrayRef(params.data(), params.size()));
			val->setCallingConv(fn->getCallingConv());
			if (result_address == nullptr)
			{
				return val;
			}
			else
			{
				context.builder.CreateStore(val, result_address);
				return result_address;
			}
		}
	}();

	if (result_type->isVoidTy())
	{
		return {};
	}

	if (result_address != nullptr)
	{
		bz_assert(res == result_address);
		return { val_ptr::reference, result_address };
	}
	else if (func_call.func_body->return_type.is<ast::ts_lvalue_reference>() || result_output_ptr)
	{
		return { val_ptr::reference, res };
	}
	else
	{
		return { val_ptr::value, res };
	}
}

template<>
void emit_bitcode<abi::platform_abi::systemv_amd64>(
	ast::stmt_return const &ret_stmt,
	ctx::bitcode_context &context
)
{
	constexpr auto abi = abi::platform_abi::systemv_amd64;
	if (ret_stmt.expr.is_null())
	{
		context.builder.CreateRetVoid();
	}
	else
	{
		auto const ret_val = emit_bitcode<abi>(ret_stmt.expr, context, context.output_pointer);
		if (context.current_function.first->return_type.is<ast::ts_lvalue_reference>())
		{
			bz_assert(ret_val.kind == val_ptr::reference);
			context.builder.CreateRet(ret_val.val);
		}
		else if (context.output_pointer != nullptr)
		{
			bz_assert(ret_val.val == context.output_pointer);
			bz_assert(ret_val.kind == val_ptr::reference);
			context.builder.CreateRetVoid();
		}
		else if (!ret_val.get_type()->isIntegerTy() && context.current_function.second->getReturnType()->isIntegerTy())
		{
			auto const ret_t = context.current_function.second->getReturnType();
			if (ret_val.kind == val_ptr::reference)
			{
				auto const val_ptr = ret_val.val;
				auto const int_ptr = context.builder.CreateBitCast(val_ptr, llvm::PointerType::get(ret_t, 0));
				auto const int_val = context.builder.CreateLoad(int_ptr);
				context.builder.CreateRet(int_val);
			}
			else
			{
				auto const val = ret_val.get_value(context.builder);
				auto const int_ptr = context.create_alloca(ret_t);
				auto const val_ptr = context.builder.CreateBitCast(int_ptr, llvm::PointerType::get(val->getType(), 0));
				context.builder.CreateStore(val, val_ptr);
				auto const int_val = context.builder.CreateLoad(int_ptr);
				context.builder.CreateRet(int_val);
			}
		}
		else
		{
			context.builder.CreateRet(ret_val.get_value(context.builder));
		}
	}
}
