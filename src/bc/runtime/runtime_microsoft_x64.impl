// documentation: https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=vs-2019
// cdec, stdcall, fastcall and thiscall all resolve to this according to wikipedia:
// https://en.wikipedia.org/wiki/X86_calling_conventions#Microsoft_x64_calling_convention
// would like to have a more reliable source for this, but it's good enough

template<>
val_ptr emit_bitcode<abi::platform_abi::microsoft_x64>(
	ast::expr_function_call const &func_call,
	ctx::bitcode_context &context,
	llvm::Value *result_address
)
{
	constexpr auto abi = abi::platform_abi::microsoft_x64;
	if (func_call.func_body->is_intrinsic())
	{
		switch (func_call.func_body->intrinsic_kind)
		{
		case ast::function_body::builtin_str_begin_ptr:
		{
			bz_assert(func_call.params.size() == 1);
			auto const arg = emit_bitcode<abi>(func_call.params[0], context, nullptr).get_value(context.builder);
			auto const begin_ptr = context.builder.CreateExtractValue(arg, 0);
			if (result_address != nullptr)
			{
				context.builder.CreateStore(begin_ptr, result_address);
				return val_ptr{ val_ptr::reference, result_address };
			}
			else
			{
				return val_ptr{ val_ptr::value, begin_ptr };
			}
		}
		case ast::function_body::builtin_str_end_ptr:
		{
			bz_assert(func_call.params.size() == 1);
			auto const arg = emit_bitcode<abi>(func_call.params[0], context, nullptr).get_value(context.builder);
			auto const end_ptr = context.builder.CreateExtractValue(arg, 1);
			if (result_address != nullptr)
			{
				context.builder.CreateStore(end_ptr, result_address);
				return val_ptr{ val_ptr::reference, result_address };
			}
			else
			{
				return val_ptr{ val_ptr::value, end_ptr };
			}
		}
		case ast::function_body::builtin_str_from_ptrs:
		{
			bz_assert(func_call.params.size() == 2);
			auto const begin_ptr = emit_bitcode<abi>(func_call.params[0], context, nullptr).get_value(context.builder);
			auto const end_ptr   = emit_bitcode<abi>(func_call.params[1], context, nullptr).get_value(context.builder);
			if (result_address != nullptr)
			{
				auto const result_begin_ptr = context.builder.CreateStructGEP(result_address, 0);
				auto const result_end_ptr   = context.builder.CreateStructGEP(result_address, 1);
				context.builder.CreateStore(begin_ptr, result_begin_ptr);
				context.builder.CreateStore(end_ptr, result_end_ptr);
				return val_ptr{ val_ptr::reference, result_address };
			}
			else
			{
				bz_assert(context.get_str_t()->isStructTy());
				auto const str_t = static_cast<llvm::StructType *>(context.get_str_t());
				llvm::Value *result = llvm::ConstantStruct::get(str_t, { llvm::UndefValue::get(str_t), llvm::UndefValue::get(str_t) });
				result = context.builder.CreateInsertValue(result, begin_ptr, 0);
				result = context.builder.CreateInsertValue(result, end_ptr,   1);
				return val_ptr{ val_ptr::value, result };
			}
		}

		default:
			break;
		}
	}

	bz_assert(func_call.func_body != nullptr);

	auto const fn = context.get_function(func_call.func_body);
	bz_assert(fn != nullptr);

	auto const result_type = get_llvm_type(func_call.func_body->return_type, context);

	bz::vector<llvm::Value *> params = {};
	params.reserve(func_call.params.size());

	auto param_it = func_call.params.begin();
	auto param_t_it = func_call.func_body->params.begin();
	auto arg_it = fn->arg_begin();
	auto const arg_end = fn->arg_end();

	auto const result_output_ptr = arg_it != arg_end && arg_it->hasAttribute(llvm::Attribute::StructRet);
	auto const result_int_cast = !result_output_ptr && !result_type->isIntegerTy() && fn->getReturnType()->isIntegerTy();

	if (result_output_ptr)
	{
		auto const ptr_t = llvm::dyn_cast<llvm::PointerType>(arg_it->getType());
		bz_assert(ptr_t != nullptr);
		auto const output_ptr = result_address != nullptr ? result_address : context.create_alloca(ptr_t->getElementType());
		params.push_back(output_ptr);
		++arg_it;
	}

	for (; arg_it != arg_end; ++param_it, ++param_t_it, ++arg_it)
	{
		auto const &p = *param_it;
		auto const &p_t = param_t_it->var_type;
		auto &arg = *arg_it;
		if (p_t.is<ast::ts_lvalue_reference>())
		{
			auto const val = emit_bitcode<abi>(p, context, nullptr);
			bz_assert(val.kind == val_ptr::reference);
			params.push_back(val.val);
		}
		else if (ast::remove_const_or_consteval(ast::remove_pointer(p_t)).is<ast::ts_void>())
		{
			auto const val = emit_bitcode<abi>(p, context, nullptr).get_value(context.builder);
			auto const void_ptr = context.builder.CreatePointerCast(val, llvm::PointerType::getInt8PtrTy(context.get_llvm_context()));
			params.push_back(void_ptr);
		}
		else
		{
			auto const val_ref = emit_bitcode<abi>(p, context, nullptr);
			auto const t = val_ref.get_type();
			if (abi::pass_by_reference<abi>(t, context))
			{
				// there's no need to provide a seperate copy for a byval argument,
				// as a copy is made at the call site automatically
				// see: https://reviews.llvm.org/D79636
				bz_assert(arg.hasAttribute(llvm::Attribute::ByVal));
				if (val_ref.kind == val_ptr::reference)
				{
					params.push_back(val_ref.val);
				}
				else
				{
					auto const val = val_ref.get_value(context.builder);
					auto const alloca = context.create_alloca(t);
					context.builder.CreateStore(val, alloca);
					params.push_back(alloca);
				}
			}
			else if (abi::pass_as_int_cast<abi>(t, context))
			{
				params.push_back(context.create_cast_to_int(val_ref));
			}
			else
			{
				auto const val = val_ref.get_value(context.builder);
				params.push_back(val);
			}
		}
	}
	auto const res = [&]() -> llvm::Value * {
		auto const call = context.builder.CreateCall(fn, llvm::ArrayRef(params.data(), params.size()));
		call->setCallingConv(fn->getCallingConv());
		arg_it = fn->arg_begin();
		unsigned i = 0;
		bz_assert(fn->arg_size() == call->arg_size());
		for (; arg_it != arg_end; ++arg_it, ++i)
		{
			if (arg_it->hasAttribute(llvm::Attribute::ByVal))
			{
				call->addParamAttr(i, llvm::Attribute::ByVal);
				call->addParamAttr(i, llvm::Attribute::NoAlias);
				call->addParamAttr(i, llvm::Attribute::NoCapture);
				call->addParamAttr(i, llvm::Attribute::NonNull);
			}
		}
		if (result_output_ptr)
		{
			return params.front();
		}
		else if (result_int_cast)
		{
			auto const val_ptr = result_address != nullptr ? result_address : context.create_alloca(result_type);
			auto const int_ptr = context.builder.CreateBitCast(val_ptr, llvm::PointerType::get(call->getType(), 0));
			context.builder.CreateStore(call, int_ptr);
			return result_address != nullptr ? result_address : context.builder.CreateLoad(val_ptr);
		}
		else
		{
			if (result_address == nullptr)
			{
				return call;
			}
			else
			{
				context.builder.CreateStore(call, result_address);
				return result_address;
			}
		}
	}();

	if (result_type->isVoidTy())
	{
		return {};
	}

	if (result_address != nullptr)
	{
		bz_assert(res == result_address);
		return { val_ptr::reference, result_address };
	}
	else if (func_call.func_body->return_type.is<ast::ts_lvalue_reference>() || result_output_ptr)
	{
		return { val_ptr::reference, res };
	}
	else
	{
		return { val_ptr::value, res };
	}
}

template<>
void emit_bitcode<abi::platform_abi::microsoft_x64>(
	ast::stmt_return const &ret_stmt,
	ctx::bitcode_context &context
)
{
	constexpr auto abi = abi::platform_abi::microsoft_x64;
	if (ret_stmt.expr.is_null())
	{
		context.builder.CreateRetVoid();
	}
	else
	{
		auto const ret_val = emit_bitcode<abi>(ret_stmt.expr, context, context.output_pointer);
		if (context.current_function.first->return_type.is<ast::ts_lvalue_reference>())
		{
			bz_assert(ret_val.kind == val_ptr::reference);
			context.builder.CreateRet(ret_val.val);
		}
		else if (context.output_pointer != nullptr)
		{
			bz_assert(ret_val.val == context.output_pointer);
			bz_assert(ret_val.kind == val_ptr::reference);
			context.builder.CreateRetVoid();
		}
		else if (!ret_val.get_type()->isIntegerTy() && context.current_function.second->getReturnType()->isIntegerTy())
		{
			auto const ret_t = context.current_function.second->getReturnType();
			if (ret_val.kind == val_ptr::reference)
			{
				auto const val_ptr = ret_val.val;
				auto const int_ptr = context.builder.CreateBitCast(val_ptr, llvm::PointerType::get(ret_t, 0));
				auto const int_val = context.builder.CreateLoad(int_ptr);
				context.builder.CreateRet(int_val);
			}
			else
			{
				auto const val = ret_val.get_value(context.builder);
				auto const int_ptr = context.create_alloca(ret_t);
				auto const val_ptr = context.builder.CreateBitCast(int_ptr, llvm::PointerType::get(val->getType(), 0));
				context.builder.CreateStore(val, val_ptr);
				auto const int_val = context.builder.CreateLoad(int_ptr);
				context.builder.CreateRet(int_val);
			}
		}
		else
		{
			context.builder.CreateRet(ret_val.get_value(context.builder));
		}
	}
}
