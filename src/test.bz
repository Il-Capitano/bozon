operator + (: int32, : int32) -> int32
{}

operator - (: int32, : int32) -> int32
{}

operator * (: int32, : int32) -> int32
{}

operator / (: int32, : int32) -> int32
{}

operator + (: float64, : float64) -> float64
{}

operator + (: float64, : int32) -> float64
{}

operator & (: int32) -> *int32
{}

operator || (: bool, : bool) -> bool
{}

operator .. (: str, : str) -> str
{}

operator () (: str) -> int32
{}

operator () (: str, : float64) -> float64
{}

operator [] (: str, : int32) -> char
{}


function factorial(n: int32) -> int32
{
	let a = 0;
	let b = n;

	let c = 1 + 4;
	let d = &c;

	let e = true || false;
	let f = e || true;

	let g = 0.0 + 1.0;
	let h = 0.0 + 1;

	"hello" .. " world\n";

	let i = "test"();
	let j = "test"(0.0);
	let k = "test"[2];
	let l = ("test1" .. "test2")();

	{
		let m = i;
	}

//	let n = m;

	let o = ((((((0))))));

	return factorial(n - 1) * n;
}

let a = factorial;

/*
operator ..= (:int32, :int32) -> range_int32
{}
*/

operator ..= (:str, :str) -> &str
{}

function factorial(: float64) -> float64
{
	let a: function(int32, str, float32) -> char;
//	let b;

	{
		let a = a;
		let b: int32;
		{
			let b: float64;
			let c = b;
		}
	}
	let d: [int32, float32];
	let e: [];
	let f: [int32, [str, char], [], null_t];
	let g: [[[[]]]];

//	let h = 0 ..= 10;
	let i = null;
	let j = 'a';

	let str = ("hello");
	let res = str ..= " world";

	return 0.0;
}

// let b = factorial(0.0);



/*

a && b || c ^^ d  // ((a '&&' b) '||' (c '^^' d))
a < b == c        // ((a '<' b) '==' c)
a == b && c == d  // ((a '==' b) '&&' (c '==' d))

typeof (a + b)  // ('typeof' (a '+' b))
sizeof a + b    // (('sizeof' a) '+' b)
++--a      // ('++' ('--' a))
++a.b      // ('++' (a '.' b))

a().b::c      // (a() '.' (b '::' c))
a[b, c];      // (a '[' (b ',' c))
a((b, c), d)  // a((b ',' c), d)
a[b + c]      // (a '[' (b '+' c))

(a + b) * c  // ((a '+' b) '*' c)
a + b * c    // (a '+' (b '*' c))
a = b = c    // (a '=' (b '=' c))
a + b + c    // ((a '+' b) '+' c)
a->b->c      // ((a '->' b) '->' c)
*/

/*
if (x == 0)
	return 0;
if (x == 1)
	return 1;
return x * factorial(x - 1);
*/
/*
typeof (a + b)   // (typeof (a + b))
sizeof a + b     // ((sizeof a) + b)

a/b/c     // ((a / b) / c)
a+b+c     // ((a + b) + c)
a=b=c     // (a = (b = c))
a+b*c/d   // (a + ((b * c) / d))
++++a     // (++ (++ a))

a||b^^c&&d   // (a || (b ^^ (c && d)))
a&&b||c^^d   // ((a && b) || (c ^^ d))
a==b&&c==d   // ((a == b) && (c == d))

((a|b)^c)&d   // (((a | b) ^ c) & d)
a|b^c&d       // (a | (b ^ (c & d)))
a&b|c^d       // ((a & b) | (c ^ d))

++a->b->c.d   // ('++' (((a '->' b) '->' c) '.' d))
&a::b         // ('&' (a '::' b))
&(a+b+c)      // ('&' ((a '+' b) '+' c))
*/



/*



struct vec3<typename T>
{
	static_assert(std::is_trivial<T>, "vec3 value_type must be trivial");

	using value_type = T;

	x: T;
	y: T;
	z: T;

	constructor() = default;

	constructor(t: [T, T, T])
	[ .x = t[0]; .y = t[1]; .z = t[2]; ]
	{}

	constructor(_x: T, _y: T, _z: T)
	[ .x = _x; .y = _y; .z = _z; ]
	{}

	function abs_sqr(&const this)
	{ return (this.x * this.x + this.y * this.y + this.z * this.z); }

	function abs(&const this)
	{ return std::sqrt(this.abs()); }

	function unit(&const this) -> vec3
	{
		const ilen = 1 / this.abs();
		return [
			this.x * ilen,
			this.y * ilen,
			this.z * ilen
		];
	}
}


struct vec<uint64 N, typename T>
{
	static_assert(std::is_trivial<T>, "...");

	using value_type = T;

	c: [N]value_type;

	constructor() = default;

	constructor(t: [...T])
	[ .c = t ]
	{}

	function abs_sqr(&const this)
	{
		const ...Ns = std::make_index_sequence<N>();
		return (this.c[Ns] * this.c[Ns]) + ...;
	}

	function abs(&const this)
	{ return std::sqrt(this.abs()); }

	function unit(&const this) -> vec<N, T>
	{
		const ilen = 1 / this.abs();
		const ...Ns = std::make_index_sequence<N>();
		return [ (this.c[Ns] * ilen)... ];
	}
}

using vec3<typename T> = vec<3, T>;

*/
