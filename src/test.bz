/*

operator .. (: str, : str) -> str
{}

operator () (: str) -> int32
{}

operator () (: str, : float64) -> float64
{}

operator [] (: str, : int32) -> char
{}


function factorial(n: int32) -> int32
{
	let a = 0;
	let b = n;

//	let c = 1 + 4;
//	let d = &c;

//	let g = 0.0 + 1.0;
//	let h = 0.0 + 1;

	"hello" .. " world\n";

	let i = "test"();
	let j = "test"(0.0);
	let k = "test"[2];
	let l = ("test1" .. "test2")();

	{
		let m = i;
	}

//	let n = m;

	let o = ((((((0))))));

	let p = "test";
	let q = p();
	p();
//	let factorial = 1;  // causes an unknown function call in the return statement

//	let r = +0;
	let s: int8;
//	let t = +s;

//	return factorial(n - 1) * n;
}

let a = factorial;

operator ..= (:str, :str) -> &str
{}

function factorial(: float64) -> float64
{
	let a: function(int32, str, float32) -> char;
//	let b;

	{
		let a = a;
		let b: int32;
		{
			let b: float64;
			let c = b;
		}
	}
	let d: [int32, float32];
	let e: [];
	let f: [int32, [str, char], [], null_t];
	let g: [[[[]]]];

//	let h = 0 ..= 10;
	let i = null;
	let j = 'a';

	let str = ("hello");
	let res = str ..= " world";

	return 0.0;
}

let b = factorial(0.0);
let c = factorial(0);
// let d = factorial;  // 'Error: identifier is ambiguous' GOOD!

	/*

struct foo
{
	b1: bool;
	b2: bool;
	i: int32;
}

// operator & () -> foo {}
operator & (: foo) -> *foo {}
operator & (: foo, : foo) -> foo {}
// operator & (: foo, : foo, : foo) -> foo {}

// operator ^^ () -> foo {}
// operator ^^ (: foo) -> foo {}
operator ^^ (: foo, : foo) -> foo {}
// operator ^^ (: foo, : foo, : foo) -> foo {}

// operator [] () -> foo {}
// operator [] (: foo) -> foo {}
operator [] (: foo, : foo) -> foo {}
// operator [] (: foo, : foo, : foo) -> foo {}

// operator () () -> foo {}
operator () (: foo) -> foo {}
operator () (: foo, : foo) -> foo {}
operator () (: foo, : foo, : foo) -> foo {}

let bar: foo;
//	*/

// let e: vec2d;

struct vec2d
{
	x: float64;
	y: float64;
}

let f: vec2d;

struct vec3d
{
	x: float64;
	y: float64;
	z: float64;
}

let g: vec3d;

// struct vec2d {}




let h = [ 0, 1, 2, 3 ];
let i = [ "test", 'a', 1.0, 12345 ];
let j = [ i ];
let k = [[[[ i ]]]];

function tuple_test(t: [ int32, int32, float64, str ]) -> [ *int32, *int32 ]
{}

let l = ([ 0, 1, 1.5, "test" ]);
let m = tuple_test(l);


function get_const_reference() -> &const int32
{}

function get_reference() -> &int32
{}

function reference_test() -> void
{
	let a = get_const_reference();
	let b = a + 1;
	let c = get_const_reference() + 5;
//	let d: &int32 = get_const_reference();
	let e: &const int32 = get_const_reference();
	let &f = get_reference();
	let &g = get_const_reference();
	const h = get_reference();
//	const &i = h;
//	let &j = 1;
}




function address_of_test() -> void
{
	let n = 2;
	let p = &n;
	const p = &n;
	const n = 1;
	let p = &n;
	const p = &n;
	let &m = n;
	let p = &m;
}

function deref_test() -> void
{
	{
		let n = 3;
		let p = &n;
		let m = *p;
		let &a = *p;
	}
	{
		const n = 3;
		const p = &n;
		let m = *p;
		let &a = *p;
		let b = *&n;
		let q = &p;
		let c = *q;
		let d = **q;
		let &e = **q;
	}
	{
		const n = 3;
//		const m = *n;
	}
}

function bool_not_test() -> void
{
	{
		let a = !true;
		let b = !a;
		const c = true;
		let d = !a;
		let &e = d;
		let f = !e;
//		let &g = !e;
	}
	{
//		const a = !3;
		const b = !!!true;
	}
}

function comma_test() -> void
{
	let a = 0, 1, 2, 3;
	let b = 0, 1.0;
	let c = "test", 'a';
	let &d = "test", c;
//	let &e = "test", 'a';
//	let &f = c, "test";
}

function bool_op_test() -> void
{
	let   a = true || false;
	const b = true && false;
	let   c = true ^^ false;
//	let &d = a || b;
	const e = a || b;
}

*/  // line 1

const i8: int8;
const u8: uint8;
const i16: int16;
const u16: uint16;
const i32: int32;
const u32: uint32;
const i64: int64;
const u64: uint64;
const f32: float32;
const f64: float64;

function op_plus_test() -> void
{
	// arithmetic types
	{
		let a = i8 + i8;
		let b = i8 + u8;
		let c = u8 + i8;
		let d = u8 + u8;
		let e = i32 + u64;
		let f = i32 + i16;
		let g = i32 + u16;
		let h = i32 + u32;
		let i = f32 + u64;
		let j = f64 + f32;
		let k = f64 + i8;
		let l = i8 + u16 + i64 + f32;
	}
	// pointer arithmetic
	{
		let a = 0;
		let p = &a + 1;
		let q = 1 + &a;
		let b: int8;
		&a + b;
		b + &a;
	}
	// char arithmetic
	{
		let c = 'a';
		let d = 'a' + 1;
		let e = 1 + c;
	}
}

function op_minus_test() -> void
{
	// arithmetic types
	{
		let a = i8 - i8;
		let b = i8 - u8;
		let c = u8 - i8;
		let d = u8 - u8;
		let e = i32 - u64;
		let f = i32 - i16;
		let g = i32 - u16;
		let h = i32 - u32;
		let i = f32 - u64;
		let j = f64 - f32;
		let k = f64 - i8;
		let l = i8 - u16 - i64 - f32;
	}
	// pointer arithmetic
	{
		let a = 0;
		let p = &a - 1;
		let b: int8;
//		1 - &a;
		&a - b;
		let diff = p - &a;
	}
	// char arithmetic
	{
		let c = 'a';
		let d = 'a' - 1;
//		1 - 'a';
	}
}

function op_multiply_test() -> void
{
	let a = i8 * i8;
	let b = i8 * u8;
	let c = u8 * i8;
	let d = u8 * u8;
	let e = i32 * u64;
	let f = i32 * i16;
	let g = i32 * u16;
	let h = i32 * u32;
	let i = f32 * u64;
	let j = f64 * f32;
	let k = f64 * i8;
	let l = i8 * u16 * i64 * f32;
}

function op_divide_test() -> void
{
	let a = i8 / i8;
	let b = i8 / u8;
	let c = u8 / i8;
	let d = u8 / u8;
	let e = i32 / u64;
	let f = i32 / i16;
	let g = i32 / u16;
	let h = i32 / u32;
	let i = f32 / u64;
	let j = f64 / f32;
	let k = f64 / i8;
	let l = i8 / u16 / i64 / f32;
}

struct tester {}

function op_equals_test() -> void
{
	// arithmetic types
	{
		let a = i8 == i8;
		let b = i8 == u8;
		let d = u8 == u8;
		let e = i32 == u64;
		let f = i32 == i16;
		let g = i32 == u16;
		let h = i32 == u32;
		let i = f32 == u64;
		let j = f64 == f32;
		let k = f64 == i8;
	}
	// pointers
	{
		let p: *int32;
		let q: *int32;
		let a = p == q;
		let r: *const int32;
		let b = r == p, p == r;

		let s: **int32;
//		let c = s == p;
		let d = s == &p;
		let t: *float32;
//		let e = t == p;
		let u: *const **const *const tester;
		const v: ***const *tester;
		let f = u == v;
		let g = &u == &v;
		let h = p == null;
		let i = null == v;
	}
	// other
	{
		let a = true == false;
		let b = 'a' == 'b';
//		let c = 'a' == false;
		let d = "hello" == "test";
	}
}

function op_not_equals_test() -> void
{
	// arithmetic types
	{
		let a = i8 != i8;
		let b = i8 != u8;
		let d = u8 != u8;
		let e = i32 != u64;
		let f = i32 != i16;
		let g = i32 != u16;
		let h = i32 != u32;
		let i = f32 != u64;
		let j = f64 != f32;
		let k = f64 != i8;
	}
	// pointers
	{
		let p: *int32;
		let q: *int32;
		let a = p != q;
		let r: *const int32;
		let b = r != p, p != r;

		let s: **int32;
//		let c = s != p;
		let d = s != &p;
		let t: *float32;
//		let e = t != p;
		let u: *const **const *const tester;
		const v: ***const *tester;
		let f = u != v;
		let g = &u != &v;
		let h = p != null;
		let i = null != v;
	}
	// other
	{
		let a = true != false;
		let b = 'a' != 'b';
//		let c = 'a' != false;
		let d = "hello" != "test";
	}
}

function op_modulo_test() -> void
{
	let a = i8 % i8;
	let b = i8 % u8;
	let d = u8 % u8;
	let e = i32 % u64;
	let f = i32 % i16;
	let g = i32 % u16;
	let h = i32 % u32;
//	let i = f32 % i32;
}

function op_bit_and_test() -> void
{
	let a = i8 & i8;
	let b = i8 & u8;
	let d = u8 & u8;
	let e = i32 & u64;
	let f = i32 & i16;
	let g = i32 & u16;
	let h = i32 & u32;
//	let i = f32 & i32;
}

function op_bit_or_test() -> void
{
	let a = i8 | i8;
	let b = i8 | u8;
	let d = u8 | u8;
	let e = i32 | u64;
	let f = i32 | i16;
	let g = i32 | u16;
	let h = i32 | u32;
//	let i = f32 | i32;
}

function op_bit_xor_test() -> void
{
	let a = i8 ^ i8;
	let b = i8 ^ u8;
	let d = u8 ^ u8;
	let e = i32 ^ u64;
	let f = i32 ^ i16;
	let g = i32 ^ u16;
	let h = i32 ^ u32;
//	let i = f32 ^ i32;
}

function op_bool_and_test() -> void
{
	let a = true && false;
//	let b = i32 && true;
}

function op_bool_or_test() -> void
{
	let a = true || false;
//	let b = i32 || true;
}

function op_bool_xor_test() -> void
{
	let a = true ^^ false;
//	let b = i32 ^^ true;
}

function op_bit_left_shift_test() -> void
{
	let a = i8 << i8;
	let b = i8 << u8;
	let d = u8 << u8;
	let e = i32 << u64;
	let f = i32 << i16;
	let g = i32 << u16;
	let h = i32 << u32;
//	let i = f32 << i32;
}

function op_bit_right_shift_test() -> void
{
	let a = i8 >> i8;
	let b = i8 >> u8;
	let d = u8 >> u8;
	let e = i32 >> u64;
	let f = i32 >> i16;
	let g = i32 >> u16;
	let h = i32 >> u32;
//	let i = f32 >> i32;
}

function op_assign_test() -> void
{
	let a = i8;
	a = i8;
	let &b = a = i8;
//	a = u8;
//	a = i32;

	let c = i32;
	c = i8;
	c = u8;
	c = u16;
	c = i32;
//	c = false;
//	c = "test";

	let d = true;
	d = false;
//	d = "hello";
}

function string_print_test() -> void
{
	"this is a test";
	"this is another 	\t test";
	"this is a newline
test\n";
	'\n';
	'	';
	'\'';
	'"';

//	'';
	' '   // BUG: why does expression parsing not check for a semicolon after this char?
	"";  // output is ' '; and not ' ' "";
	"\t";

	1 + 3 3; // same as above!
}

function random() -> void
{
//	[(1, 2, 3 + 4;
	[a, b] = [c, d];
	if (true)
	{}
	else;

	let a: int32;
	let &a_ref = a;
//	const &a_err = a;
	let const b = a;
//	let const &c = a;
	let *d = &a;
	const *e = d;
	const **const *f = &c;
//	const *const const g = 0;
}

struct foo
{
	x: int32;
	y: int32;
	z: [int32, [[]]];
}

const this_is_some_var = &((((i8))));
// let error_var: foo;

operator () (: functor, : int32, : int32) -> int32 { return 0; }

/*
struct vec3<typename T>
{
	static_assert(std::is_trivial<T>, "vec3 value_type must be trivial");

	using value_type = T;

	x: T;
	y: T;
	z: T;

	constructor() = default;

	constructor(t: [T, T, T])
	[ .x = t[0]; .y = t[1]; .z = t[2]; ]
	{}

	constructor(_x: T, _y: T, _z: T)
	[ .x = _x; .y = _y; .z = _z; ]
	{}

	function abs_sqr(&const this)
	{ return (this.x * this.x + this.y * this.y + this.z * this.z); }

	function abs(&const this)
	{ return std::sqrt(this.abs_sqr()); }

	function unit(&const this) -> vec3
	{
		const ilen = 1 / this.abs();
		return [
			this.x * ilen,
			this.y * ilen,
			this.z * ilen
		];
	}
}


struct vec<uint64 N, typename T>
{
	static_assert(std::is_trivial<T>, "...");

	using value_type = T;

	c: [N]value_type;

	constructor() = default;

	constructor(t: [...T])
	[ .c = t ]
	{}

	function abs_sqr(&const this)
	{
		const ...Ns = std::make_index_sequence<N>();
		return (this.c[Ns] * this.c[Ns]) + ...;
	}

	function abs(&const this)
	{ return std::sqrt(this.abs()); }

	function unit(&const this) -> vec<N, T>
	{
		const ilen = 1 / this.abs();
		const ...Ns = std::make_index_sequence<N>();
		return [ (this.c[Ns] * ilen)... ];
	}
}

using vec3<typename T> = vec<3, T>;

*/
