import std::libc::stdlib;
import meta::comptime;
import meta::types;
import format;

export function memcpy  = __builtin_memcpy;
export function memmove = __builtin_memmove;
export function memset  = __builtin_memset;
export function swap = __builtin_swap;

export function assert(b: bool)
{
	if (!b) unreachable;
}

export function exit(code: int32) -> void
{
	libc::exit(code);
}

export function malloc_raw(T: typename, n: usize) -> *T
{
	static_assert(!meta::is_reference(T), "type in 'malloc_raw' can't be a reference type");
	static_assert(!meta::is_const(T), "type in 'malloc_raw' can't be 'const'");
	static_assert(!meta::is_consteval(T), "type in 'malloc_raw' can't be 'consteval'");

	return if (meta::is_comptime()) {
		meta::malloc(T, n)
	} else {
		__builtin_pointer_cast(*T, libc::malloc(n * sizeof T))
	};
}

export function malloc(T: typename, n: usize) -> *T
{
	static_assert(!meta::is_reference(T), "type in 'malloc' can't be a reference type");
	static_assert(!meta::is_move_reference(T), "type in 'malloc' can't be a move reference type");
	static_assert(!meta::is_const(T), "type in 'malloc' can't be 'const'");
	static_assert(!meta::is_consteval(T), "type in 'malloc' can't be 'consteval'");

	const result = if (meta::is_comptime()) {
		meta::malloc(T, n)
	} else {
		__builtin_pointer_cast(*T, libc::malloc(n * sizeof T))
	};

	for (let [it, const end] = [ result, result + n ]; it != end; ++it)
	{
		__builtin_inplace_construct(it, T());
	}

	return result;
}

export function free(p: *void)
{
	if (meta::is_comptime())
	{
		meta::free(p);
	}
	else
	{
		libc::free(p);
	}
}

consteval function is_integer_type(T: typename) -> bool
{
	return T == int8 || T == int16 || T == int32 || T == int64
		|| T == uint8 || T == uint16 || T == uint32 || T == uint64;
}

export struct iota_range<T: typename>
{
	static_assert(
		is_integer_type(T),
		comptime_format("invalid type argument '{}' for std::iota_range", __builtin_typename_as_str(T))
	);

	type value_type = T;
	type _self_t = iota_range<T>;

	._begin: T;
	._end: T;

	function begin(self: _self_t) -> iota_iterator_t<value_type>
	{
		return iota_iterator_t<value_type>[ self._begin ];
	}

	function end(self: _self_t) -> iota_iterator_t<value_type>
	{
		return iota_iterator_t<value_type>[ self._end ];
	}

	function size(self: _self_t) -> usize
	{
		return (self._end - self._begin) as usize;
	}
}

export struct iota_iterator_t<T: typename>
{
	static_assert(
		is_integer_type(T),
		comptime_format("invalid type argument '{}' for std::iota_iterator_t", __builtin_typename_as_str(T))
	);

	type value_type = T;
	type _self_t = iota_iterator_t<T>;

	._value: T;

	operator * (self: _self_t) -> value_type
	{
		return self._value;
	}

	operator ++ (self: &_self_t) -> &_self_t
	{
		++self._value;
		return self;
	}

	operator == (lhs: _self_t, rhs: _self_t) -> bool
	{
		return lhs._value == rhs._value;
	}

	operator != (lhs: _self_t, rhs: _self_t) -> bool
	{
		return lhs._value != rhs._value;
	}
}

export function iota(end) -> iota_range<typeof end>
{
	type T = typeof end;
	return iota_range<T>[ T(), end ];
}

export function iota(begin, end) -> iota_range<typeof begin>
{
	static_assert(
		typeof begin == typeof end,
		comptime_format(
			"begin and end have different types '{}' and '{}' in 'std::iota'",
			__builtin_typename_as_str(typeof begin), __builtin_typename_as_str(typeof end)
		)
	);
	if consteval (typeof begin == typeof end)
	{
		type T = typeof begin;
		return iota_range<T>[ begin, end ];
	}
	else
	{
		type T = typeof begin;
		return iota_range<T>[ T(), T() ];
	}
}
