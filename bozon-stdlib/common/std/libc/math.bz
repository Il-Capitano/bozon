import types;

@symbol_name("acosf") export function "c" acos(x: float)   -> float;
@symbol_name("acos")  export function "c" acos(x: double)  -> double;
@symbol_name("acosf") export function "c" acosf(x: double) -> double;

@symbol_name("asinf") export function "c" asin(x: float)  -> float;
@symbol_name("asin")  export function "c" asin(x: double) -> double;
@symbol_name("asinf") export function "c" asinf(x: float) -> float;

@symbol_name("atanf") export function "c" atan(x: float)  -> float;
@symbol_name("atan")  export function "c" atan(x: double) -> double;
@symbol_name("atanf") export function "c" atanf(x: float) -> float;

@symbol_name("atan2f") export function "c" atan2(y: float,  x: float)  -> float;
@symbol_name("atan2")  export function "c" atan2(y: double, x: double) -> double;
@symbol_name("atan2f") export function "c" atan2f(y: float, x: float) -> float;

@symbol_name("cosf") export function "c" cos(x: float)  -> float;
@symbol_name("cos")  export function "c" cos(x: double) -> double;
@symbol_name("cosf") export function "c" cosf(x: float) -> float;

@symbol_name("sinf") export function "c" sin(x: float)  -> float;
@symbol_name("sin")  export function "c" sin(x: double) -> double;
@symbol_name("sinf") export function "c" sinf(x: float) -> float;

@symbol_name("tanf") export function "c" tan(x: float)  -> float;
@symbol_name("tan")  export function "c" tan(x: double) -> double;
@symbol_name("tanf") export function "c" tanf(x: float) -> float;

@symbol_name("acoshf") export function "c" acosh(x: float)  -> float;
@symbol_name("acosh")  export function "c" acosh(x: double) -> double;
@symbol_name("acoshf") export function "c" acoshf(x: float) -> float;

@symbol_name("asinhf") export function "c" asinh(x: float)  -> float;
@symbol_name("asinh")  export function "c" asinh(x: double) -> double;
@symbol_name("asinhf") export function "c" asinhf(x: float) -> float;

@symbol_name("atanhf") export function "c" atanh(x: float)  -> float;
@symbol_name("atanh")  export function "c" atanh(x: double) -> double;
@symbol_name("atanhf") export function "c" atanhf(x: float) -> float;

@symbol_name("coshf") export function "c" cosh(x: float)  -> float;
@symbol_name("cosh")  export function "c" cosh(x: double) -> double;
@symbol_name("coshf") export function "c" coshf(x: float) -> float;

@symbol_name("sinhf") export function "c" sinh(x: float)  -> float;
@symbol_name("sinh")  export function "c" sinh(x: double) -> double;
@symbol_name("sinhf") export function "c" sinhf(x: float) -> float;

@symbol_name("tanhf") export function "c" tanh(x: float)  -> float;
@symbol_name("tanh")  export function "c" tanh(x: double) -> double;
@symbol_name("tanhf") export function "c" tanhf(x: float) -> float;

@symbol_name("expf") export function "c" exp(x: float)  -> float;
@symbol_name("exp")  export function "c" exp(x: double) -> double;
@symbol_name("expf") export function "c" expf(x: float) -> float;

@symbol_name("exp2f") export function "c" exp2(x: float)  -> float;
@symbol_name("exp2")  export function "c" exp2(x: double) -> double;
@symbol_name("exp2f") export function "c" exp2f(x: float) -> float;

@symbol_name("expm1f") export function "c" expm1(x: float)  -> float;
@symbol_name("expm1")  export function "c" expm1(x: double) -> double;
@symbol_name("expm1f") export function "c" expm1f(x: float) -> float;

@symbol_name("frexpf") export function "c" frexp(value: float,  exp: *int) -> float;
@symbol_name("frexp")  export function "c" frexp(value: double, exp: *int) -> double;
@symbol_name("frexpf") export function "c" frexpf(value: float, exp: *int) -> float;

@symbol_name("ilogbf") export function "c" ilogb(x: float)  -> int;
@symbol_name("ilogb")  export function "c" ilogb(x: double) -> int;
@symbol_name("ilogbf") export function "c" ilogbf(x: float) -> int;

@symbol_name("ldexpf") export function "c" ldexp(x: float,  exp: int) -> float;
@symbol_name("ldexp")  export function "c" ldexp(x: double, exp: int) -> double;
@symbol_name("ldexpf") export function "c" ldexpf(x: float, exp: int) -> float;

@symbol_name("logf") export function "c" log(x: float)  -> float;
@symbol_name("log")  export function "c" log(x: double) -> double;
@symbol_name("logf") export function "c" logf(x: float) -> float;

@symbol_name("log10f") export function "c" log10(x: float)  -> float;
@symbol_name("log10")  export function "c" log10(x: double) -> double;
@symbol_name("log10f") export function "c" log10f(x: float) -> float;

@symbol_name("log1pf") export function "c" log1p(x: float)  -> float;
@symbol_name("log1p")  export function "c" log1p(x: double) -> double;
@symbol_name("log1pf") export function "c" log1pf(x: float) -> float;

@symbol_name("log2f") export function "c" log2(x: float)  -> float;
@symbol_name("log2")  export function "c" log2(x: double) -> double;
@symbol_name("log2f") export function "c" log2f(x: float) -> float;

@symbol_name("logbf") export function "c" logb(x: float)  -> float;
@symbol_name("logb")  export function "c" logb(x: double) -> double;
@symbol_name("logbf") export function "c" logbf(x: float) -> float;

@symbol_name("modff") export function "c" modf(value: float,  iptr: *float)  -> float;
@symbol_name("modf")  export function "c" modf(value: double, iptr: *double) -> double;
@symbol_name("modff") export function "c" modff(value: float, iptr: *float) -> float;

@symbol_name("scalbnf") export function "c" scalbn(x: float,  n: int) -> float;
@symbol_name("scalbn")  export function "c" scalbn(x: double, n: int) -> double;
@symbol_name("scalbnf") export function "c" scalbnf(x: float, n: int) -> float;

@symbol_name("scalblnf") export function "c" scalbln(x: float,  n: long) -> float;
@symbol_name("scalbln")  export function "c" scalbln(x: double, n: long) -> double;
@symbol_name("scalblnf") export function "c" scalblnf(x: float, n: long) -> float;

@symbol_name("cbrtf") export function "c" cbrt(x: float)  -> float;
@symbol_name("cbrt")  export function "c" cbrt(x: double) -> double;
@symbol_name("cbrtf") export function "c" cbrtf(x: float) -> float;

// absolute values
/*
function "c" abs(j: int) -> int;
// function "c" abs(j: long) -> long; // long is either the same as int or long_long, so it's not needed
function "c" abs(j: long_long) -> long_long;
function "c" abs(j: float) -> float;
function "c" abs(j: double) -> double;
*/

@symbol_name("fabsf") export function "c" fabs(x: float)  -> float;
@symbol_name("fabs")  export function "c" fabs(x: double) -> double;
@symbol_name("fabsf") export function "c" fabsf(x: float) -> float;

@symbol_name("hypotf") export function "c" hypot(x: float,  y: float)  -> float;
@symbol_name("hypot")  export function "c" hypot(x: double, y: double) -> double;
@symbol_name("hypotf") export function "c" hypotf(x: float, y: float) -> float;

// three-dimensional hypotenuse
@symbol_name("hypotf") export function "c" hypot(x: float,  y: float,  z: float)  -> float;
@symbol_name("hypot")  export function "c" hypot(x: double, y: double, z: double) -> double;
@symbol_name("hypotf") export function "c" hypotf(x: float, y: float, z: float) -> float;

@symbol_name("powf") export function "c" pow(x: float,  y: float)  -> float;
@symbol_name("pow")  export function "c" pow(x: double, y: double) -> double;
@symbol_name("powf") export function "c" powf(x: float, y: float) -> float;

@symbol_name("sqrtf") export function "c" sqrt(x: float)  -> float;
@symbol_name("sqrt")  export function "c" sqrt(x: double) -> double;
@symbol_name("sqrtf") export function "c" sqrtf(x: float) -> float;

@symbol_name("erff") export function "c" erf(x: float)  -> float;
@symbol_name("erf")  export function "c" erf(x: double) -> double;
@symbol_name("erff") export function "c" erff(x: float) -> float;

@symbol_name("erfcf") export function "c" erfc(x: float)  -> float;
@symbol_name("erfc")  export function "c" erfc(x: double) -> double;
@symbol_name("erfcf") export function "c" erfcf(x: float) -> float;

@symbol_name("lgammaf") export function "c" lgamma(x: float)  -> float;
@symbol_name("lgamma")  export function "c" lgamma(x: double) -> double;
@symbol_name("lgammaf") export function "c" lgammaf(x: float) -> float;

@symbol_name("tgammaf") export function "c" tgamma(x: float)  -> float;
@symbol_name("tgamma")  export function "c" tgamma(x: double) -> double;
@symbol_name("tgammaf") export function "c" tgammaf(x: float) -> float;

@symbol_name("ceilf") export function "c" ceil(x: float)  -> float;
@symbol_name("ceil")  export function "c" ceil(x: double) -> double;
@symbol_name("ceilf") export function "c" ceilf(x: float) -> float;

@symbol_name("floorf") export function "c" floor(x: float)  -> float;
@symbol_name("floor")  export function "c" floor(x: double) -> double;
@symbol_name("floorf") export function "c" floorf(x: float) -> float;

@symbol_name("nearbyintf") export function "c" nearbyint(x: float)  -> float;
@symbol_name("nearbyint")  export function "c" nearbyint(x: double) -> double;
@symbol_name("nearbyintf") export function "c" nearbyintf(x: float) -> float;

@symbol_name("rintf") export function "c" rint(x: float)  -> float;
@symbol_name("rint")  export function "c" rint(x: double) -> double;
@symbol_name("rintf") export function "c" rintf(x: float) -> float;

@symbol_name("lrintf") export function "c" lrint(x: float)  -> long;
@symbol_name("lrint")  export function "c" lrint(x: double) -> long;
@symbol_name("lrintf") export function "c" lrintf(x: float) -> long;

@symbol_name("llrintf") export function "c" llrint(x: float)  -> long_long;
@symbol_name("llrint")  export function "c" llrint(x: double) -> long_long;
@symbol_name("llrintf") export function "c" llrintf(x: float) -> long_long;

@symbol_name("roundf") export function "c" round(x: float)  -> float;
@symbol_name("round")  export function "c" round(x: double) -> double;
@symbol_name("roundf") export function "c" roundf(x: float) -> float;

@symbol_name("lroundf") export function "c" lround(x: float)  -> long;
@symbol_name("lround")  export function "c" lround(x: double) -> long;
@symbol_name("lroundf") export function "c" lroundf(x: float) -> long;

@symbol_name("llroundf") export function "c" llround(x: float)  -> long_long;
@symbol_name("llround")  export function "c" llround(x: double) -> long_long;
@symbol_name("llroundf") export function "c" llroundf(x: float) -> long_long;

@symbol_name("truncf") export function "c" trunc(x: float)  -> float;
@symbol_name("trunc")  export function "c" trunc(x: double) -> double;
@symbol_name("truncf") export function "c" truncf(x: float) -> float;

@symbol_name("fmodf") export function "c" fmod(x: float,  y: float)  -> float;
@symbol_name("fmod")  export function "c" fmod(x: double, y: double) -> double;
@symbol_name("fmodf") export function "c" fmodf(x: float, y: float)  -> float;

@symbol_name("remainderf") export function "c" remainder(x: float,  y: float)  -> float;
@symbol_name("remainder")  export function "c" remainder(x: double, y: double) -> double;
@symbol_name("remainderf") export function "c" remainderf(x: float, y: float)  -> float;

@symbol_name("remquof") export function "c" remquo(x: float,  y: float,  quo: *int) -> float;
@symbol_name("remquo")  export function "c" remquo(x: double, y: double, quo: *int) -> double;
@symbol_name("remquof") export function "c" remquof(x: float, y: float, quo: *int)  -> float;

@symbol_name("copysignf") export function "c" copysign(x: float,  y: float)  -> float;
@symbol_name("copysign")  export function "c" copysign(x: double, y: double) -> double;
@symbol_name("copysignf") export function "c" copysignf(x: float, y: float)  -> float;

/*
double nan(const char* tagp);
float nanf(const char* tagp);
*/

@symbol_name("nextafterf") export function "c" nextafter(x: float,  y: float)  -> float;
@symbol_name("nextafter")  export function "c" nextafter(x: double, y: double) -> double;
@symbol_name("nextafterf") export function "c" nextafterf(x: float, y: float)  -> float;

/*
float nexttoward(float x, long double y);
double nexttoward(double x, long double y);
long double nexttoward(long double x, long double y);
float nexttowardf(float x, long double y);
long double nexttowardl(long double x, long double y);
*/

@symbol_name("fdimf") export function "c" fdim(x: float,  y: float)  -> float;
@symbol_name("fdim")  export function "c" fdim(x: double, y: double) -> double;
@symbol_name("fdimf") export function "c" fdimf(x: float, y: float)  -> float;

@symbol_name("fmaxf") export function "c" fmax(x: float,  y: float)  -> float;
@symbol_name("fmax")  export function "c" fmax(x: double, y: double) -> double;
@symbol_name("fmaxf") export function "c" fmaxf(x: float, y: float)  -> float;

@symbol_name("fminf") export function "c" fmin(x: float,  y: float)  -> float;
@symbol_name("fmin")  export function "c" fmin(x: double, y: double) -> double;
@symbol_name("fminf") export function "c" fminf(x: float, y: float)  -> float;

@symbol_name("fmaf") export function "c" fma(x: float,  y: float,  z: float)  -> float;
@symbol_name("fma")  export function "c" fma(x: double, y: double, z: double) -> double;
@symbol_name("fmaf") export function "c" fmaf(x: float, y: float,  z: float)  -> float;

// linear interpolation
@symbol_name("lerpf") export function "c" lerp(a: float,  b: float,  t: float)  -> float;
@symbol_name("lerp")  export function "c" lerp(a: double, b: double, t: double) -> double;
@symbol_name("lerpf") export function "c" lerpf(a: float, b: float,  t: float)  -> float;

// classification / comparison function "c"s
@symbol_name("fpclassifyf") export function "c" fpclassify(x: float)  -> int;
@symbol_name("fpclassify")  export function "c" fpclassify(x: double) -> int;
@symbol_name("fpclassifyf") export function "c" fpclassifyf(x: float) -> int;

@symbol_name("isfinitef") export function "c" isfinite(x: float)  -> bool;
@symbol_name("isfinite")  export function "c" isfinite(x: double) -> bool;
@symbol_name("isfinitef") export function "c" isfinitef(x: float) -> bool;

@symbol_name("isinff") export function "c" isinf(x: float)  -> bool;
@symbol_name("isinf")  export function "c" isinf(x: double) -> bool;
@symbol_name("isinff") export function "c" isinff(x: float) -> bool;

@symbol_name("isnanf") export function "c" isnan(x: float)  -> bool;
@symbol_name("isnan")  export function "c" isnan(x: double) -> bool;
@symbol_name("isnanf") export function "c" isnanf(x: float) -> bool;

@symbol_name("isnormalf") export function "c" isnormal(x: float)  -> bool;
@symbol_name("isnormal")  export function "c" isnormal(x: double) -> bool;
@symbol_name("isnormalf") export function "c" isnormalf(x: float) -> bool;

@symbol_name("signbitf") export function "c" signbit(x: float)  -> bool;
@symbol_name("signbit")  export function "c" signbit(x: double) -> bool;
@symbol_name("signbitf") export function "c" signbitf(x: float) -> bool;

@symbol_name("isgreaterf") export function "c" isgreater(x: float,  y: float)  -> bool;
@symbol_name("isgreater")  export function "c" isgreater(x: double, y: double) -> bool;
@symbol_name("isgreaterf") export function "c" isgreaterf(x: float, y: float)  -> bool;

@symbol_name("isgreaterequalf") export function "c" isgreaterequal(x: float,  y: float)  -> bool;
@symbol_name("isgreaterequal")  export function "c" isgreaterequal(x: double, y: double) -> bool;
@symbol_name("isgreaterequalf") export function "c" isgreaterequalf(x: float, y: float)  -> bool;

@symbol_name("islessf") export function "c" isless(x: float,  y: float)  -> bool;
@symbol_name("isless")  export function "c" isless(x: double, y: double) -> bool;
@symbol_name("islessf") export function "c" islessf(x: float, y: float)  -> bool;

@symbol_name("islessequalf") export function "c" islessequal(x: float,  y: float)  -> bool;
@symbol_name("islessequal")  export function "c" islessequal(x: double, y: double) -> bool;
@symbol_name("islessequalf") export function "c" islessequalf(x: float, y: float)  -> bool;

@symbol_name("islessgreaterf") export function "c" islessgreater(x: float,  y: float)  -> bool;
@symbol_name("islessgreater")  export function "c" islessgreater(x: double, y: double) -> bool;
@symbol_name("islessgreaterf") export function "c" islessgreaterf(x: float, y: float)  -> bool;

@symbol_name("isunorderedf") export function "c" isunordered(x: float,  y: float)  -> bool;
@symbol_name("isunordered")  export function "c" isunordered(x: double, y: double) -> bool;
@symbol_name("isunorderedf") export function "c" isunorderedf(x: float, y: float)  -> bool;

/*
// mathematical special function "c"s

// associated Laguerre polynomials
@symbol_name("assoc_laguerref") export function "c" assoc_laguerre(n: unsigned_int, m: unsigned_int, x: float)  -> float;
@symbol_name("assoc_laguerre") export function "c" assoc_laguerre(n: unsigned_int, m: unsigned_int, x: double) -> double;
@symbol_name("assoc_laguerref") export function "c" assoc_laguerref(n: unsigned_int, m: unsigned_int, x: float) -> float;

// associated Legendre function "c"s
@symbol_name("assoc_legendref") export function "c" assoc_legendre(l: unsigned_int, m: unsigned_int, x: float)  -> float;
@symbol_name("assoc_legendre") export function "c" assoc_legendre(l: unsigned_int, m: unsigned_int, x: double) -> double;
@symbol_name("assoc_legendref") export function "c" assoc_legendref(l: unsigned_int, m: unsigned_int, x: float) -> float;

// beta function "c"
@symbol_name("betaf") export function "c" beta(x: float,  y: float)  -> float;
@symbol_name("beta") export function "c" beta(x: double, y: double) -> double;
@symbol_name("betaf") export function "c" betaf(x: float, y: float) -> float;

// complete elliptic integral of the first kind
@symbol_name("comp_ellint_1f") export function "c" comp_ellint_1(k: float)  -> float;
@symbol_name("comp_ellint_1") export function "c" comp_ellint_1(k: double) -> double;
@symbol_name("comp_ellint_1f") export function "c" comp_ellint_1f(k: float) -> float;

// complete elliptic integral of the second kind
@symbol_name("comp_ellint_2f") export function "c" comp_ellint_2(k: float)  -> float;
@symbol_name("comp_ellint_2") export function "c" comp_ellint_2(k: double) -> double;
@symbol_name("comp_ellint_2f") export function "c" comp_ellint_2f(k: float) -> float;

// complete elliptic integral of the third kind
@symbol_name("comp_ellint_3f") export function "c" comp_ellint_3(k: float,  nu: float)  -> float;
@symbol_name("comp_ellint_3") export function "c" comp_ellint_3(k: double, nu: double) -> double;
@symbol_name("comp_ellint_3f") export function "c" comp_ellint_3f(k: float, nu: float) -> float;

// regular modified cylindrical Bessel function "c"s
@symbol_name("cyl_bessel_if") export function "c" cyl_bessel_i(nu: float,  x: float)  -> float;
@symbol_name("cyl_bessel_i") export function "c" cyl_bessel_i(nu: double, x: double) -> double;
@symbol_name("cyl_bessel_if") export function "c" cyl_bessel_if(nu: float, x: float) -> float;

// cylindrical Bessel function "c"s of the first kind
@symbol_name("cyl_bessel_jf") export function "c" cyl_bessel_j(nu: float,  x: float)  -> float;
@symbol_name("cyl_bessel_j") export function "c" cyl_bessel_j(nu: double, x: double) -> double;
@symbol_name("cyl_bessel_jf") export function "c" cyl_bessel_jf(nu: float, x: float) -> float;

// irregular modified cylindrical Bessel function "c"s
@symbol_name("cyl_bessel_kf") export function "c" cyl_bessel_k(nu: float,  x: float)  -> float;
@symbol_name("cyl_bessel_k") export function "c" cyl_bessel_k(nu: double, x: double) -> double;
@symbol_name("cyl_bessel_kf") export function "c" cyl_bessel_kf(nu: float, x: float) -> float;

// cylindrical Neumann function "c"s;
// cylindrical Bessel function "c"s of the second kind
@symbol_name("cyl_neumannf") export function "c" cyl_neumann(nu: float,  x: float)  -> float;
@symbol_name("cyl_neumann") export function "c" cyl_neumann(nu: double, x: double) -> double;
@symbol_name("cyl_neumannf") export function "c" cyl_neumannf(nu: float, x: float) -> float;

// incomplete elliptic integral of the first kind
@symbol_name("ellint_1f") export function "c" ellint_1(k: float,  phi: float)  -> float;
@symbol_name("ellint_1") export function "c" ellint_1(k: double, phi: double) -> double;
@symbol_name("ellint_1f") export function "c" ellint_1f(k: float, phi: float) -> float;

// incomplete elliptic integral of the second kind
@symbol_name("ellint_2f") export function "c" ellint_2(k: float,  phi: float)  -> float;
@symbol_name("ellint_2") export function "c" ellint_2(k: double, phi: double) -> double;
@symbol_name("ellint_2f") export function "c" ellint_2f(k: float, phi: float) -> float;

// incomplete elliptic integral of the third kind
@symbol_name("ellint_3f") export function "c" ellint_3(k: float,  nu: float,  phi: float)  -> float;
@symbol_name("ellint_3") export function "c" ellint_3(k: double, nu: double, phi: double) -> double;
@symbol_name("ellint_3f") export function "c" ellint_3f(k: float, nu: float, phi: float) -> float;

// exponential integral
@symbol_name("expintf") export function "c" expint(x: float)  -> float;
@symbol_name("expint") export function "c" expint(x: double) -> double;
@symbol_name("expintf") export function "c" expintf(x: float) -> float;

// Hermite polynomials
@symbol_name("hermitef") export function "c" hermite(n: unsigned_int, x: float)  -> float;
@symbol_name("hermite") export function "c" hermite(n: unsigned_int, x: double) -> double;
@symbol_name("hermitef") export function "c" hermitef(n: unsigned_int, x: float) -> float;

// Laguerre polynomials
@symbol_name("laguerref") export function "c" laguerre(n: unsigned_int, x: float)  -> float;
@symbol_name("laguerre") export function "c" laguerre(n: unsigned_int, x: double) -> double;
@symbol_name("laguerref") export function "c" laguerref(n: unsigned_int, x: float) -> float;

// Legendre polynomials
@symbol_name("legendref") export function "c" legendre(l: unsigned_int, x: float)  -> float;
@symbol_name("legendre") export function "c" legendre(l: unsigned_int, x: double) -> double;
@symbol_name("legendref") export function "c" legendref(l: unsigned_int, x: float) -> float;

// Riemann zeta function "c"
@symbol_name("riemann_zetaf") export function "c" riemann_zeta(x: float)  -> float;
@symbol_name("riemann_zeta") export function "c" riemann_zeta(x: double) -> double;
@symbol_name("riemann_zetaf") export function "c" riemann_zetaf(x: float) -> float;

// spherical Bessel function "c"s of the first kind
@symbol_name("sph_besself") export function "c" sph_bessel(n: unsigned_int, x: float)  -> float;
@symbol_name("sph_bessel") export function "c" sph_bessel(n: unsigned_int, x: double) -> double;
@symbol_name("sph_besself") export function "c" sph_besself(n: unsigned_int, x: float) -> float;

// spherical associated Legendre function "c"s
@symbol_name("sph_legendref") export function "c" sph_legendre(l: unsigned_int, m: unsigned_int, theta: float)  -> float;
@symbol_name("sph_legendre") export function "c" sph_legendre(l: unsigned_int, m: unsigned_int, theta: double) -> double;
@symbol_name("sph_legendref") export function "c" sph_legendref(l: unsigned_int, m: unsigned_int, theta: float) -> float;

// spherical Neumann function "c"s;
// spherical Bessel function "c"s of the second kind
@symbol_name("sph_neumannf") export function "c" sph_neumann(n: unsigned_int, x: float)  -> float;
@symbol_name("sph_neumann") export function "c" sph_neumann(n: unsigned_int, x: double) -> double;
@symbol_name("sph_neumannf") export function "c" sph_neumannf(n: unsigned_int, x: float) -> float;
*/
