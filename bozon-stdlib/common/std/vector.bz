import utils;
import bit;
import meta::types;
import format;

export struct vector<T: typename>
{
	static_assert(
		!meta::is_const(T),
		comptime_format("vector value_type can't be a const type '{}'", meta::typename_as_str(T))
	);
	static_assert(
		!meta::is_consteval(T),
		comptime_format("vector value_type can't be a consteval type '{}'", meta::typename_as_str(T))
	);
	static_assert(
		!meta::is_reference(T),
		comptime_format("vector value_type can't be a reference type '{}'", meta::typename_as_str(T))
	);
	static_assert(
		!meta::is_move_reference(T),
		comptime_format("vector value_type can't be a move reference type '{}'", meta::typename_as_str(T))
	);

	type value_type = T
		.meta::remove_reference()
		.meta::remove_move_reference()
		.meta::remove_const()
		.meta::remove_consteval();
	type _self_t = vector<T>;

	._data_begin: ?*value_type;
	._data_end:   ?*value_type;
	._alloc_end:  ?*value_type;

	destructor(&self)
	{
		self.clear();
		free(self._data_begin);
	}

	constructor()
	{
		return _self_t[ null, null, null ];
	}

	constructor(other: &const _self_t)
	{
		return _self_t(other.as_slice());
	}

	constructor(slice: [: const value_type])
	{
		const size = slice.size();
		if (size == 0)
		{
			return _self_t();
		}
		const [data_begin, alloc_size] = rounded_alloc(value_type, size);
		const data_end = data_begin + size;
		const alloc_end = data_begin + alloc_size;
		copy_range(data_begin, data_end, slice.begin());
		return _self_t[ data_begin, data_end, alloc_end ];
	}

	operator = (self: &_self_t, other: &const _self_t) -> &_self_t
	{
		if (&self == &other)
		{
			return self;
		}
		const size = other.size();
		self.clear();
		self.reserve(size);
		self._data_end = self._data_begin + size;
		copy_range(self._data_begin, self._data_end, other._data_begin);
		return self;
	}

	operator = (self: &_self_t, other: _self_t) = __default__;

	operator = (self: &_self_t, rhs: [: const value_type]) -> &_self_t
	{
		const is_in_self_range = rhs.begin() >= self._data_begin && rhs.end() <= self._data_end;
		if (is_in_self_range)
		{
			const self_begin = self._data_begin;
			const self_end = self._data_end;

			const rhs_begin_offset = rhs.begin() - self_begin;
			const rhs_end_offset = rhs.end() - self_begin;
			const rhs_size = rhs.size();

			const rhs_begin = self_begin + rhs_begin_offset;
			const rhs_end = self_begin + rhs_end_offset;

			destruct_range(self_begin, rhs_begin);
			move_range(self_begin, self_begin + rhs_size, rhs_begin);
			destruct_range(rhs_end, self_end);
			self._data_end = self._data_begin + rhs_size;
		}
		else
		{
			const size = rhs.size();
			self.clear();
			self.reserve(size);
			self._data_end = self._data_begin + size;
			copy_range(self._data_begin, self._data_end, rhs.begin());
		}
		return self;
	}

	function size(self: #const _self_t) -> usize
	{
		return (self._data_end - self._data_begin) as usize;
	}

	function capacity(self: #const _self_t) -> usize
	{
		return (self._alloc_end - self._data_begin) as usize;
	}

	function as_slice(self: &_self_t) -> [: value_type]
	{
		return __builtin_slice_from_ptrs(self._data_begin, self._data_end);
	}

	function as_slice(self: &const _self_t) -> [: const value_type]
	{
		return __builtin_slice_from_const_ptrs(self._data_begin, self._data_end);
	}

	operator [] (self: &_self_t, i: uint64) -> &value_type
	{
		assert(i < self.size());
		return *(self._data_begin + i);
	}

	operator [] (self: &const _self_t, i: uint64) -> &const value_type
	{
		assert(i < self.size());
		return *(self._data_begin + i);
	}


	function reserve(self: &_self_t, new_capacity: usize)
	{
		if (new_capacity > self.capacity())
		{
			const [new_data_begin, new_alloc_size] = rounded_alloc(value_type, new_capacity);
			const new_data_end = new_data_begin + self.size();
			const new_alloc_end = new_data_begin + new_alloc_size;
			move_range(new_data_begin, new_data_end, self._data_begin);
			free(self._data_begin);
			self._data_begin = new_data_begin;
			self._data_end   = new_data_end;
			self._alloc_end  = new_alloc_end;
		}
	}

	function resize(self: &_self_t, new_size: usize)
	{
		if (new_size > self.size())
		{
			if consteval (meta::is_default_constructible(value_type))
			{
				self.reserve(new_size);
				const new_end = self._data_begin + new_size;
				for (let it = self._data_end; it != new_end; ++it)
				{
					__builtin_inplace_construct(it.get_value(), value_type());
				}
				self._data_end = new_end;
			}
			else
			{
				unreachable;
			}
		}
		else
		{
			const new_end = self._data_begin + new_size;
			for (let it = self._data_end; it != new_end;)
			{
				--it;
				__builtin_destruct_value(*it);
			}
			self._data_end = new_end;
		}
	}

	function release(self: &_self_t) -> _self_t
	{
		const data_begin = self._data_begin;
		const data_end   = self._data_end;
		const alloc_end  = self._alloc_end;
		self._data_begin = null;
		self._data_end   = null;
		self._alloc_end  = null;
		return _self_t[ data_begin, data_end, alloc_end ];
	}

	function clear(self: &_self_t)
	{
		for (let it = self._data_end; it != self._data_begin;)
		{
			--it;
			__builtin_destruct_value(*it);
		}
		self._data_end = self._data_begin;
	}

	function push_back(self: &_self_t, value: ##value_type)
	{
		if (self._data_end == self._alloc_end)
		{
			self.reserve(self.size() + 1);
		}
		__builtin_inplace_construct(self._data_end.get_value(), value_type(__forward value));
		self._data_end += 1;
	}

	function emplace_back(self: &_self_t, args: ...##auto) -> &value_type
	{
		if (self._data_end == self._alloc_end)
		{
			self.reserve(self.size() + 1);
		}
		__builtin_inplace_construct(self._data_end.get_value(), value_type(...__forward args));
		self._data_end += 1;
		return *(self._data_end - 1);
	}

	function push_front(self: &_self_t, value: ##value_type)
	{
		if (self._data_end == self._alloc_end)
		{
			const new_size = self.size() + 1;
			const [new_data_begin, new_alloc_size] = rounded_alloc(value_type, new_size);
			const new_data_end = new_data_begin + new_size;
			const new_alloc_end = new_data_begin + new_alloc_size;

			move_range(new_data_begin + 1, new_data_end, self._data_begin);
			__builtin_inplace_construct(new_data_begin.get_value(), value_type(__forward value));
			free(self._data_begin);
			self._data_begin = new_data_begin;
			self._data_end   = new_data_end;
			self._alloc_end  = new_alloc_end;
		}
		else
		{
			for (let it = self._data_end; it != self._data_begin; --it)
			{
				__builtin_inplace_construct(it.get_value(), __move__ *(it - 1));
			}
			__builtin_inplace_construct(self._data_begin.get_value(), value_type(__forward value));
			self._data_end += 1;
		}
	}

	function emplace_front(self: &_self_t, args: ...##auto) -> &value_type
	{
		if (self._data_end == self._alloc_end)
		{
			const new_size = self.size() + 1;
			const [new_data_begin, new_alloc_size] = rounded_alloc(value_type, new_size);
			const new_data_end = new_data_begin + new_size;
			const new_alloc_end = new_data_begin + new_alloc_size;

			move_range(new_data_begin.get_value() + 1, new_data_end, self._data_begin);
			__builtin_inplace_construct(new_data_begin, value_type(...__forward args));
			free(self._data_begin);
			self._data_begin = new_data_begin;
			self._data_end   = new_data_end;
			self._alloc_end  = new_alloc_end;
		}
		else
		{
			for (let it = self._data_end; it != self._data_begin; --it)
			{
				__builtin_inplace_construct(it.get_value(), __move__ *(it - 1));
			}
			__builtin_inplace_construct(self._data_begin.get_value(), value_type(...__forward args));
			self._data_end += 1;
		}
		return *self._data_begin;
	}
}

export function begin(vec: &vector) -> ?*(typeof vec).value_type
{
	return vec._data_begin;
}

export function end(vec: &vector) -> ?*(typeof vec).value_type
{
	return vec._data_end;
}

export function begin(vec: &const vector) -> ?*const (typeof vec).value_type
{
	return vec._data_begin;
}

export function end(vec: &const vector) -> ?*const (typeof vec).value_type
{
	return vec._data_end;
}


function move_range(begin: ?*auto, end: ?*auto, other_begin: ?*auto)
{
	type value_type = (typeof begin).meta::remove_optional().meta::remove_pointer();
	if consteval (meta::is_trivially_relocatable(value_type))
	{
		trivially_relocate_values(begin, other_begin, (end - begin) as usize);
	}
	else
	{
		for (let [it, other_it] = [ begin, other_begin ]; it != end; ++it, ++other_it)
		{
			__builtin_inplace_construct(it.get_value(), __move__ *other_it);
		}
	}
}

function copy_range(begin: ?*auto, end: ?*auto, other_begin: ?*const auto)
{
	type value_type = (typeof begin).meta::remove_optional().meta::remove_pointer();
	if consteval (meta::is_trivially_copy_constructible(value_type))
	{
		trivially_copy_values(begin, other_begin, (end - begin) as usize);
	}
	else
	{
		for (let [it, other_it] = [ begin, other_begin ]; it != end; ++it, ++other_it)
		{
			__builtin_inplace_construct(it.get_value(), *other_it);
		}
	}
}

function destruct_range(begin: ?*auto, end: ?*auto)
{
	for (let it = begin; it < end; ++it)
	{
		__builtin_destruct_value(*it);
	}
}

function round_to_next_power_of_two(n: usize) -> usize
{
	return if (n <= 1) {
		1
	} else {
		1uz << (sizeof usize * 8 - clz(n - 1))
	};
}

function rounded_alloc(T: typename, n: usize) -> [?*T, usize]
{
	if (n == 0)
	{
		return [ null, 0 ];
	}
	else
	{
		const rounded_n = round_to_next_power_of_two(n);
		return [ malloc_raw(T, rounded_n), rounded_n ];
	}
}
