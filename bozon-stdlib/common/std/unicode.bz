export consteval unicode_max_char = '\U0010ffff';

export consteval utf8_max_one_byte_char   = '\u007f';
export consteval utf8_max_two_byte_char   = '\u07ff';
export consteval utf8_max_three_byte_char = '\uffff';

export function encode_char_utf8(c: char) -> [[4: u8], u32]
{
	mut buffer: [4: u8];
	if (c < utf8_max_one_byte_char)
	{
		buffer[0] = c as u8;
		return [buffer, 1u];
	}
	else if (c < utf8_max_two_byte_char)
	{
		buffer[0] = (((c as u32 >> 6u) & 0b0001'1111) | 0b1100'0000) as u8;
		buffer[1] = (((c as u32 >> 0u) & 0b0011'1111) | 0b1000'0000) as u8;
		return [buffer, 2u];
	}
	else if (c < utf8_max_three_byte_char)
	{
		buffer[0] = (((c as u32 >> 12u) & 0b0000'1111) | 0b1110'0000) as u8;
		buffer[1] = (((c as u32 >>  6u) & 0b0011'1111) | 0b1000'0000) as u8;
		buffer[2] = (((c as u32 >>  0u) & 0b0011'1111) | 0b1000'0000) as u8;
		return [buffer, 3u];
	}
	else
	{
		buffer[0] = (((c as u32 >> 18u) & 0b0000'0111) | 0b1111'0000) as u8;
		buffer[1] = (((c as u32 >> 12u) & 0b0011'1111) | 0b1000'0000) as u8;
		buffer[2] = (((c as u32 >>  6u) & 0b0011'1111) | 0b1000'0000) as u8;
		buffer[3] = (((c as u32 >>  0u) & 0b0011'1111) | 0b1000'0000) as u8;
		return [buffer, 4u];
	}
}

export function decode_char_utf8(data: *u8, end: *u8) -> [char, *u8]
{
	let max_size = end - data;
	if (max_size == 0)
	{
		return [ '\x00', data ];
	}
	let first_byte = *data;
	if (first_byte < utf8_max_one_byte_char as u8)
	{
		return [ first_byte as char, data + 1 ];
	}
	else if (max_size >= 2 && (first_byte & 0b1110'0000u8) == 0b1100'0000u8)
	{
		let bytes = [ first_byte, *(data + 1) ];
		if ((bytes[1] & 0b1100'0000u8) != 0b1000'0000u8)
		{
			return [ '\x00', data ];
		}
		let result_int_val = ((bytes[0] & 0b0001'1111u8) as u32 << 6u)
			| ((bytes[1] & 0b0011'1111u8) as u32 <<  0u);
		return [ result_int_val as char, data + 2];
	}
	else if (max_size >= 3 && (first_byte & 0b1111'0000u8) == 0b1110'0000u8)
	{
		let bytes = [ first_byte, *(data + 1), *(data + 2) ];
		if (
			(bytes[1] & 0b1100'0000u8) != 0b1000'0000u8
			|| (bytes[2] & 0b1100'0000u8) != 0b1000'0000u8
		)
		{
			return [ '\x00', data ];
		}
		let result_int_val = ((bytes[0] & 0b0000'1111u8) as u32 << 12u)
			| ((bytes[1] & 0b0011'1111u8) as u32 <<  6u)
			| ((bytes[2] & 0b0011'1111u8) as u32 <<  0u);
		return [ result_int_val as char, data + 3];
	}
	else if (max_size >= 4 && (first_byte & 0b1111'1000u8) == 0b1111'0000u8)
	{
		let bytes = [ first_byte, *(data + 1), *(data + 2), *(data + 3) ];
		if (
			(bytes[1] & 0b1100'0000u8) != 0b1000'0000u8
			|| (bytes[2] & 0b1100'0000u8) != 0b1000'0000u8
			|| (bytes[3] & 0b1100'0000u8) != 0b1000'0000u8
		)
		{
			return [ '\x00', data ];
		}
		let result_int_val = ((bytes[0] & 0b0000'0111u8) as u32 << 18u)
			| ((bytes[1] & 0b0011'1111u8) as u32 << 12u)
			| ((bytes[2] & 0b0011'1111u8) as u32 <<  6u)
			| ((bytes[3] & 0b0011'1111u8) as u32 <<  0u);
		return [ result_int_val as char, data + 4];
	}
	else
	{
		return [ '\x00', data ];
	}
}

export function decode_char_utf8(data: *mut u8, end: *mut u8) -> [char, *mut u8]
{
	let max_size = end - data;
	if (max_size == 0)
	{
		return [ '\x00', data ];
	}
	let first_byte = *data;
	if (first_byte < utf8_max_one_byte_char as u8)
	{
		return [ first_byte as char, data + 1 ];
	}
	else if (max_size >= 2 && (first_byte & 0b1110'0000u8) == 0b1100'0000u8)
	{
		let bytes = [ first_byte, *(data + 1) ];
		if ((bytes[1] & 0b1100'0000u8) != 0b1000'0000u8)
		{
			return [ '\x00', data ];
		}
		let result_int_val = ((bytes[0] & 0b0001'1111u8) as u32 << 6u)
			| ((bytes[1] & 0b0011'1111u8) as u32 <<  0u);
		return [ result_int_val as char, data + 2];
	}
	else if (max_size >= 3 && (first_byte & 0b1111'0000u8) == 0b1110'0000u8)
	{
		let bytes = [ first_byte, *(data + 1), *(data + 2) ];
		if (
			(bytes[1] & 0b1100'0000u8) != 0b1000'0000u8
			|| (bytes[2] & 0b1100'0000u8) != 0b1000'0000u8
		)
		{
			return [ '\x00', data ];
		}
		let result_int_val = ((bytes[0] & 0b0000'1111u8) as u32 << 12u)
			| ((bytes[1] & 0b0011'1111u8) as u32 <<  6u)
			| ((bytes[2] & 0b0011'1111u8) as u32 <<  0u);
		return [ result_int_val as char, data + 3];
	}
	else if (max_size >= 4 && (first_byte & 0b1111'1000u8) == 0b1111'0000u8)
	{
		let bytes = [ first_byte, *(data + 1), *(data + 2), *(data + 3) ];
		if (
			(bytes[1] & 0b1100'0000u8) != 0b1000'0000u8
			|| (bytes[2] & 0b1100'0000u8) != 0b1000'0000u8
			|| (bytes[3] & 0b1100'0000u8) != 0b1000'0000u8
		)
		{
			return [ '\x00', data ];
		}
		let result_int_val = ((bytes[0] & 0b0000'0111u8) as u32 << 18u)
			| ((bytes[1] & 0b0011'1111u8) as u32 << 12u)
			| ((bytes[2] & 0b0011'1111u8) as u32 <<  6u)
			| ((bytes[3] & 0b0011'1111u8) as u32 <<  0u);
		return [ result_int_val as char, data + 4];
	}
	else
	{
		return [ '\x00', data ];
	}
}

export function is_valid_unicode_value(val: u32) -> bool
{
	return val <= 0x10'ffff && !(val >= 0xd800 && val <= 0xdfff);
}

export function is_valid_unicode_value(val: i32) -> bool
{
	return val <= 0x10'ffff as i32 && !(val >= 0xd800 as i32 && val <= 0xdfff as i32);
}
