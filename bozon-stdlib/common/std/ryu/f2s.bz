// Copyright 2018 Ulf Adams
//
// The contents of this file may be used under the terms of the Apache License,
// Version 2.0.
//
//    (See accompanying file LICENSE-Apache or copy at
//     http://www.apache.org/licenses/LICENSE-2.0)
//
// Alternatively, the contents of this file may be used under the terms of
// the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE-Boost or copy at
//     https://www.boost.org/LICENSE_1_0.txt)
//
// Unless required by applicable law or agreed to in writing, this software
// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.

// Runtime compiler options:
// -DRYU_DEBUG Generate verbose debugging output to stdout.


import common;
import f2s_intrinsics;
import f2s_full_table;
import digit_table;

import std::utils;
import std::libc::stdlib;

consteval FLOAT_MANTISSA_BITS = 23;
consteval FLOAT_EXPONENT_BITS = 8;
consteval FLOAT_BIAS = 127;

// A floating decimal representing m * 10^e.
struct floating_decimal_32
{
	.mantissa: uint32;
	// Decimal exponent's range is -45 to 38
	// inclusive, and can fit in a short if needed.
	.exponent: int32;
}

function f2d(ieeeMantissa: uint32, ieeeExponent: uint32) -> floating_decimal_32
{
	let e2: int32;
	let m2: uint32;
	if (ieeeExponent == 0)
	{
		// We subtract 2 so that the bounds computation has 2 additional bits.
		e2 = 1 - FLOAT_BIAS - FLOAT_MANTISSA_BITS - 2;
		m2 = ieeeMantissa;
	}
	else
	{
		e2 = ieeeExponent as int32 - FLOAT_BIAS - FLOAT_MANTISSA_BITS - 2;
		m2 = (1u32 << FLOAT_MANTISSA_BITS as uint32) | ieeeMantissa;
	}
	const even = (m2 & 1u32) == 0;
	const acceptBounds = even;

	// Step 2: Determine the interval of valid decimal representations.
	const mv = 4 * m2;
	const mp = 4 * m2 + 2;
	// Implicit bool -> int conversion. True is 1, false is 0.
	const mmShift = (ieeeMantissa != 0 || ieeeExponent <= 1) as uint32;
	const mm = 4 * m2 - 1 - mmShift;

	// Step 3: Convert to a decimal power base using 64-bit arithmetic.
	let vr: uint32;
	let vp: uint32;
	let vm: uint32;
	let e10: int32;
	let vmIsTrailingZeros = false;
	let vrIsTrailingZeros = false;
	let lastRemovedDigit = 0u8;
	if (e2 >= 0)
	{
		const q = log10Pow2(e2 as uint32);
		e10 = q as int32;
		const k = FLOAT_POW5_INV_BITCOUNT + pow5bits(q) as int32 - 1;
		const i = -e2 + q as int32 + k;
		vr = mulPow5InvDivPow2(mv, q, i as uint32);
		vp = mulPow5InvDivPow2(mp, q, i as uint32);
		vm = mulPow5InvDivPow2(mm, q, i as uint32);
		if (q != 0 && (vp - 1) / 10 <= vm / 10)
		{
			// We need to know one removed digit even if we are not going to loop below. We could use
			// q = X - 1 above, except that would require 33 bits for the result, and we've found that
			// 32-bit arithmetic is faster even on 64-bit machines.
			const l = FLOAT_POW5_INV_BITCOUNT + pow5bits(q - 1) as int32 - 1;
			lastRemovedDigit = (mulPow5InvDivPow2(mv, q - 1, (-e2 + q as int32 - 1 + l) as uint32) % 10) as uint8;
		}
		if (q <= 9)
		{
			// The largest power of 5 that fits in 24 bits is 5^10, but q <= 9 seems to be safe as well.
			// Only one of mp, mv, and mm can be a multiple of 5, if any.
			if (mv % 5 == 0)
			{
				vrIsTrailingZeros = multipleOfPowerOf5_32(mv, q);
			}
			else if (acceptBounds)
			{
				vmIsTrailingZeros = multipleOfPowerOf5_32(mm, q);
			}
			else
			{
				vp -= multipleOfPowerOf5_32(mp, q) as uint32;
			}
		}
	}
	else
	{
		const q = log10Pow5(-e2 as uint32);
		e10 = q as int32 + e2;
		const i = -e2 - q as int32;
		const k = pow5bits(i as uint32) as int32 - FLOAT_POW5_BITCOUNT;
		let j = q as int32 - k;
		vr = mulPow5divPow2(mv, i as uint32, j as uint32);
		vp = mulPow5divPow2(mp, i as uint32, j as uint32);
		vm = mulPow5divPow2(mm, i as uint32, j as uint32);
		if (q != 0 && (vp - 1) / 10 <= vm / 10)
		{
			j = q as int32 - 1 - (pow5bits((i + 1) as uint32) as int32 - FLOAT_POW5_BITCOUNT);
			lastRemovedDigit = (mulPow5divPow2(mv, (i + 1) as uint32, j as uint32) % 10) as uint8;
		}
		if (q <= 1)
		{
			// {vr,vp,vm} is trailing zeros if {mv,mp,mm} has at least q trailing 0 bits.
			// mv = 4 * m2, so it always has at least two trailing 0 bits.
			vrIsTrailingZeros = true;
			if (acceptBounds)
			{
				// mm = mv - 1 - mmShift, so it has 1 trailing 0 bit iff mmShift == 1.
				vmIsTrailingZeros = mmShift == 1;
			}
			else
			{
				// mp = mv + 2, so it always has at least one trailing 0 bit.
				--vp;
			}
		}
		else if (q < 31) // TODO(ulfjack): Use a tighter bound here.
		{
			vrIsTrailingZeros = multipleOfPowerOf2_32(mv, q - 1);
		}
	}

	// Step 4: Find the shortest decimal representation in the interval of valid representations.
	let removed = 0i32;
	let output: uint32;
	if (vmIsTrailingZeros || vrIsTrailingZeros)
	{
		// General case, which happens rarely (~4.0%).
		while (vp / 10 > vm / 10)
		{
			// https://bugs.llvm.org/show_bug.cgi?id=23106
			// The compiler does not realize that vm % 10 can be computed from vm / 10
			// as vm - (vm / 10) * 10.
			vmIsTrailingZeros &= vm - (vm / 10) * 10 == 0;
			vrIsTrailingZeros &= lastRemovedDigit == 0;
			lastRemovedDigit = (vr % 10) as uint8;
			vr /= 10;
			vp /= 10;
			vm /= 10;
			++removed;
		}
		if (vmIsTrailingZeros)
		{
			while (vm % 10 == 0)
			{
				vrIsTrailingZeros &= lastRemovedDigit == 0;
				lastRemovedDigit = (vr % 10) as uint8;
				vr /= 10;
				vp /= 10;
				vm /= 10;
				++removed;
			}
		}
		if (vrIsTrailingZeros && lastRemovedDigit == 5 && vr % 2 == 0)
		{
			// Round even if the exact number is .....50..0.
			lastRemovedDigit = 4;
		}
		// We need to take vr + 1 if vr is outside bounds or we need to round up.
		output = vr + ((vr == vm && (!acceptBounds || !vmIsTrailingZeros)) || lastRemovedDigit >= 5) as uint32;
	}
	else
	{
		// Specialized for the common case (~96.0%). Percentages below are relative to this.
		// Loop iterations below (approximately):
		// 0: 13.6%, 1: 70.7%, 2: 14.1%, 3: 1.39%, 4: 0.14%, 5+: 0.01%
		while (vp / 10 > vm / 10)
		{
			lastRemovedDigit = (vr % 10) as uint8;
			vr /= 10;
			vp /= 10;
			vm /= 10;
			++removed;
		}
		// We need to take vr + 1 if vr is outside bounds or we need to round up.
		output = vr + (vr == vm || lastRemovedDigit >= 5) as uint32;
	}
	const exp = e10 + removed;

	let fd: floating_decimal_32;
	fd.exponent = exp;
	fd.mantissa = output;
	return fd;
}

function to_chars(v: floating_decimal_32, sign: bool, result: *uint8) -> int32
{
	// Step 5: Print the decimal representation.
	let index = 0i32;
	if (sign)
	{
		*(result + index) = '-' as uint8;
		++index;
	}

	let output = v.mantissa;
	const olength = decimalLength9(output);

	// Print the decimal digits.
	// The following code is equivalent to:
	// for (uint32_t i = 0; i < olength - 1; ++i) {
	//   const uint32_t c = output % 10; output /= 10;
	//   result[index + olength - i] = (char) ('0' + c);
	// }
	// result[index] = '0' + output % 10;
	let i = 0u32;
	while (output >= 10000)
	{
		// https://bugs.llvm.org/show_bug.cgi?id=38217
		const c = output - 10000 * (output / 10000);
		output /= 10000;
		const c0 = (c % 100) << 1;
		const c1 = (c / 100) << 1;
		trivially_copy_values(result + index + olength - i - 1, DIGIT_TABLE.begin() + c0, 2);
		trivially_copy_values(result + index + olength - i - 3, DIGIT_TABLE.begin() + c1, 2);
		i += 4;
	}
	if (output >= 100)
	{
		const c = (output % 100) << 1;
		output /= 100;
		trivially_copy_values(result + index + olength - i - 1, DIGIT_TABLE.begin() + c, 2);
		i += 2;
	}
	if (output >= 10)
	{
		const c = output << 1;
		// We can't use memcpy here: the decimal dot goes between these two digits.
		*(result + index + olength - i) = DIGIT_TABLE[c + 1];
		*(result + index) = DIGIT_TABLE[c];
	}
	else
	{
		*(result + index) = ('0' + output) as uint8;
	}

	// Print decimal point if needed.
	if (olength > 1)
	{
		*(result + index + 1) = '.' as uint8;
		index += olength as int32 + 1;
	}
	else
	{
		++index;
	}

	// Print the exponent.
	*(result + index) = 'E' as uint8;
	++index;
	let exp = v.exponent + olength as int32 - 1;
	if (exp < 0)
	{
		*(result + index) = '-' as uint8;
		++index;
		exp = -exp;
	}

	if (exp >= 10)
	{
		trivially_copy_values(result + index, DIGIT_TABLE.begin() + 2 * exp, 2);
		index += 2;
	}
	else
	{
		*(result + index) = ('0' + exp) as uint8;
		++index;
	}

	return index;
}

export function f2s_buffered_n(f: float32, result: *uint8) -> int32
{
	// Step 1: Decode the floating-point number, and unify normalized and subnormal cases.
	const bits = float_to_bits(f);

	// Decode bits into sign, mantissa, and exponent.
	const ieeeSign = ((bits >> (FLOAT_MANTISSA_BITS + FLOAT_EXPONENT_BITS) as uint32) & 1u32) != 0;
	const ieeeMantissa = bits & ((1u32 << FLOAT_MANTISSA_BITS as uint32) - 1);
	const ieeeExponent = (bits >> FLOAT_MANTISSA_BITS as uint32) & ((1u32 << FLOAT_EXPONENT_BITS as uint32) - 1);

	// Case distinction; exit early for the easy cases.
	if (ieeeExponent == ((1u32 << FLOAT_EXPONENT_BITS as uint32) - 1) || (ieeeExponent == 0 && ieeeMantissa == 0))
	{
		return copy_special_str(result, ieeeSign, ieeeExponent != 0, ieeeMantissa != 0);
	}

	const v = f2d(ieeeMantissa, ieeeExponent);
	return to_chars(v, ieeeSign, result);
}

export function f2s_buffered(f: float32, result: *uint8)
{
	const index = f2s_buffered_n(f, result);

	// Terminate the string.
	*(result + index) = 0;
}

export function f2s(f: float32) -> ?*uint8
{
	const buffer_alloc = libc::malloc(16);
	if (buffer_alloc == null)
	{
		return null;
	}
	const result = __builtin_pointer_cast(*uint8, buffer_alloc.get_value());
	f2s_buffered(f, result);
	return result;
}


//
// addition by me
//

export function f2s_shortest(f: float32, result: *uint8) -> *uint8
{
	// Step 1: Decode the floating-point number, and unify normalized and subnormal cases.
	const bits = float_to_bits(f);

	// Decode bits into sign, mantissa, and exponent.
	const ieeeSign = ((bits >> (FLOAT_MANTISSA_BITS + FLOAT_EXPONENT_BITS) as uint32) & 1u32) != 0;
	const ieeeMantissa = bits & ((1u32 << FLOAT_MANTISSA_BITS as uint32) - 1);
	const ieeeExponent = (bits >> FLOAT_MANTISSA_BITS as uint32) & ((1u32 << FLOAT_EXPONENT_BITS as uint32) - 1);

	// Case distinction; exit early for the easy cases.
	if (ieeeExponent == ((1u32 << FLOAT_EXPONENT_BITS as uint32) - 1) || (ieeeExponent == 0 && ieeeMantissa == 0))
	{
		return copy_short_special_str(result, ieeeSign, ieeeExponent != 0, ieeeMantissa != 0);
	}

	const v = f2d(ieeeMantissa, ieeeExponent);
	return to_chars_shortest(v, ieeeSign, result);
}

function to_chars_fixed(v: floating_decimal_32, out: *uint8) -> *uint8
{
	// Step 5: Print the decimal representation.
	let output = v.mantissa;
	const olength = decimalLength9(output);

	const actual_exponent = olength as int32 - 1 + v.exponent;

	if (actual_exponent < 0)
	{
		consteval s = "0.000";
		trivially_copy_values(out, s.begin_ptr(), (-actual_exponent + 1) as usize);
		out += -actual_exponent;
	}

	// Print the decimal digits.
	// The following code is equivalent to:
	// for (uint32_t i = 0; i < olength - 1; ++i) {
	//   const uint32_t c = output % 10; output /= 10;
	//   result[index + olength - i] = (char) ('0' + c);
	// }
	// result[index] = '0' + output % 10;
	let i = 0u32;
	while (output >= 10000)
	{
		// https://bugs.llvm.org/show_bug.cgi?id=38217
		const c = output - 10000 * (output / 10000);
		output /= 10000;
		const c0 = (c % 100) << 1;
		const c1 = (c / 100) << 1;
		trivially_copy_values(out + olength - i - 1, DIGIT_TABLE.begin() + c0, 2);
		trivially_copy_values(out + olength - i - 3, DIGIT_TABLE.begin() + c1, 2);
		i += 4;
	}
	if (output >= 100)
	{
		const c = (output % 100) << 1;
		output /= 100;
		trivially_copy_values(out + olength - i - 1, DIGIT_TABLE.begin() + c, 2);
		i += 2;
	}
	if (output >= 10)
	{
		const c = output << 1;
		// We can't use memcpy here: the decimal dot goes between these two digits.
		trivially_copy_values(out + 1, DIGIT_TABLE.begin() + c, 2);
		// *(out + olength - i) = DIGIT_TABLE[c + 1];
		// *out = DIGIT_TABLE[c];
	}
	else
	{
		*(out + 1) = ('0' + output) as uint8;
	}

	// print trailing zeros
	if (v.exponent >= 0)
	{
		memset(out + olength + 1, '0' as uint8, v.exponent as usize);
	}

	if (actual_exponent >= 0)
	{
		memmove(out, out + 1, (actual_exponent + 1) as usize);
		// Print decimal point
		*(out + actual_exponent + 1) = '.' as uint8;
	}
	out += olength + 1;
	if (v.exponent >= 0)
	{
		out += v.exponent;
		*out = '0' as uint8;
		++out;
	}
	return out;
}

function to_chars_scientific(v: floating_decimal_32, out: *uint8) -> *uint8
{
	// Step 5: Print the decimal representation.
	let output = v.mantissa;
	const olength = decimalLength9(output);

	// Print the decimal digits.
	// The following code is equivalent to:
	// for (uint32_t i = 0; i < olength - 1; ++i) {
	//   const uint32_t c = output % 10; output /= 10;
	//   result[index + olength - i] = (char) ('0' + c);
	// }
	// result[index] = '0' + output % 10;
	let i = 0u32;
	while (output >= 10000)
	{
		// https://bugs.llvm.org/show_bug.cgi?id=38217
		const c = output - 10000 * (output / 10000);
		output /= 10000;
		const c0 = (c % 100) << 1;
		const c1 = (c / 100) << 1;
		trivially_copy_values(out + olength - i - 1, DIGIT_TABLE.begin() + c0, 2);
		trivially_copy_values(out + olength - i - 3, DIGIT_TABLE.begin() + c1, 2);
		i += 4;
	}
	if (output >= 100)
	{
		const c = (output % 100) << 1;
		output /= 100;
		trivially_copy_values(out + olength - i - 1, DIGIT_TABLE.begin() + c, 2);
		i += 2;
	}
	if (output >= 10)
	{
		const c = output << 1;
		// We can't use memcpy here: the decimal dot goes between these two digits.
		*(out + olength - i) = DIGIT_TABLE[c + 1];
		*out = DIGIT_TABLE[c];
	}
	else
	{
		*out = ('0' + output) as uint8;
	}

	// Print decimal point if needed.
	if (olength > 1)
	{
		*(out + 1) = '.' as uint8;
		out += olength + 1;
	}
	else
	{
		++out;
	}

	// Print the exponent.
	*out = 'e' as uint8;
	++out;
	let exp = v.exponent + olength as int32 - 1;
	if (exp < 0)
	{
		*out = '-' as uint8;
		++out;
		exp = -exp;
	}
	else
	{
		*out = '+' as uint8;
		++out;
	}

	trivially_copy_values(out, DIGIT_TABLE.begin() + 2 * exp, 2);
	out += 2;

	return out;
}

function to_chars_shortest(v: floating_decimal_32, sign: bool, out: *uint8) -> *uint8
{
	if (sign)
	{
		*out = '-' as uint8;
		++out;
	}

	const olength = decimalLength9(v.mantissa) as int32;
	const actual_exponent = olength - 1 + v.exponent;

	if (actual_exponent >= -4 && actual_exponent <= 6)
	{
		return to_chars_fixed(v, out);
	}
	else
	{
		return to_chars_scientific(v, out);
	}
}
