// Copyright 2018 Ulf Adams
//
// The contents of this file may be used under the terms of the Apache License,
// Version 2.0.
//
//    (See accompanying file LICENSE-Apache or copy at
//     http://www.apache.org/licenses/LICENSE-2.0)
//
// Alternatively, the contents of this file may be used under the terms of
// the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE-Boost or copy at
//     https://www.boost.org/LICENSE_1_0.txt)
//
// Unless required by applicable law or agreed to in writing, this software
// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.

// The contents of this file are a direct translation of the corresponding source
// file(s) found in https://github.com/ulfjack/ryu/tree/master/ryu from C to bozon.

// Runtime compiler options:
// -DRYU_DEBUG Generate verbose debugging output to stdout.


import common;
import f2s_intrinsics;
import f2s_full_table;
import digit_table;

import std::utils;
import std::libc::stdlib;

consteval FLOAT_MANTISSA_BITS = 23;
consteval FLOAT_EXPONENT_BITS = 8;
consteval FLOAT_BIAS = 127;

// A floating decimal representing m * 10^e.
struct floating_decimal_32
{
	.mantissa: u32;
	// Decimal exponent's range is -45 to 38
	// inclusive, and can fit in a short if needed.
	.exponent: i32;
}

function f2d(ieeeMantissa: u32, ieeeExponent: u32) -> floating_decimal_32
{
	mut e2: i32;
	mut m2: u32;
	if (ieeeExponent == 0)
	{
		// We subtract 2 so that the bounds computation has 2 additional bits.
		e2 = 1 - FLOAT_BIAS - FLOAT_MANTISSA_BITS - 2;
		m2 = ieeeMantissa;
	}
	else
	{
		e2 = ieeeExponent as i32 - FLOAT_BIAS - FLOAT_MANTISSA_BITS - 2;
		m2 = (1u32 << FLOAT_MANTISSA_BITS as u32) | ieeeMantissa;
	}
	let even = (m2 & 1u32) == 0;
	let acceptBounds = even;

	// Step 2: Determine the interval of valid decimal representations.
	let mv = 4 * m2;
	let mp = 4 * m2 + 2;
	// Implicit bool -> int conversion. True is 1, false is 0.
	let mmShift = (ieeeMantissa != 0 || ieeeExponent <= 1) as u32;
	let mm = 4 * m2 - 1 - mmShift;

	// Step 3: Convert to a decimal power base using 64-bit arithmetic.
	mut vr: u32;
	mut vp: u32;
	mut vm: u32;
	mut e10: i32;
	mut vmIsTrailingZeros = false;
	mut vrIsTrailingZeros = false;
	mut lastRemovedDigit = 0u8;
	if (e2 >= 0)
	{
		let q = log10Pow2(e2 as u32);
		e10 = q as i32;
		let k = FLOAT_POW5_INV_BITCOUNT + pow5bits(q) as i32 - 1;
		let i = -e2 + q as i32 + k;
		vr = mulPow5InvDivPow2(mv, q, i as u32);
		vp = mulPow5InvDivPow2(mp, q, i as u32);
		vm = mulPow5InvDivPow2(mm, q, i as u32);
		if (q != 0 && (vp - 1) / 10 <= vm / 10)
		{
			// We need to know one removed digit even if we are not going to loop below. We could use
			// q = X - 1 above, except that would require 33 bits for the result, and we've found that
			// 32-bit arithmetic is faster even on 64-bit machines.
			let l = FLOAT_POW5_INV_BITCOUNT + pow5bits(q - 1) as i32 - 1;
			lastRemovedDigit = (mulPow5InvDivPow2(mv, q - 1, (-e2 + q as i32 - 1 + l) as u32) % 10) as u8;
		}
		if (q <= 9)
		{
			// The largest power of 5 that fits in 24 bits is 5^10, but q <= 9 seems to be safe as well.
			// Only one of mp, mv, and mm can be a multiple of 5, if any.
			if (mv % 5 == 0)
			{
				vrIsTrailingZeros = multipleOfPowerOf5_32(mv, q);
			}
			else if (acceptBounds)
			{
				vmIsTrailingZeros = multipleOfPowerOf5_32(mm, q);
			}
			else
			{
				vp -= multipleOfPowerOf5_32(mp, q) as u32;
			}
		}
	}
	else
	{
		let q = log10Pow5(-e2 as u32);
		e10 = q as i32 + e2;
		let i = -e2 - q as i32;
		let k = pow5bits(i as u32) as i32 - FLOAT_POW5_BITCOUNT;
		mut j = q as i32 - k;
		vr = mulPow5divPow2(mv, i as u32, j as u32);
		vp = mulPow5divPow2(mp, i as u32, j as u32);
		vm = mulPow5divPow2(mm, i as u32, j as u32);
		if (q != 0 && (vp - 1) / 10 <= vm / 10)
		{
			j = q as i32 - 1 - (pow5bits((i + 1) as u32) as i32 - FLOAT_POW5_BITCOUNT);
			lastRemovedDigit = (mulPow5divPow2(mv, (i + 1) as u32, j as u32) % 10) as u8;
		}
		if (q <= 1)
		{
			// {vr,vp,vm} is trailing zeros if {mv,mp,mm} has at least q trailing 0 bits.
			// mv = 4 * m2, so it always has at least two trailing 0 bits.
			vrIsTrailingZeros = true;
			if (acceptBounds)
			{
				// mm = mv - 1 - mmShift, so it has 1 trailing 0 bit iff mmShift == 1.
				vmIsTrailingZeros = mmShift == 1;
			}
			else
			{
				// mp = mv + 2, so it always has at least one trailing 0 bit.
				--vp;
			}
		}
		else if (q < 31) // TODO(ulfjack): Use a tighter bound here.
		{
			vrIsTrailingZeros = multipleOfPowerOf2_32(mv, q - 1);
		}
	}

	// Step 4: Find the shortest decimal representation in the interval of valid representations.
	mut removed = 0i32;
	mut output: u32;
	if (vmIsTrailingZeros || vrIsTrailingZeros)
	{
		// General case, which happens rarely (~4.0%).
		while (vp / 10 > vm / 10)
		{
			// https://bugs.llvm.org/show_bug.cgi?id=23106
			// The compiler does not realize that vm % 10 can be computed from vm / 10
			// as vm - (vm / 10) * 10.
			vmIsTrailingZeros &= vm - (vm / 10) * 10 == 0;
			vrIsTrailingZeros &= lastRemovedDigit == 0;
			lastRemovedDigit = (vr % 10) as u8;
			vr /= 10;
			vp /= 10;
			vm /= 10;
			++removed;
		}
		if (vmIsTrailingZeros)
		{
			while (vm % 10 == 0)
			{
				vrIsTrailingZeros &= lastRemovedDigit == 0;
				lastRemovedDigit = (vr % 10) as u8;
				vr /= 10;
				vp /= 10;
				vm /= 10;
				++removed;
			}
		}
		if (vrIsTrailingZeros && lastRemovedDigit == 5 && vr % 2 == 0)
		{
			// Round even if the exact number is .....50..0.
			lastRemovedDigit = 4;
		}
		// We need to take vr + 1 if vr is outside bounds or we need to round up.
		output = vr + ((vr == vm && (!acceptBounds || !vmIsTrailingZeros)) || lastRemovedDigit >= 5) as u32;
	}
	else
	{
		// Specialized for the common case (~96.0%). Percentages below are relative to this.
		// Loop iterations below (approximately):
		// 0: 13.6%, 1: 70.7%, 2: 14.1%, 3: 1.39%, 4: 0.14%, 5+: 0.01%
		while (vp / 10 > vm / 10)
		{
			lastRemovedDigit = (vr % 10) as u8;
			vr /= 10;
			vp /= 10;
			vm /= 10;
			++removed;
		}
		// We need to take vr + 1 if vr is outside bounds or we need to round up.
		output = vr + (vr == vm || lastRemovedDigit >= 5) as u32;
	}
	let exp = e10 + removed;

	mut fd = floating_decimal_32();
	fd.exponent = exp;
	fd.mantissa = output;
	return fd;
}

function to_chars(v: floating_decimal_32, sign: bool, result: *mut u8) -> i32
{
	// Step 5: Print the decimal representation.
	mut index = 0i32;
	if (sign)
	{
		*(result + index) = '-' as u8;
		++index;
	}

	mut output = v.mantissa;
	let olength = decimalLength9(output);

	// Print the decimal digits.
	// The following code is equivalent to:
	// for (uint32_t i = 0; i < olength - 1; ++i) {
	//   const uint32_t c = output % 10; output /= 10;
	//   result[index + olength - i] = (char) ('0' + c);
	// }
	// result[index] = '0' + output % 10;
	mut i = 0u32;
	while (output >= 10000)
	{
		// https://bugs.llvm.org/show_bug.cgi?id=38217
		let c = output - 10000 * (output / 10000);
		output /= 10000;
		let c0 = (c % 100) << 1;
		let c1 = (c / 100) << 1;
		std::trivially_copy_values(result + index + olength - i - 1, DIGIT_TABLE.begin() + c0, 2);
		std::trivially_copy_values(result + index + olength - i - 3, DIGIT_TABLE.begin() + c1, 2);
		i += 4;
	}
	if (output >= 100)
	{
		let c = (output % 100) << 1;
		output /= 100;
		std::trivially_copy_values(result + index + olength - i - 1, DIGIT_TABLE.begin() + c, 2);
		i += 2;
	}
	if (output >= 10)
	{
		let c = output << 1;
		// We can't use memcpy here: the decimal dot goes between these two digits.
		*(result + index + olength - i) = DIGIT_TABLE[c + 1];
		*(result + index) = DIGIT_TABLE[c];
	}
	else
	{
		*(result + index) = ('0' + output) as u8;
	}

	// Print decimal point if needed.
	if (olength > 1)
	{
		*(result + index + 1) = '.' as u8;
		index += olength as i32 + 1;
	}
	else
	{
		++index;
	}

	// Print the exponent.
	*(result + index) = 'E' as u8;
	++index;
	mut exp = v.exponent + olength as i32 - 1;
	if (exp < 0)
	{
		*(result + index) = '-' as u8;
		++index;
		exp = -exp;
	}

	if (exp >= 10)
	{
		std::trivially_copy_values(result + index, DIGIT_TABLE.begin() + 2 * exp, 2);
		index += 2;
	}
	else
	{
		*(result + index) = ('0' + exp) as u8;
		++index;
	}

	return index;
}

export function f2s_buffered_n(f: f32, result: *mut u8) -> i32
{
	// Step 1: Decode the floating-point number, and unify normalized and subnormal cases.
	let bits = float_to_bits(f);

	// Decode bits into sign, mantissa, and exponent.
	let ieeeSign = ((bits >> (FLOAT_MANTISSA_BITS + FLOAT_EXPONENT_BITS) as u32) & 1u32) != 0;
	let ieeeMantissa = bits & ((1u32 << FLOAT_MANTISSA_BITS as u32) - 1);
	let ieeeExponent = (bits >> FLOAT_MANTISSA_BITS as u32) & ((1u32 << FLOAT_EXPONENT_BITS as u32) - 1);

	// Case distinction; exit early for the easy cases.
	if (ieeeExponent == ((1u32 << FLOAT_EXPONENT_BITS as u32) - 1) || (ieeeExponent == 0 && ieeeMantissa == 0))
	{
		return copy_special_str(result, ieeeSign, ieeeExponent != 0, ieeeMantissa != 0);
	}

	let v = f2d(ieeeMantissa, ieeeExponent);
	return to_chars(v, ieeeSign, result);
}

export function f2s_buffered(f: f32, result: *mut u8)
{
	let index = f2s_buffered_n(f, result);

	// Terminate the string.
	*(result + index) = 0;
}

export function f2s(f: f32) -> ?*mut u8
{
	let buffer_alloc = std::libc::malloc(16);
	if (buffer_alloc == null)
	{
		return null;
	}
	let result = __builtin_pointer_cast(*mut u8, buffer_alloc.get_value());
	f2s_buffered(f, result);
	return result;
}


//
// addition by me
//

export function f2s_shortest(f: f32, result: *mut u8) -> *mut u8
{
	// Step 1: Decode the floating-point number, and unify normalized and subnormal cases.
	let bits = float_to_bits(f);

	// Decode bits into sign, mantissa, and exponent.
	let ieeeSign = ((bits >> (FLOAT_MANTISSA_BITS + FLOAT_EXPONENT_BITS) as u32) & 1u32) != 0;
	let ieeeMantissa = bits & ((1u32 << FLOAT_MANTISSA_BITS as u32) - 1);
	let ieeeExponent = (bits >> FLOAT_MANTISSA_BITS as u32) & ((1u32 << FLOAT_EXPONENT_BITS as u32) - 1);

	// Case distinction; exit early for the easy cases.
	if (ieeeExponent == ((1u32 << FLOAT_EXPONENT_BITS as u32) - 1) || (ieeeExponent == 0 && ieeeMantissa == 0))
	{
		return copy_short_special_str(result, ieeeSign, ieeeExponent != 0, ieeeMantissa != 0);
	}

	let v = f2d(ieeeMantissa, ieeeExponent);
	return to_chars_shortest(v, ieeeSign, result);
}

function to_chars_fixed(v: floating_decimal_32, mut out: *mut u8) -> *mut u8
{
	// Step 5: Print the decimal representation.
	mut output = v.mantissa;
	let olength = decimalLength9(output);

	let actual_exponent = olength as i32 - 1 + v.exponent;

	if (actual_exponent < 0)
	{
		consteval s = "0.000";
		std::trivially_copy_values(out, s.begin_ptr(), (-actual_exponent + 1) as usize);
		out += -actual_exponent;
	}

	// Print the decimal digits.
	// The following code is equivalent to:
	// for (uint32_t i = 0; i < olength - 1; ++i) {
	//   const uint32_t c = output % 10; output /= 10;
	//   result[index + olength - i] = (char) ('0' + c);
	// }
	// result[index] = '0' + output % 10;
	mut i = 0u32;
	while (output >= 10000)
	{
		// https://bugs.llvm.org/show_bug.cgi?id=38217
		let c = output - 10000 * (output / 10000);
		output /= 10000;
		let c0 = (c % 100) << 1;
		let c1 = (c / 100) << 1;
		std::trivially_copy_values(out + olength - i - 1, DIGIT_TABLE.begin() + c0, 2);
		std::trivially_copy_values(out + olength - i - 3, DIGIT_TABLE.begin() + c1, 2);
		i += 4;
	}
	if (output >= 100)
	{
		let c = (output % 100) << 1;
		output /= 100;
		std::trivially_copy_values(out + olength - i - 1, DIGIT_TABLE.begin() + c, 2);
		i += 2;
	}
	if (output >= 10)
	{
		let c = output << 1;
		// We can't use memcpy here: the decimal dot goes between these two digits.
		std::trivially_copy_values(out + 1, DIGIT_TABLE.begin() + c, 2);
		// *(out + olength - i) = DIGIT_TABLE[c + 1];
		// *out = DIGIT_TABLE[c];
	}
	else
	{
		*(out + 1) = ('0' + output) as u8;
	}

	// print trailing zeros
	if (v.exponent >= 0)
	{
		std::trivially_set_values(out + olength + 1, '0' as u8, v.exponent as usize);
	}

	if (actual_exponent >= 0)
	{
		std::trivially_copy_overlapping_values(out, out + 1, (actual_exponent + 1) as usize);
		// Print decimal point
		*(out + actual_exponent + 1) = '.' as u8;
	}
	out += olength + 1;
	if (v.exponent >= 0)
	{
		out += v.exponent;
		*out = '0' as u8;
		++out;
	}
	return out;
}

function to_chars_scientific(v: floating_decimal_32, mut out: *mut u8) -> *mut u8
{
	// Step 5: Print the decimal representation.
	mut output = v.mantissa;
	let olength = decimalLength9(output);

	// Print the decimal digits.
	// The following code is equivalent to:
	// for (uint32_t i = 0; i < olength - 1; ++i) {
	//   const uint32_t c = output % 10; output /= 10;
	//   result[index + olength - i] = (char) ('0' + c);
	// }
	// result[index] = '0' + output % 10;
	mut i = 0u32;
	while (output >= 10000)
	{
		// https://bugs.llvm.org/show_bug.cgi?id=38217
		let c = output - 10000 * (output / 10000);
		output /= 10000;
		let c0 = (c % 100) << 1;
		let c1 = (c / 100) << 1;
		std::trivially_copy_values(out + olength - i - 1, DIGIT_TABLE.begin() + c0, 2);
		std::trivially_copy_values(out + olength - i - 3, DIGIT_TABLE.begin() + c1, 2);
		i += 4;
	}
	if (output >= 100)
	{
		let c = (output % 100) << 1;
		output /= 100;
		std::trivially_copy_values(out + olength - i - 1, DIGIT_TABLE.begin() + c, 2);
		i += 2;
	}
	if (output >= 10)
	{
		let c = output << 1;
		// We can't use memcpy here: the decimal dot goes between these two digits.
		*(out + olength - i) = DIGIT_TABLE[c + 1];
		*out = DIGIT_TABLE[c];
	}
	else
	{
		*out = ('0' + output) as u8;
	}

	// Print decimal point if needed.
	if (olength > 1)
	{
		*(out + 1) = '.' as u8;
		out += olength + 1;
	}
	else
	{
		++out;
	}

	// Print the exponent.
	*out = 'e' as u8;
	++out;
	mut exp = v.exponent + olength as i32 - 1;
	if (exp < 0)
	{
		*out = '-' as u8;
		++out;
		exp = -exp;
	}
	else
	{
		*out = '+' as u8;
		++out;
	}

	std::trivially_copy_values(out, DIGIT_TABLE.begin() + 2 * exp, 2);
	out += 2;

	return out;
}

function to_chars_shortest(v: floating_decimal_32, sign: bool, mut out: *mut u8) -> *mut u8
{
	if (sign)
	{
		*out = '-' as u8;
		++out;
	}

	let olength = decimalLength9(v.mantissa) as i32;
	let actual_exponent = olength - 1 + v.exponent;

	if (actual_exponent >= -4 && actual_exponent <= 6)
	{
		return to_chars_fixed(v, out);
	}
	else
	{
		return to_chars_scientific(v, out);
	}
}
