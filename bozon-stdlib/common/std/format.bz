import string;
import print;
import utils;
import unicode;
import bit;
import math;
import ryu::common;
import ryu::d2s;
import ryu::f2s;
import ryu::d2fixed;
import ryu::digit_table;
import meta::comptime;

export struct format_buffer
{
	._str: string;
}

export function write_into(buffer: &mut format_buffer, s: str)
{
	buffer._str += s;
}

export function write_into(buffer: &mut format_buffer, c: char)
{
	buffer._str += c;
}

export function write_into(buffer: &mut format_buffer, c: char, count: usize)
{
	let size = buffer._str.size();
	if (c <= '\x7f')
	{
		buffer._str.resize(size + count, c);
	}
	else
	{
		let [encoded_char, byte_count] = encode_char_utf8(c);
		buffer._str.resize(size + count * byte_count);
		mut it = buffer._str.data() + size;
		for (let _ in 0..count)
		{
			trivially_copy_values(it, encoded_char.begin(), byte_count);
			it += byte_count;
		}
	}
}

export struct format_spec
{
	.fill: char;
	.align: char;
	.sign: char;
	.fmt_kind: char;
	.width: usize;
	.precision: usize;
	.zero_pad: bool;
}

export consteval precision_none = ((-1 as usize));

export function get_default_format_spec() -> format_spec
{
	return format_spec[ '\x00', '\x00', '\x00', '\x00', 0uz, precision_none, false ];
}

function is_valid_align(c: char) -> bool
{
	return c == '<' || c == '^' || c == '>';
}

function is_valid_sign(c: char) -> bool
{
	return c == '+' || c == '-' || c == ' ';
}

function is_number(c: char) -> bool
{
	return c >= '0' && c <= '9';
}

function advance_number(it: &mut ?*uint8, end: ?*uint8)
{
	while (it != end && {
		let c = *it as char;
		c >= '0' && c <= '9'
	})
	{
		++it;
	}
}

function get_number(it: &mut ?*uint8, end: ?*uint8) -> usize
{
	mut result = 0uz;
	while (it != end && {
		let c = *it as char;
		c >= '0' && c <= '9'
	})
	{
		result *= 10;
		result += (*it as char - '0') as usize;
		++it;
	}
	return result;
}

export function get_default_format_spec(fmt_spec: str) -> format_spec
{
	mut result = get_default_format_spec();

	// syntax: [[fill]align][sign][0][width][.precision][kind]
	mut it = fmt_spec.begin_ptr();
	let end = fmt_spec.end_ptr();

	if (it == end)
	{
		return result;
	}
	else if (it + 1 != end && is_valid_align(*(it + 1) as char))
	{
		result.fill = *it as char;
		++it; // fill
		result.align = *it as char;
		++it; // align
	}
	else if (is_valid_align(*it as char))
	{
		result.align = *it as char;
		++it; // align
	}

	if (it != end && is_valid_sign(*it as char))
	{
		result.sign = *it as char;
		++it; // sign
	}
	if (it != end && *it == '0' as uint8)
	{
		result.zero_pad = true;
		++it;
	}
	if (it != end && is_number(*it as char))
	{
		result.width = get_number(it, end);
	}
	if (it != end && *it == '.' as uint8)
	{
		++it; // '.'
		result.precision = get_number(it, end);
	}
	if (it != end && {
		let c = *it as char;
		(c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '%'
	})
	{
		result.fmt_kind = *it as char;
		++it; // kind
	}

	return result;
}

consteval function find_next_bracket(mut it: ?*uint8, end: ?*uint8) -> ?*uint8
{
	for (; it != end; ++it)
	{
		if (*it == '{' as uint8 && (it + 1 == end || *(it + 1) != '{' as uint8))
		{
			return it;
		}
		else if (*it == '{' as uint8)
		{
			// next character must be '{' and can't be the end, so we can safely skip it
			++it;
		}
		else if (*it == '}' as uint8 && (it + 1 == end || *(it + 1) != '}' as uint8))
		{
			return it;
		}
		else if (*it == '}' as uint8)
		{
			// next character must be '}' and can't be the end, so we can safely skip it
			++it;
		}
	}

	return end;
}

consteval function string_find(s: str, c: char) -> ?*uint8
{
	assert(c <= '\x7f');
	mut it = s.begin_ptr();
	let end = s.end_ptr();
	for (; it != end; ++it)
	{
		if (*it == c as uint8)
		{
			return it;
		}
	}
	return end;
}

consteval function check_format_spec_str(
	mut it: ?*uint8,
	end: ?*uint8,
	fmt_str: str,
	mut current_index: usize,
	passed_args_count: usize
) -> usize
{
	assert(it > fmt_str.begin_ptr());
	assert(it < fmt_str.end_ptr());
	let open_bracket_it = it - 1;
	assert(*open_bracket_it == '{' as uint8);
	let is_explicit_index = it != end && is_number(*it as char);
	if (is_explicit_index)
	{
		current_index = get_number(it, end);
	}

	if (current_index >= passed_args_count)
	{
		let position = __builtin_str_from_ptrs(fmt_str.begin_ptr(), open_bracket_it).length();
		let message = if (is_explicit_index) {
			let fmt_str_end = __builtin_str_from_ptrs(open_bracket_it + 1, fmt_str.end_ptr());
			format_unchecked_fmt(
				"invalid format string '{}'; explicit index {} is out of range for {} argument(s) at position {} ('{}')",
				fmt_str, current_index, passed_args_count, position, fmt_str_end
			)
		} else {
			let fmt_str_end = __builtin_str_from_ptrs(open_bracket_it, fmt_str.end_ptr());
			format_unchecked_fmt(
				"invalid format string '{}'; implicit index {} is out of range for {} argument(s) at position {} ('{}')",
				fmt_str, current_index, passed_args_count, position, fmt_str_end
			)
		};
		meta::compile_error(message.as_str());
		return current_index + 1;
	}

	if (it == end)
	{
		return current_index + 1;
	}

	if (*it != ':' as uint8)
	{
		let position = __builtin_str_from_ptrs(fmt_str.begin_ptr(), open_bracket_it).length();
		let message = format_unchecked_fmt(
			"invalid format string '{}'; expected argument index or ':' or '}}' after '{{' at position {} ('{}')",
			fmt_str, position, __builtin_str_from_ptrs(open_bracket_it, fmt_str.end_ptr())
		);
		meta::compile_error(message.as_str());
		return current_index + 1;
	}
	++it; // ':'
	if (it == end)
	{
		return current_index + 1;
	}
	// syntax: [[fill]align][sign][0][width][.precision][kind]

	if (it + 1 != end && is_valid_align(*(it + 1) as char))
	{
		++it; // fill
		++it; // align
	}
	else if (is_valid_align(*it as char))
	{
		++it; // align
	}

	if (it != end && is_valid_sign(*it as char))
	{
		++it; // sign
	}
	advance_number(it, end); // [0][width]
	if (it != end && *it == '.' as uint8)
	{
		++it; // '.'
		if (it == end || !is_number(*it as char))
		{
			let dot_it = it - 1;
			let position = __builtin_str_from_ptrs(fmt_str.begin_ptr(), dot_it).length();
			let fmt_str_end = __builtin_str_from_ptrs(dot_it, fmt_str.end_ptr());
			let message = format_unchecked_fmt(
				"invalid format string '{}'; expected a number after '.' at position {} ('{}')",
				fmt_str, position, fmt_str_end
			);
			meta::compile_error(message.as_str());
			return current_index + 1;
		}
		advance_number(it, end); // precision
	}
	if (it != end && {
		let c = *it as char;
		(c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '%'
	})
	{
		++it; // kind
	}

	if (it != end)
	{
		let position = __builtin_str_from_ptrs(fmt_str.begin_ptr(), it).length();
		let unexpected_chars = __builtin_str_from_ptrs(it, end);
		let fmt_str_end = __builtin_str_from_ptrs(it, fmt_str.end_ptr());
		let message = format_unchecked_fmt(
			"invalid format string '{}'; unexpected characters '{}' at position {} ('{}')",
			fmt_str, unexpected_chars, position, fmt_str_end
		);
		meta::compile_error(message.as_str());
		return current_index + 1;
	}

	return current_index + 1;
}

consteval function check_fmt_str(fmt_str: str, passed_args_count: usize) -> bool
{
	let begin = fmt_str.begin_ptr();
	let end   = fmt_str.end_ptr();
	mut it = begin;

	mut current_index = 0uz;

	while (true)
	{
		let next_bracket = find_next_bracket(it, end);
		if (next_bracket == end)
		{
			// break if we reached the end
			break;
		}

		switch (*next_bracket as char)
		{
			'}' => {
				// stray closing bracket, report only as a warning
				it = next_bracket + 1;
				let position = __builtin_str_from_ptrs(begin, next_bracket).length();
				let message = format_unchecked_fmt(
					"invalid format string '{}'; stray '}}' at position {} ('{}')",
					fmt_str, position, __builtin_str_from_ptrs(next_bracket, end)
				);
				meta::compile_warning(message.as_str());
			},
			'{' => {
				it = next_bracket + 1;
				let closing_bracket_it = string_find(__builtin_str_from_ptrs(it, end), '}');
				if (closing_bracket_it == end)
				{
					let position = __builtin_str_from_ptrs(begin, next_bracket).length();
					let message = format_unchecked_fmt(
						"invalid format string '{}'; unclosed '{{' at position {} ('{}')",
						fmt_str, position, __builtin_str_from_ptrs(next_bracket, end)
					);
					meta::compile_error(message.as_str());
					unreachable;
				}
				current_index = check_format_spec_str(it, closing_bracket_it, fmt_str, current_index, passed_args_count);
				it = closing_bracket_it + 1;
			},
			else => unreachable
		}
	}

	return true;
}

consteval function count_args_in_str(fmt_str: str) -> usize
{
	mut it = fmt_str.begin_ptr();
	let end = fmt_str.end_ptr();

	mut result = 0uz;
	while (true)
	{
		let next_bracket = find_next_bracket(it, end);
		if (next_bracket == end)
		{
			break;
		}
		else if (*next_bracket == '{' as uint8)
		{
			++result;
		}
		it = next_bracket + 1;
	}
	return result;
}

consteval function remove_escaped_brackets(s: str) -> str
{
	mut result = string();
	result.reserve(s.size());

	mut it = s.begin_ptr();
	mut prev_begin = it;
	let end = s.end_ptr();
	for (; it != end; ++it)
	{
		if (
			(*it == '{' as uint8 && it + 1 != end && *(it + 1) == '{' as uint8)
			|| (*it == '}' as uint8 && it + 1 != end && *(it + 1) == '}' as uint8)
		)
		{
			// escaped '{' or '}'
			result += __builtin_str_from_ptrs(prev_begin, it + 1);
			prev_begin = it + 2;
			// second increment will happen at end of the for loop
			++it;
		}
	}
	result += __builtin_str_from_ptrs(prev_begin, end);

	return result.as_str().meta::create_global_string();
}

consteval function get_fmt_spec(inner_str: str) -> str
{
	if (inner_str == "")
	{
		return "";
	}
	assert(inner_str.starts_with(":"));
	return __builtin_str_from_ptrs(inner_str.begin_ptr() + 1, inner_str.end_ptr());
}

consteval function get_fmt_info(fmt_str: str, slices: [: mut str], fmt_specs: [: mut str], indices: [: mut usize])
{
	mut it = fmt_str.begin_ptr();
	mut prev_begin = it;
	let end = fmt_str.end_ptr();
	mut index = 0uz;
	mut arg_index = 0uz;

	mut contains_escaped_bracket = false;
	for (; it != end; ++it)
	{
		if (
			(*it == '{' as uint8 && it + 1 != end && *(it + 1) == '{' as uint8)
			|| (*it == '}' as uint8 && it + 1 != end && *(it + 1) == '}' as uint8)
		)
		{
			// escaped '{' or '}'
			// second increment will happen at end of the for loop
			++it;
			contains_escaped_bracket = true;
		}
		else if (*it == '{' as uint8)
		{
			if (contains_escaped_bracket)
			{
				let s = __builtin_str_from_ptrs(prev_begin, it);
				slices[index] = remove_escaped_brackets(s);
			}
			else
			{
				slices[index] = __builtin_str_from_ptrs(prev_begin, it);
			}
			let closing_bracket_it = string_find(__builtin_str_from_ptrs(it, end), '}');
			assert(closing_bracket_it != end);
			++it;
			if (is_number(*it as char))
			{
				arg_index = get_number(it, closing_bracket_it);
			}
			fmt_specs[index] = get_fmt_spec(__builtin_str_from_ptrs(it, closing_bracket_it));
			indices[index] = arg_index;
			++arg_index;

			contains_escaped_bracket = false; // reset value
			index += 1;
			prev_begin = closing_bracket_it + 1;
			// other increment will happen at the next start of the loop
			it = closing_bracket_it;
		}
	}
	if (contains_escaped_bracket)
	{
		let s = __builtin_str_from_ptrs(prev_begin, it);
		slices[index] = remove_escaped_brackets(s);
	}
	else
	{
		slices[index] = __builtin_str_from_ptrs(prev_begin, it);
	}
}

consteval function get_fmt_info(fmt_str: str, args_count: consteval usize)
	-> [
		[args_count + 1: str],
		[max(args_count, 1): str],
		[max(args_count, 1): usize],
	]
{
	mut result = [
		[args_count + 1: str],
		[max(args_count, 1): str],
		[max(args_count, 1): usize],
	]();
	get_fmt_info(fmt_str, result[0], result[1], result[2]);
	return result;
}

consteval function get_global_indices(start: consteval usize, stop: consteval usize)
	-> [(assert(start <= stop), if (start == stop) { 1 } else { stop - start }): usize]
{
	mut result = [(assert(start <= stop), if (start == stop) { 1 } else { stop - start }): usize]();
	for (let i in start..stop)
	{
		result[i - start] = i;
	}
	return result;
}

function format_into_impl(
	buffer: &mut format_buffer,
	consteval [...global_indices],
	indices: consteval auto,
	slices: [: str],
	fmt_specs: [: str],
	arg_ptrs: &[...*auto]
)
{
	...{
		consteval index = indices[global_indices];
		buffer.write_into(slices[global_indices]);
		arg_ptrs[index]->format_to(buffer, fmt_specs[index]);
	};
}

export function format_into(buffer: &mut format_buffer, fmt_str: consteval str, args: ...#auto)
{
	consteval args_count = count_args_in_str(fmt_str);
	@maybe_unused consteval [slices, fmt_specs, indices] = get_fmt_info(fmt_str, args_count);
	if consteval (slices.size() > 1)
	{
		let arg_ptrs = if consteval (sizeof ...args == 0) {
			[]()
		} else {
			[ ...&args ]
		};
		consteval global_indices = get_global_indices(0uz, args_count);
		buffer.format_into_impl(global_indices, indices, slices, fmt_specs, arg_ptrs);
	}
	buffer.write_into(slices[args_count]);
}

function format_unchecked_fmt(fmt_str: consteval str, args: ...#auto) -> string
{
	mut buffer = format_buffer[ string() ];
	buffer.format_into(fmt_str, ...args);
	return buffer._str.release();
}

export function format(fmt_str: consteval str, args: ...#auto) -> string
{
	consteval passed_args_count = sizeof ...args;
	if consteval (check_fmt_str(fmt_str, passed_args_count))
	{
		return format_unchecked_fmt(fmt_str, ...args);
	}
	else
	{
		return string();
	}
}

export consteval function comptime_format(fmt_str: consteval str, args: ...#auto) -> str
{
	consteval passed_args_count = sizeof ...args;
	if consteval (check_fmt_str(fmt_str, passed_args_count))
	{
		let s = format_unchecked_fmt(fmt_str, ...args);
		return s.as_str().meta::create_global_string();
	}
	else
	{
		return "";
	}
}

export function print(fmt_str: consteval str, arg0: #auto, args: ...#auto)
{
	consteval passed_args_count = 1 + sizeof ...args;
	if consteval (check_fmt_str(fmt_str, passed_args_count))
	{
		mut buf = format_buffer[ string() ];
		buf.format_into(fmt_str, arg0, ...args);
		print_stdout(buf._str.as_str());
	}
}

export function print = print_stdout;


function print_uint_to_reverse_buffer(mut it: *uint8, val: uint64, base: consteval uint64) -> *uint8
{
	if (val == 0)
	{
		--it;
		*it = '0' as uint8;
		return it;
	}
	while (val != 0)
	{
		let digit_val = val % base;
		val /= base;
		if (digit_val < 10)
		{
			--it;
			*it = ('0' + digit_val) as uint8;
		}
		else
		{
			--it;
			*it = ('a' + digit_val - 10) as uint8;
		}
	}
	return it;
}

function decimal_length_u64(n: uint64) -> uint32
{
	return if (n < 10u64) { 1 }
		else if (n < 100u64) { 2 }
		else if (n < 1000u64) { 3 }
		else if (n < 10000u64) { 4 }
		else if (n < 100000u64) { 5 }
		else if (n < 1000000u64) { 6 }
		else if (n < 10000000u64) { 7 }
		else if (n < 100000000u64) { 8 }
		else if (n < 1000000000u64) { 9 }
		else if (n < 10000000000u64) { 10 }
		else if (n < 100000000000u64) { 11 }
		else if (n < 1000000000000u64) { 12 }
		else if (n < 10000000000000u64) { 13 }
		else if (n < 100000000000000u64) { 14 }
		else if (n < 1000000000000000u64) { 15 }
		else if (n < 10000000000000000u64) { 16 }
		else if (n < 100000000000000000u64) { 17 }
		else if (n < 1000000000000000000u64) { 18 }
		else if (n < 10000000000000000000u64) { 19 }
		else { 20 };
}

function print_uint_decimal_to_buffer(mut n: uint64, out: *mut uint8) -> *mut uint8
{
	let output_len = decimal_length_u64(n);
	mut rev_out = out + output_len;
	// basically a copy of number printing in ryu::d2s
	while (n >= 10000)
	{
		let c = n - 10000 * (n / 10000);
		n /= 10000;
		let c0 = (c % 100) * 2;
		let c1 = (c / 100) * 2;
		rev_out -= 4;
		trivially_copy_values(rev_out + 2, ryu::DIGIT_TABLE.begin() + c0, 2);
		trivially_copy_values(rev_out,     ryu::DIGIT_TABLE.begin() + c1, 2);
	}
	if (n >= 100)
	{
		let c = (n % 100) * 2;
		n /= 100;
		rev_out -= 2;
		trivially_copy_values(rev_out, ryu::DIGIT_TABLE.begin() + c, 2);
	}
	if (n >= 10)
	{
		let c = (n % 100) * 2;
		n /= 100;
		rev_out -= 2;
		trivially_copy_values(rev_out, ryu::DIGIT_TABLE.begin() + c, 2);
	}
	else
	{
		rev_out -= 1;
		*rev_out = ('0' + n) as uint8;
	}
	return out + output_len;
}

function print_uint_base_to_buffer(n: uint64, mut out: *mut uint8, base: consteval uint64) -> *mut uint8
{
	if (n == 0)
	{
		*out = '0' as uint8;
		return out + 1;
	}
	static_assert(base == 2 || base == 8);
	consteval bit_width = if (base == 2) { 1u64 } else { 3u64 };
	consteval max_output_len = if (base == 2) { 64u64 } else { 22u64 };
	let output_len = (max_output_len - clz(n) / bit_width) as int32;
	mut i = output_len;
	while (i > 0)
	{
		--i;
		consteval mask = base - 1;
		let c = '0' + ((n >> (i * bit_width as int32)) & mask);
		*out = c as uint8;
		++out;
	}
	return out;
}

function print_uint_hex_to_buffer(n: uint64, mut out: *mut uint8) -> *mut uint8
{
	if (n == 0)
	{
		*out = '0' as uint8;
		return out + 1;
	}
	let output_len = (16 - clz(n) / 4) as int32;
	consteval table: [16: uint8] = [
		'0' as uint8, '1' as uint8,
		'2' as uint8, '3' as uint8,
		'4' as uint8, '5' as uint8,
		'6' as uint8, '7' as uint8,
		'8' as uint8, '9' as uint8,
		'a' as uint8, 'b' as uint8,
		'c' as uint8, 'd' as uint8,
		'e' as uint8, 'f' as uint8,
	];
	mut i = output_len;
	while (i > 0)
	{
		--i;
		let c = table[(n >> (i * 4)) & 0b1111u64];
		*out = c;
		++out;
	}
	return out;
}

function print_uint_HEX_to_buffer(n: uint64, mut out: *mut uint8) -> *mut uint8
{
	if (n == 0)
	{
		*out = '0' as uint8;
		return out + 1;
	}
	let output_len = (16 - clz(n) / 4) as int32;
	consteval table: [16: uint8] = [
		'0' as uint8, '1' as uint8,
		'2' as uint8, '3' as uint8,
		'4' as uint8, '5' as uint8,
		'6' as uint8, '7' as uint8,
		'8' as uint8, '9' as uint8,
		'A' as uint8, 'B' as uint8,
		'C' as uint8, 'D' as uint8,
		'E' as uint8, 'F' as uint8,
	];
	mut i = output_len;
	while (i > 0)
	{
		--i;
		let c = table[(n >> (i * 4)) & 0b1111u64];
		*out = c;
		++out;
	}
	return out;
}

// binary printing has the max number of possible chars
consteval max_uint_string_length = 64uz;

function get_uint_decimal_as_string(n: uint64) -> [[max_uint_string_length: uint8], uint32]
{
	mut result = [[max_uint_string_length: uint8], uint32]();
	let end = print_uint_decimal_to_buffer(n, result[0].begin());
	result[1] = (end - result[0].begin()) as uint32;
	return result;
}

function get_uint_base_as_string(n: uint64, base: consteval uint64) -> [[max_uint_string_length: uint8], uint32]
{
	static_assert(base == 2 || base == 8);
	mut result = [[max_uint_string_length: uint8], uint32]();
	let end = print_uint_base_to_buffer(n, result[0].begin(), base);
	result[1] = (end - result[0].begin()) as uint32;
	return result;
}

function get_uint_hex_as_string(n: uint64, capital: bool) -> [[max_uint_string_length: uint8], uint32]
{
	mut result = [[max_uint_string_length: uint8], uint32]();
	let end = if (capital) {
		print_uint_HEX_to_buffer(n, result[0].begin())
	} else {
		print_uint_hex_to_buffer(n, result[0].begin())
	};
	result[1] = (end - result[0].begin()) as uint32;
	return result;
}

export function format_to(s: str, buffer: &mut format_buffer, fmt_spec: str)
{
	s.format_to(buffer, get_default_format_spec(fmt_spec));
}

export function format_to(s: str, buffer: &mut format_buffer, mut fmt_spec: format_spec)
{
	if (fmt_spec.align == '\x00')
	{
		fmt_spec.align = '<';
	}
	if (fmt_spec.fill == '\x00')
	{
		fmt_spec.fill = ' ';
	}
	switch (fmt_spec.align)
	{
		'<' => {
			let len = s.length();
			buffer.write_into(s);
			if (len < fmt_spec.width)
			{
				buffer.write_into(fmt_spec.fill, fmt_spec.width - len);
			}
		},
		'^' => {
			let len = s.length();
			if (len < fmt_spec.width)
			{
				let diff = fmt_spec.width - len;
				// if the spacing is uneven, prefer left alignment
				buffer.write_into(fmt_spec.fill, diff / 2);
				buffer.write_into(s);
				buffer.write_into(fmt_spec.fill, (diff + 1) / 2);
			}
			else
			{
				buffer.write_into(s);
			}
		},
		'>' => {
			let len = s.length();
			if (len < fmt_spec.width)
			{
				buffer.write_into(fmt_spec.fill, fmt_spec.width - len);
			}
			buffer.write_into(s);
		},
		else => unreachable
	}
}

export function format_to(c: char, buffer: &mut format_buffer, fmt_spec: str)
{
	c.format_to(buffer, get_default_format_spec(fmt_spec));
}

export function format_to(c: char, buffer: &mut format_buffer, fmt_spec: format_spec)
{
	let [encoded_char, byte_count] = encode_char_utf8(c);
	let s = __builtin_str_from_ptrs(encoded_char.begin(), encoded_char.begin() + byte_count);
	s.format_to(buffer, fmt_spec);
}

function format_number(number_str: str, buffer: &mut format_buffer, mut fmt_spec: format_spec, put_sign: bool)
{
	if (fmt_spec.align == '\x00')
	{
		fmt_spec.align = '>';
	}
	if (fmt_spec.fill == '\x00')
	{
		fmt_spec.fill = ' ';
	}
	switch (fmt_spec.align)
	{
		'<' => {
			let len = number_str.length() + put_sign as usize;
			if (put_sign)
			{
				buffer.write_into(fmt_spec.sign);
			}
			buffer.write_into(number_str);
			if (len < fmt_spec.width)
			{
				buffer.write_into(fmt_spec.fill, fmt_spec.width - len);
			}
		},
		'^' => {
			let len = number_str.length() + put_sign as usize;
			if (len < fmt_spec.width)
			{
				let diff = fmt_spec.width - len;
				// if the spacing is uneven, prefer right alignment
				if (fmt_spec.zero_pad)
				{
					if (put_sign)
					{
						buffer.write_into(fmt_spec.sign);
					}
					buffer.write_into('0', (diff + 1) / 2);
					buffer.write_into(number_str);
				}
				else
				{
					buffer.write_into(fmt_spec.fill, (diff + 1) / 2);
					if (put_sign)
					{
						buffer.write_into(fmt_spec.sign);
					}
					buffer.write_into(number_str);
				}
				buffer.write_into(fmt_spec.fill, diff / 2);
			}
			else
			{
				if (put_sign)
				{
					buffer.write_into(fmt_spec.sign);
				}
				buffer.write_into(number_str);
			}
		},
		'>' => {
			let len = number_str.length() + put_sign as usize;
			if (len < fmt_spec.width)
			{
				if (fmt_spec.zero_pad)
				{
					if (put_sign)
					{
						buffer.write_into(fmt_spec.sign);
					}
					buffer.write_into('0', fmt_spec.width - len);
					buffer.write_into(number_str);
				}
				else
				{
					buffer.write_into(fmt_spec.fill, fmt_spec.width - len);
					if (put_sign)
					{
						buffer.write_into(fmt_spec.sign);
					}
					buffer.write_into(number_str);
				}
			}
			else
			{
				if (put_sign)
				{
					buffer.write_into(fmt_spec.sign);
				}
				buffer.write_into(number_str);
			}
		},
		else => unreachable
	}
}

export function format_to(n: uint64, buffer: &mut format_buffer, fmt_spec: str)
{
	n.format_to(buffer, get_default_format_spec(fmt_spec));
}

export function format_to(n: uint64, buffer: &mut format_buffer, fmt_spec: format_spec)
{
	let [result_buffer, size] = switch (fmt_spec.fmt_kind) {
		'b', 'B' => {
			get_uint_base_as_string(n, 2)
		},
		'o', 'O' => {
			get_uint_base_as_string(n, 8)
		},
		'x', 'X' => {
			get_uint_hex_as_string(n, fmt_spec.fmt_kind == 'X')
		},
		else => {
			get_uint_decimal_as_string(n)
		}
	};
	let result_str = __builtin_str_from_ptrs(result_buffer.begin(), result_buffer.begin() + size);
	let put_sign = fmt_spec.sign == '+' || fmt_spec.sign == ' ';
	format_number(result_str, buffer, fmt_spec, put_sign);
}

export function format_to(n: int64, buffer: &mut format_buffer, fmt_spec: str)
{
	n.format_to(buffer, get_default_format_spec(fmt_spec));
}

export function format_to(n: int64, buffer: &mut format_buffer, mut fmt_spec: format_spec)
{
	let put_sign = n < 0 || fmt_spec.sign == '+' || fmt_spec.sign == ' ';
	if (n < 0)
	{
		fmt_spec.sign = '-';
	}
	// -n as uint64 works for uint64_min as well
	let n = if (n < 0) { -n as uint64 } else { n as uint64 };
	let [result_buffer, size] = get_uint_decimal_as_string(n);
	let result_str = __builtin_str_from_ptrs(result_buffer.begin(), result_buffer.begin() + size);
	format_number(result_str, buffer, fmt_spec, put_sign);
}

function format_pointer(number_str: str, buffer: &mut format_buffer, mut fmt_spec: format_spec)
{
	if (fmt_spec.align == '\x00')
	{
		fmt_spec.align = '>';
	}
	if (fmt_spec.fill == '\x00')
	{
		fmt_spec.fill = ' ';
	}
	let prefix = if (fmt_spec.fmt_kind == 'P') { "0X" } else { "0x" };
	switch (fmt_spec.align)
	{
		'<' => {
			let len = number_str.length() + 2;
			buffer.write_into(prefix);
			buffer.write_into(number_str);
			if (len < fmt_spec.width)
			{
				buffer.write_into(fmt_spec.fill, fmt_spec.width - len);
			}
		},
		'^' => {
			let len = number_str.length() + 2;
			if (len < fmt_spec.width)
			{
				let diff = fmt_spec.width - len;
				// if the spacing is uneven, prefer right alignment
				if (fmt_spec.zero_pad)
				{
					buffer.write_into(prefix);
					buffer.write_into('0', (diff + 1) / 2);
					buffer.write_into(number_str);
				}
				else
				{
					buffer.write_into(fmt_spec.fill, (diff + 1) / 2);
					buffer.write_into(prefix);
					buffer.write_into(number_str);
				}
				buffer.write_into(fmt_spec.fill, diff / 2);
			}
			else
			{
				buffer.write_into(prefix);
				buffer.write_into(number_str);
			}
		},
		'>' => {
			let len = number_str.length() + 2;
			if (len < fmt_spec.width)
			{
				if (fmt_spec.zero_pad)
				{
					buffer.write_into(prefix);
					buffer.write_into('0', fmt_spec.width - len);
					buffer.write_into(number_str);
				}
				else
				{
					buffer.write_into(fmt_spec.fill, fmt_spec.width - len);
					buffer.write_into(prefix);
					buffer.write_into(number_str);
				}
			}
			else
			{
				buffer.write_into(prefix);
				buffer.write_into(number_str);
			}
		},
		else => unreachable
	}
}

export function format_to(p: ?*void, buffer: &mut format_buffer, fmt_spec: str)
{
	p.format_to(buffer, get_default_format_spec(fmt_spec));
}

export function format_to(p: ?*void, buffer: &mut format_buffer, fmt_spec: format_spec)
{
	let val = __builtin_pointer_to_int(p);
	let [result_buffer, size] = get_uint_hex_as_string(val, fmt_spec.fmt_kind == 'P');
	let result_str = __builtin_str_from_ptrs(result_buffer.begin(), result_buffer.begin() + size);
	format_pointer(result_str, buffer, fmt_spec);
}

export function format_to(b: bool, buffer: &mut format_buffer, fmt_spec: str)
{
	b.format_to(buffer, get_default_format_spec(fmt_spec));
}

export function format_to(b: bool, buffer: &mut format_buffer, fmt_spec: format_spec)
{
	if (b)
	{
		"true".format_to(buffer, fmt_spec);
	}
	else
	{
		"false".format_to(buffer, fmt_spec);
	}
}

function isfinite(x: float32) -> bool
{
	let bits = ryu::float_to_bits(x);
	consteval exponent_mask = 0x7f80'0000u32;
	static_assert(popcount(exponent_mask) == 8);
	return (bits & exponent_mask) != exponent_mask;
}

function isfinite(x: float64) -> bool
{
	let bits = ryu::double_to_bits(x);
	consteval exponent_mask = 0x7ff0'0000'0000'0000u64;
	static_assert(popcount(exponent_mask) == 11);
	return (bits & exponent_mask) != exponent_mask;
}

function isnan(x: float32) -> bool
{
	let bits = ryu::float_to_bits(x);
	consteval exponent_mask = 0x7f80'0000u32;
	consteval mantissa_mask = 0x007f'ffffu32;
	static_assert(popcount(exponent_mask) == 8);
	static_assert(popcount(mantissa_mask) == 23);
	return (bits & exponent_mask) == exponent_mask && (bits & mantissa_mask) != 0;
}

function isnan(x: float64) -> bool
{
	let bits = ryu::double_to_bits(x);
	consteval exponent_mask = 0x7ff0'0000'0000'0000u64;
	consteval mantissa_mask = 0x000f'ffff'ffff'ffffu64;
	static_assert(popcount(exponent_mask) == 11);
	static_assert(popcount(mantissa_mask) == 52);
	return (bits & exponent_mask) == exponent_mask && (bits & mantissa_mask) != 0;
}

static_assert(isfinite(1.0));
static_assert(!isfinite(((1.0 / 0.0))));
static_assert(!isfinite(((0.0 / 0.0))));
static_assert(!isnan(1.0));
static_assert(!isnan(((1.0 / 0.0))));
static_assert(isnan(((0.0 / 0.0))));

export function format_to(x: float32, buffer: &mut format_buffer, fmt_spec: str)
{
	x.format_to(buffer, get_default_format_spec(fmt_spec));
}

export function format_to(x: float32, buffer: &mut format_buffer, mut fmt_spec: format_spec)
{
	switch (fmt_spec.fmt_kind)
	{
		'f', 'F', 'e', 'E', 'g', 'G', '%' => {
			(x as float64).format_to(buffer, fmt_spec);
		},
		else => {
			if (fmt_spec.precision != precision_none)
			{
				fmt_spec.fmt_kind = 'g';
				(x as float64).format_to(buffer, fmt_spec);
			}
			else
			{
				fmt_spec.zero_pad &= isfinite(x);
				mut result_buffer = [15: uint8]();
				let end = ryu::f2s_shortest(x, result_buffer.begin());
				let [result_str, put_sign] = if (result_buffer[0] == '-' as uint8) {
					fmt_spec.sign = '-';
					[ __builtin_str_from_ptrs(result_buffer.begin() + 1, end), true ]
				} else {
					[
						__builtin_str_from_ptrs(result_buffer.begin(), end),
						!isnan(x) && (fmt_spec.sign == '+' || fmt_spec.sign == ' ')
					]
				};
				format_number(result_str, buffer, fmt_spec, put_sign);
			}
		}
	}
}

// generated by scripts/gen_float_limit_table.py
// bounds[precision] returns the number x for which if num < x, precision number of digits
// are needed before the decimal point to represent the number
consteval upper_bounds: [309: float64] = [
	1.0, 10.0, 100.0, 1000.0, 10000.0,
	100000.0, 1000000.0, 10000000.0, 100000000.0, 1000000000.0,
	10000000000.0, 100000000000.0, 1000000000000.0, 10000000000000.0, 100000000000000.0,
	1000000000000000.0, 1e+16, 1e+17, 1e+18, 1e+19,
	1e+20, 1e+21, 1e+22, 1.0000000000000001e+23, 1.0000000000000001e+24,
	1e+25, 1e+26, 1e+27, 1.0000000000000002e+28, 1.0000000000000001e+29,
	1e+30, 1.0000000000000001e+31, 1e+32, 1.0000000000000001e+33, 1.0000000000000001e+34,
	1.0000000000000002e+35, 1e+36, 1.0000000000000001e+37, 1.0000000000000002e+38, 1.0000000000000001e+39,
	1e+40, 1e+41, 1e+42, 1e+43, 1e+44,
	1.0000000000000001e+45, 1.0000000000000001e+46, 1e+47, 1e+48, 1.0000000000000001e+49,
	1e+50, 1.0000000000000002e+51, 1.0000000000000001e+52, 1.0000000000000002e+53, 1e+54,
	1e+55, 1e+56, 1e+57, 1.0000000000000001e+58, 1.0000000000000001e+59,
	1.0000000000000001e+60, 1.0000000000000001e+61, 1e+62, 1e+63, 1e+64,
	1.0000000000000001e+65, 1.0000000000000001e+66, 1.0000000000000001e+67, 1.0000000000000001e+68, 1e+69,
	1e+70, 1e+71, 1.0000000000000001e+72, 1.0000000000000001e+73, 1.0000000000000001e+74,
	1.0000000000000001e+75, 1e+76, 1.0000000000000001e+77, 1e+78, 1.0000000000000001e+79,
	1e+80, 1.0000000000000001e+81, 1.0000000000000001e+82, 1e+83, 1e+84,
	1e+85, 1e+86, 1.0000000000000002e+87, 1.0000000000000001e+88, 1.0000000000000001e+89,
	1.0000000000000001e+90, 1e+91, 1e+92, 1e+93, 1e+94,
	1e+95, 1e+96, 1e+97, 1.0000000000000001e+98, 1.0000000000000001e+99,
	1e+100, 1.0000000000000001e+101, 1.0000000000000001e+102, 1e+103, 1e+104,
	1.0000000000000001e+105, 1e+106, 1.0000000000000001e+107, 1e+108, 1.0000000000000002e+109,
	1e+110, 1.0000000000000001e+111, 1.0000000000000001e+112, 1e+113, 1e+114,
	1e+115, 1e+116, 1e+117, 1.0000000000000001e+118, 1.0000000000000001e+119,
	1.0000000000000001e+120, 1e+121, 1e+122, 1.0000000000000001e+123, 1.0000000000000001e+124,
	1.0000000000000001e+125, 1.0000000000000001e+126, 1.0000000000000001e+127, 1e+128, 1.0000000000000002e+129,
	1e+130, 1.0000000000000001e+131, 1.0000000000000001e+132, 1e+133, 1.0000000000000001e+134,
	1.0000000000000001e+135, 1e+136, 1e+137, 1e+138, 1e+139,
	1e+140, 1e+141, 1e+142, 1e+143, 1e+144,
	1.0000000000000001e+145, 1.0000000000000002e+146, 1.0000000000000002e+147, 1e+148, 1e+149,
	1.0000000000000002e+150, 1e+151, 1e+152, 1.0000000000000002e+153, 1e+154,
	1e+155, 1.0000000000000002e+156, 1.0000000000000001e+157, 1.0000000000000001e+158, 1.0000000000000001e+159,
	1e+160, 1e+161, 1.0000000000000001e+162, 1.0000000000000001e+163, 1e+164,
	1.0000000000000001e+165, 1.0000000000000001e+166, 1e+167, 1.0000000000000001e+168, 1.0000000000000001e+169,
	1e+170, 1.0000000000000002e+171, 1e+172, 1e+173, 1e+174,
	1.0000000000000001e+175, 1e+176, 1e+177, 1e+178, 1.0000000000000001e+179,
	1e+180, 1.0000000000000001e+181, 1e+182, 1.0000000000000001e+183, 1e+184,
	1.0000000000000001e+185, 1.0000000000000001e+186, 1.0000000000000001e+187, 1e+188, 1e+189,
	1e+190, 1e+191, 1e+192, 1e+193, 1.0000000000000001e+194,
	1.0000000000000001e+195, 1.0000000000000002e+196, 1.0000000000000001e+197, 1e+198, 1e+199,
	1.0000000000000001e+200, 1e+201, 1.0000000000000001e+202, 1.0000000000000002e+203, 1.0000000000000001e+204,
	1e+205, 1e+206, 1e+207, 1.0000000000000001e+208, 1e+209,
	1.0000000000000001e+210, 1.0000000000000001e+211, 1.0000000000000001e+212, 1.0000000000000001e+213, 1.0000000000000001e+214,
	1.0000000000000001e+215, 1e+216, 1.0000000000000001e+217, 1e+218, 1.0000000000000001e+219,
	1.0000000000000001e+220, 1e+221, 1e+222, 1e+223, 1.0000000000000002e+224,
	1.0000000000000001e+225, 1.0000000000000001e+226, 1e+227, 1.0000000000000001e+228, 1.0000000000000001e+229,
	1e+230, 1e+231, 1e+232, 1.0000000000000002e+233, 1e+234,
	1e+235, 1e+236, 1.0000000000000001e+237, 1e+238, 1.0000000000000001e+239,
	1e+240, 1e+241, 1e+242, 1e+243, 1e+244,
	1e+245, 1e+246, 1.0000000000000001e+247, 1e+248, 1.0000000000000001e+249,
	1.0000000000000001e+250, 1e+251, 1e+252, 1.0000000000000001e+253, 1.0000000000000001e+254,
	1.0000000000000002e+255, 1e+256, 1e+257, 1e+258, 1.0000000000000001e+259,
	1e+260, 1.0000000000000001e+261, 1e+262, 1e+263, 1e+264,
	1e+265, 1e+266, 1.0000000000000001e+267, 1.0000000000000002e+268, 1e+269,
	1e+270, 1.0000000000000001e+271, 1e+272, 1.0000000000000001e+273, 1.0000000000000001e+274,
	1.0000000000000001e+275, 1e+276, 1e+277, 1.0000000000000001e+278, 1e+279,
	1e+280, 1e+281, 1e+282, 1.0000000000000002e+283, 1e+284,
	1.0000000000000001e+285, 1e+286, 1e+287, 1e+288, 1e+289,
	1e+290, 1.0000000000000001e+291, 1e+292, 1.0000000000000001e+293, 1e+294,
	1.0000000000000001e+295, 1.0000000000000002e+296, 1e+297, 1.0000000000000001e+298, 1e+299,
	1e+300, 1e+301, 1e+302, 1e+303, 1.0000000000000001e+304,
	1.0000000000000001e+305, 1e+306, 1.0000000000000001e+307, 1e+308,
];

consteval lower_bounds: [17: float64] = [
	0.0, // this is unused
	9.499999999999999e-05, 9.949999999999999e-05, 9.994999999999999e-05, 9.9995e-05, 9.99995e-05,
	9.999994999999999e-05, 9.9999995e-05, 9.99999995e-05, 9.999999994999999e-05, 9.999999999499999e-05,
	9.99999999995e-05, 9.999999999995e-05, 9.999999999999499e-05, 9.999999999999949e-05, 9.999999999999994e-05,
	9.999999999999999e-05,
];

consteval trailing_zeros_upper_bounds: [17, 4: float64] = [
	[ 0.0, 0.0, 0.0, 0.0 ], // this is unused
	[ 0.09499999999999999, 0.0095, 0.00095, 9.499999999999999e-05 ],
	[ 0.09949999999999999, 0.009949999999999999, 0.0009949999999999998, 9.949999999999999e-05 ],
	[ 0.09995, 0.009994999999999999, 0.0009995, 9.994999999999999e-05 ],
	[ 0.09999499999999999, 0.0099995, 0.0009999499999999999, 9.9995e-05 ],
	[ 0.09999949999999999, 0.009999949999999999, 0.0009999949999999998, 9.99995e-05 ],
	[ 0.09999994999999999, 0.009999995, 0.0009999994999999999, 9.999994999999999e-05 ],
	[ 0.099999995, 0.009999999499999999, 0.0009999999499999998, 9.9999995e-05 ],
	[ 0.09999999949999999, 0.00999999995, 0.0009999999949999998, 9.99999995e-05 ],
	[ 0.09999999994999999, 0.009999999995, 0.0009999999994999998, 9.999999994999999e-05 ],
	[ 0.09999999999499999, 0.009999999999499999, 0.0009999999999499999, 9.999999999499999e-05 ],
	[ 0.09999999999949999, 0.009999999999949999, 0.000999999999995, 9.99999999995e-05 ],
	[ 0.09999999999994999, 0.009999999999994999, 0.0009999999999995, 9.999999999995e-05 ],
	[ 0.099999999999995, 0.009999999999999499, 0.00099999999999995, 9.999999999999499e-05 ],
	[ 0.09999999999999949, 0.00999999999999995, 0.0009999999999999948, 9.999999999999949e-05 ],
	[ 0.09999999999999994, 0.009999999999999993, 0.0009999999999999994, 9.999999999999994e-05 ],
	[ 0.09999999999999999, 0.009999999999999998, 0.0009999999999999998, 9.999999999999999e-05 ],
];

function abs_f64(x: float64) -> float64
{
	let bits = ryu::double_to_bits(x);
	consteval sign_mask = 0x8000'0000'0000'0000u64;
	static_assert(popcount(sign_mask) == 1);
	return ryu::bits_to_double(bits & ~sign_mask);
}

function format_float64_fixed(x: float64, buffer: &mut format_buffer, mut fmt_spec: format_spec)
{
	// most results should fit in this buffer
	mut static_buffer = [32: uint8]();
	let finite = isfinite(x);
	fmt_spec.zero_pad &= finite;

	let abs_x = abs_f64(x);
	let leading_digit_count = {
		mut i = 1uz;
		while (i < upper_bounds.size() && abs_x >= upper_bounds[i])
		{
			++i;
		}
		i
	};
	let result_len = if (fmt_spec.precision == 0) {
		// sign + leading digits
		1 + leading_digit_count
	} else {
		// sign + leading digits + dot + precision
		1 + leading_digit_count + 1 + fmt_spec.precision
	};
	let result_buffer = if (result_len <= static_buffer.size()) {
		static_buffer.begin()
	} else {
		malloc(uint8, result_len)
	};

	let end = ryu::d2fixed_short(
		x,
		fmt_spec.precision as uint32,
		result_buffer,
		fmt_spec.fmt_kind != 'f' && fmt_spec.fmt_kind != 'F'
	);
	assert(end <= result_buffer + result_len);
	let [result_str, put_sign] = if (*result_buffer == '-' as uint8) {
		fmt_spec.sign = '-';
		[ __builtin_str_from_ptrs(result_buffer + 1, end), true ]
	} else {
		[
			__builtin_str_from_ptrs(result_buffer, end),
			!isnan(x) && (fmt_spec.sign == '+' || fmt_spec.sign == ' ')
		]
	};
	format_number(result_str, buffer, fmt_spec, put_sign);

	if (result_buffer != static_buffer.begin())
	{
		free(result_buffer);
	}
}

function format_float64_exponential(x: float64, buffer: &mut format_buffer, mut fmt_spec: format_spec)
{
	// most results should fit in this buffer
	mut static_buffer = [32: uint8]();
	let finite = isfinite(x);
	fmt_spec.zero_pad &= finite;
	// sign + "X." + precision + e+XXX
	let result_len = if (!finite) {
		// sign + "inf" or "nan"
		4
	} else {
		// sign + leading digit + dot + precision + "e+000"
		1 + 1 + 1 + fmt_spec.precision + 5
	};
	let result_buffer = if (result_len <= static_buffer.size()) {
		static_buffer.begin()
	} else {
		malloc(uint8, result_len)
	};

	let end = ryu::d2exp_short(
		x,
		fmt_spec.precision as uint32,
		result_buffer, fmt_spec.fmt_kind == 'E' || fmt_spec.fmt_kind == 'G',
		fmt_spec.fmt_kind != 'e' && fmt_spec.fmt_kind != 'E'
	);
	assert(end <= result_buffer + result_len);
	let [result_str, put_sign] = if (*result_buffer == '-' as uint8) {
		fmt_spec.sign = '-';
		[ __builtin_str_from_ptrs(result_buffer + 1, end), true ]
	} else {
		[
			__builtin_str_from_ptrs(result_buffer, end),
			!isnan(x) && (fmt_spec.sign == '+' || fmt_spec.sign == ' ')
		]
	};
	format_number(result_str, buffer, fmt_spec, put_sign);

	if (result_buffer != static_buffer.begin())
	{
		free(result_buffer);
	}
}

function format_float64_generic(x: float64, buffer: &mut format_buffer, mut fmt_spec: format_spec)
{
	assert(fmt_spec.precision != precision_none);
	if (fmt_spec.precision == 0)
	{
		fmt_spec.precision = 1;
	}

	let abs_x = abs_f64(x);
	let upper_bound = upper_bounds[fmt_spec.precision];
	let lower_bound = if (fmt_spec.precision >= lower_bounds.size()) {
		lower_bounds[lower_bounds.size() - 1]
	} else {
		lower_bounds[fmt_spec.precision]
	};
	if (abs_x == 0.0)
	{
		// special case for 0.0
		fmt_spec.precision = 0;
		format_float64_fixed(x, buffer, fmt_spec);
	}
	else if (abs_x <= lower_bound || abs_x >= upper_bound || !isfinite(x))
	{
		// the leading digit isn't counted in format_float64_exponential
		fmt_spec.precision -= 1;
		format_float64_exponential(x, buffer, fmt_spec);
	}
	else if (abs_x >= 1.0)
	{
		let leading_digit_count = {
			mut i = 0uz;
			while (i < upper_bounds.size() && abs_x >= upper_bounds[i])
			{
				++i;
			}
			i
		};
		assert(leading_digit_count <= fmt_spec.precision);
		fmt_spec.precision -= leading_digit_count;
		format_float64_fixed(x, buffer, fmt_spec);
	}
	else
	{
		let trailing_zeros_count = {
			let bounds: [: auto] = if (fmt_spec.precision >= trailing_zeros_upper_bounds.size()) {
				trailing_zeros_upper_bounds[trailing_zeros_upper_bounds.size() - 1]
			} else {
				trailing_zeros_upper_bounds[fmt_spec.precision]
			};
			mut i = 0uz;
			while (i < bounds.size() && abs_x <= bounds[i])
			{
				++i;
			}
			i
		};
		fmt_spec.precision += trailing_zeros_count;
		format_float64_fixed(x, buffer, fmt_spec);
	}
}

function format_float64_percentage(x: float64, buffer: &mut format_buffer, mut fmt_spec: format_spec)
{
	// most results should fit in this buffer
	mut static_buffer = [32: uint8]();
	// we need 2 more digits to get the specified precision in percentage form
	fmt_spec.precision += 2;

	let abs_x = abs_f64(x);
	let leading_digit_count = {
		mut i = 1uz;
		while (i < upper_bounds.size() && abs_x >= upper_bounds[i])
		{
			++i;
		}
		i
	};
	// sign + leading digits + dot + precision + '%'
	let result_len = 1 + leading_digit_count + 1 + fmt_spec.precision + 1;
	let result_buffer = if (result_len <= static_buffer.size()) {
		static_buffer.begin()
	} else {
		malloc(uint8, result_len)
	};

	mut end = ryu::d2fixed_short(
		x,
		fmt_spec.precision as uint32,
		result_buffer,
		false
	);

	// the beginning of the number could change, e.g. 0.0012 would be transformed to 0.12 and not 000.12
	let begin = {
		let dot_it = end - fmt_spec.precision - 1;
		assert(*dot_it == '.' as uint8);
		let tenth_it = dot_it + 1;
		let hundredth_it = dot_it + 2;

		*dot_it = *tenth_it;
		*tenth_it = *hundredth_it;
		*hundredth_it = '.' as uint8;

		if (fmt_spec.precision == 2)
		{
			// remove trailing dot
			--end;
		}
		if (leading_digit_count == 1 && *(dot_it - 1) == '0' as uint8) {
			if (*dot_it == '0' as uint8) {
				dot_it + 1
			} else {
				dot_it
			}
		} else {
			if (*result_buffer == '-' as uint8) {
				result_buffer + 1
			} else {
				result_buffer
			}
		}
	};

	*end = '%' as uint8;
	++end;
	assert(end <= result_buffer + result_len);
	let result_str = __builtin_str_from_ptrs(begin, end);
	let put_sign = if (*result_buffer == '-' as uint8) {
		fmt_spec.sign = '-';
		true
	} else {
		!isnan(x) && (fmt_spec.sign == '+' || fmt_spec.sign == ' ')
	};
	format_number(result_str, buffer, fmt_spec, put_sign);

	if (result_buffer != static_buffer.begin())
	{
		free(result_buffer);
	}
}

function format_float64_shortest(x: float64, buffer: &mut format_buffer, mut fmt_spec: format_spec)
{
	fmt_spec.zero_pad &= isfinite(x);
	mut result_buffer = [24: uint8]();
	let end = ryu::d2s_shortest(x, result_buffer.begin());
	let [result_str, put_sign] = if (result_buffer[0] == '-' as uint8) {
		fmt_spec.sign = '-';
		[ __builtin_str_from_ptrs(result_buffer.begin() + 1, end), true ]
	} else {
		[
			__builtin_str_from_ptrs(result_buffer.begin(), end),
			!isnan(x) && (fmt_spec.sign == '+' || fmt_spec.sign == ' ')
		]
	};
	format_number(result_str, buffer, fmt_spec, put_sign);
}

export function format_to(x: float64, buffer: &mut format_buffer, fmt_spec: str)
{
	x.format_to(buffer, get_default_format_spec(fmt_spec));
}

export function format_to(x: float64, buffer: &mut format_buffer, mut fmt_spec: format_spec)
{
	switch (fmt_spec.fmt_kind)
	{
		'f', 'F' => {
			if (fmt_spec.precision == precision_none)
			{
				fmt_spec.precision = 6;
			}
			format_float64_fixed(x, buffer, fmt_spec);
		},
		'e', 'E' => {
			if (fmt_spec.precision == precision_none)
			{
				fmt_spec.precision = 6;
			}
			format_float64_exponential(x, buffer, fmt_spec);
		},
		'g', 'G' => {
			if (fmt_spec.precision == precision_none)
			{
				fmt_spec.precision = 6;
			}
			format_float64_generic(x, buffer, fmt_spec);
		},
		'%' => {
			if (fmt_spec.precision == precision_none)
			{
				fmt_spec.precision = 2;
			}
			format_float64_percentage(x, buffer, fmt_spec);
		},
		else => {
			if (fmt_spec.precision != precision_none)
			{
				format_float64_generic(x, buffer, fmt_spec);
			}
			else
			{
				format_float64_shortest(x, buffer, fmt_spec);
			}
		}
	}
}

export function format_to(arr: [: auto], buffer: &mut format_buffer, fmt_spec: str)
{
	arr.format_to(buffer, get_default_format_spec(fmt_spec));
}

export function format_to(arr: [: auto], buffer: &mut format_buffer, fmt_spec: format_spec)
{
	mut it = arr.begin();
	let end = arr.end();

	if (it == end)
	{
		buffer.write_into("[]");
		return;
	}

	buffer.write_into("[ ");

	it->format_to(buffer, fmt_spec);
	++it;
	for (; it != end; ++it)
	{
		buffer.write_into(", ");
		it->format_to(buffer, fmt_spec);
	}

	buffer.write_into(" ]");
}

function tuple_format_to_impl(buffer: &mut format_buffer, [first: *auto], fmt_spec: format_spec)
{
	first->format_to(buffer, fmt_spec);
}

function tuple_format_to_impl(buffer: &mut format_buffer, [first: *auto, second: *auto, ...rest: *auto], fmt_spec: format_spec)
{
	first->format_to(buffer, fmt_spec);
	buffer.write_into(", ");
	tuple_format_to_impl(buffer, [ second, ...rest ], fmt_spec);
}

export function format_to(: &[], buffer: &mut format_buffer, : str)
{
	buffer.write_into("[]");
}

export function format_to(: &[], buffer: &mut format_buffer, : format_spec)
{
	buffer.write_into("[]");
}

export function format_to(t: &[...auto], buffer: &mut format_buffer, fmt_spec: str)
{
	t.format_to(buffer, get_default_format_spec(fmt_spec));
}

export function format_to(&[...elems], buffer: &mut format_buffer, fmt_spec: format_spec)
{
	buffer.write_into("[ ");
	tuple_format_to_impl(buffer, [ ...&elems ], fmt_spec);
	buffer.write_into(" ]");
}

export function format_to(s: &string, buffer: &mut format_buffer, fmt_spec: str)
{
	s.as_str().format_to(buffer, fmt_spec);
}

export function format_to(s: &string, buffer: &mut format_buffer, fmt_spec: format_spec)
{
	s.as_str().format_to(buffer, fmt_spec);
}

export function format_to(o: &?auto, buffer: &mut format_buffer, fmt_spec: str)
{
	if (o == null)
	{
		"null".format_to(buffer, fmt_spec);
	}
	else
	{
		o.get_value().format_to(buffer, fmt_spec);
	}
}

export function format_to(o: &?auto, buffer: &mut format_buffer, fmt_spec: format_spec)
{
	if (o == null)
	{
		"null".format_to(buffer, fmt_spec);
	}
	else
	{
		o.get_value().format_to(buffer, fmt_spec);
	}
}
