import ::std::string;

consteval warning_kind_comptime_warning = 21u32;
consteval warning_kind_error            = 22u32;

// copied from std::format

@no_runtime_emit
consteval max_uint_string_length = 20uz;

@no_comptime_checking
function get_uint_as_string(n: uint64) -> [[max_uint_string_length: uint8], uint32]
{
	let result: [[max_uint_string_length: uint8], uint32];
	if (n < 10u)
	{
		result[0, max_uint_string_length - 1u] = ('0' + n) as uint32 as uint8;
		result[1] = 1u;
	}
	else
	{
		let it = result[0].end();
		while (n != 0u)
		{
			const digit = n % 10u;
			n /= 10u;
			--it;
			*it = ('0' + digit) as uint32 as uint8;
		}
		result[1] = (result[0].end() - it) as uint32;
	}
	return result;
}

@no_runtime_emit
consteval max_int_string_length = 20uz;

@no_comptime_checking
function get_int_as_string(abs_val: uint64, is_negative: bool) -> [[max_int_string_length: uint8], uint32]
{
	let n = abs_val;
	let result: [[max_int_string_length: uint8], uint32];
	if (n < 10u)
	{
		result[0, max_uint_string_length - 1u] = ('0' + n) as uint32 as uint8;
		result[1] = 1u;
	}
	else
	{
		let it = result[0].end();
		while (n != 0u)
		{
			const digit = n % 10u;
			n /= 10u;
			--it;
			*it = ('0' + digit) as uint32 as uint8;
		}
		result[1] = (result[0].end() - it) as uint32;
	}
	if (is_negative)
	{
		*(result[0].end() - result[1] - 1u) = '-' as uint32 as uint8;
		++result[1];
	}
	return result;
}

/*
@no_comptime_checking
function print_ascii_char(c: char)
{
	const c_int_val = c as uint32 as uint8;
	std::print(__builtin_str_from_ptrs(&c_int_val, &c_int_val + 1));
}

@no_comptime_checking
function print_uint_impl(n: uint64, base: consteval uint64)
{
	if (n < 10u)
	{
		print_ascii_char('0' + n);
	}
	else if (n < base)
	{
		print_ascii_char('a' + n - 10);
	}
	else
	{
		print_uint_impl(n / base, base);
		const mod = n % base;
		const c = if (mod < 10u) { '0' + mod } else { 'a' + mod - 10 };
		print_ascii_char(c);
	}
}

@no_comptime_checking
function print_uint(n: uint64, base: consteval uint64)
{
	if (n == 0u)
	{
		std::print("0");
	}
	else
	{
		print_uint_impl(n, base);
	}
}

@no_comptime_checking
export function print(n: uint64)
{
	print_uint(n, 10u);
}

@no_comptime_checking
export function print(p: *const void)
{
	std::print("0x"), print_uint(__builtin_pointer_to_int(p), 16u);
}

@no_comptime_checking
export function println(n: uint64)
{
	print_uint(n, 10u), std::println("");
}

@no_comptime_checking
export function println(p: *const void)
{
	std::print("0x"), print_uint(__builtin_pointer_to_int(p), 16u), std::println("");
}
*/

struct call_stack_t
{
	.data_begin: *uint64;
	.data_end:   *uint64;
	.alloc_end:  *uint64;

	// @no_comptime_checking
	destructor(&self)
	{
		for (let it = self.data_begin; it != self.data_end; ++it)
		{
			__builtin_call_destructor(*it);
		}
		free(self.data_begin);
		self.data_begin = null;
		self.data_end   = null;
		self.alloc_end  = null;
	}
}

struct src_tokens_t
{
	.begin: uint64;
	.pivot: uint64;
	.end:   uint64;
}

struct error_t
{
	.kind: uint32;
	.src_tokens: src_tokens_t;
	.message: std::string;
	.call_stack: [: uint64];

	constructor()
	{
		return error_t[
			0u,
			src_tokens_t[ 0u, 0u, 0u ],
			std::string(),
			__builtin_slice_from_ptrs(null as *uint64, null as *uint64)
		];
	}

	// @no_comptime_checking
	destructor(&self)
	{
		__builtin_comptime_free(self.call_stack.begin());
	}
}

struct error_array_t
{
	.data_begin: *error_t;
	.data_end:   *error_t;
	.alloc_end:  *error_t;

	// @no_comptime_checking
	destructor(&self)
	{
		for (let it = self.data_begin; it != self.data_end; ++it)
		{
			__builtin_call_destructor(*it);
		}
		free(self.data_begin);
		self.data_begin = null;
		self.data_end   = null;
		self.alloc_end  = null;
	}
}

@no_comptime_checking
function swap(a: &auto, b: &auto)
{
	static_assert(typeof a != &std::string);
	const temp = a;
	a = b;
	b = temp;
}

@no_comptime_checking
function swap(a: &call_stack_t, b: &call_stack_t)
{
	a.data_begin.swap(b.data_begin);
	a.data_end.swap(b.data_end);
	a.alloc_end.swap(b.alloc_end);
}

@no_comptime_checking
function swap(a: &error_t, b: &error_t)
{
	a.kind.swap(b.kind);
	a.src_tokens.swap(b.src_tokens);
	a.message.swap(b.message);
	a.call_stack.swap(b.call_stack);
}

@no_comptime_checking
function swap(a: &error_array_t, b: &error_array_t)
{
	a.data_begin.swap(b.data_begin);
	a.data_end.swap(b.data_end);
	a.alloc_end.swap(b.alloc_end);
}

@no_comptime_checking
operator = (lhs: &error_t, rhs: error_t)
{
	lhs.swap(rhs);
}

@no_comptime_checking
function alloc(T: typename, count: usize) -> *T
{
	const result = __builtin_comptime_malloc_type(T, count);
	return result;
}

@no_comptime_checking
function free(p: *void)
{
	__builtin_comptime_free(p);
}

@no_comptime_checking
function round_to_next_power_of_two(n: usize) -> usize
{
	// https://stackoverflow.com/a/466242/11488457
	n -= 1u;
	n |= n >> 1;
	n |= n >> 2;
	n |= n >> 4;
	n |= n >> 8;
	n |= n >> 16;
	n |= n >> 32;
	n += 1u;
	return n;
}

@no_comptime_checking
function reserve(arr: &auto, new_capacity: usize)
{
	type value_type = typeof *arr.data_begin;
	static_assert(value_type == error_t || value_type == uint64);

	new_capacity = round_to_next_power_of_two(new_capacity);

	if (arr.capacity() < new_capacity)
	{
		const size = arr.size();
		const new_array = alloc(value_type, new_capacity);
		for (let i = 0uz; i < size; ++i)
		{
			(*(new_array + i)).swap(*(arr.data_begin + i));
			__builtin_call_destructor(*(arr.data_begin + i));
		}
		free(arr.data_begin);
		arr.data_begin = new_array;
		arr.data_end   = new_array + size;
		arr.alloc_end  = new_array + new_capacity;
	}
}

@no_comptime_checking
function push_back(arr: &error_array_t, val: error_t)
{
	arr.reserve(arr.size() + 1u);
	let &pushed_val = *(arr.data_end);
	__builtin_inplace_construct(&pushed_val, error_t());
	val.swap(pushed_val);
	arr.data_end += 1;
}

@no_comptime_checking
function push_back(arr: &call_stack_t, val: uint64)
{
	arr.reserve(arr.size() + 1u);
	*arr.data_end = val;
	++arr.data_end;
}

@no_comptime_checking
function pop_back(arr: &call_stack_t)
{
	if (arr.data_begin == arr.data_end)
	{
		return;
	}
	--arr.data_end;
}

@no_comptime_checking
function size(arr: &const call_stack_t) -> usize
{
	return (arr.data_end - arr.data_begin) as usize;
}

@no_comptime_checking
function size(arr: &const error_array_t) -> usize
{
	return (arr.data_end - arr.data_begin) as usize;
}

@no_comptime_checking
function capacity(arr: &const call_stack_t) -> usize
{
	return (arr.alloc_end - arr.data_begin) as usize;
}

@no_comptime_checking
function capacity(arr: &const error_array_t) -> usize
{
	return (arr.alloc_end - arr.data_begin) as usize;
}

@no_comptime_checking
function empty(arr: &const call_stack_t) -> bool
{
	return arr.data_begin == arr.data_end;
}

@no_comptime_checking
function empty(arr: &const error_array_t) -> bool
{
	return arr.data_begin == arr.data_end;
}

@no_comptime_checking
function clear(arr: &call_stack_t)
{
	for (let it = arr.data_end; it != arr.data_begin;)
	{
		--it;
		__builtin_call_destructor(*it);
	}
	arr.data_end = arr.data_begin;
}

@no_comptime_checking
function clear(arr: &error_array_t)
{
	for (let it = arr.data_end; it != arr.data_begin;)
	{
		--it;
		__builtin_call_destructor(*it);
	}
	arr.data_end = arr.data_begin;
}

@no_comptime_checking
operator [] (arr: &auto, i: uint64) -> &typeof *arr.data_begin
{
	return *(arr.data_begin + i);
}

@no_comptime_checking
operator [] (arr: &const auto, i: uint64) -> &const typeof *arr.data_begin
{
	return *(arr.data_begin + i);
}

@no_comptime_checking
operator [] (arr: &auto, i: int64) -> &typeof *arr.data_begin
{
	return *(arr.data_begin + i);
}

@no_comptime_checking
operator [] (arr: &const auto, i: int64) -> &const typeof *arr.data_begin
{
	return *(arr.data_begin + i);
}

@no_comptime_checking
function begin(arr: &error_array_t) -> *typeof *arr.data_begin
{
	return arr.data_begin;
}

@no_comptime_checking
function begin(arr: &const error_array_t) -> *const typeof *arr.data_begin
{
	return arr.data_begin;
}

@no_comptime_checking
function end(arr: &error_array_t) -> *typeof *arr.data_end
{
	return arr.data_end;
}

@no_comptime_checking
function end(arr: &const error_array_t) -> *const typeof *arr.data_end
{
	return arr.data_end;
}

@no_runtime_emit
@comptime_error_checking("errors_var")
let errors = error_array_t[ null, null, null ];

@no_runtime_emit
@comptime_error_checking("call_stack_var")
let call_stack = call_stack_t[ null, null, null ];


@comptime_error_checking("cleanup")
function cleanup()
{
	__builtin_call_destructor(errors);
	__builtin_call_destructor(call_stack);
}

@comptime_error_checking("get_error_count")
function get_error_count() -> uint64
{
	return errors.size();
}

@comptime_error_checking("get_error_kind_by_index")
function get_error_kind_by_index(i: uint64) -> uint32
{
	return if (i < errors.size()) { errors[i].kind } else { 0u32 };
}

@comptime_error_checking("get_error_begin_by_index")
function get_error_begin_by_index(i: uint64) -> uint64
{
	return if (i < errors.size()) { errors[i].src_tokens.begin } else { 0u64 };
}

@comptime_error_checking("get_error_pivot_by_index")
function get_error_pivot_by_index(i: uint64) -> uint64
{
	return if (i < errors.size()) { errors[i].src_tokens.pivot } else { 0u64 };
}

@comptime_error_checking("get_error_end_by_index")
function get_error_end_by_index(i: uint64) -> uint64
{
	return if (i < errors.size()) { errors[i].src_tokens.end } else { 0u64 };
}

@comptime_error_checking("get_error_message_size_by_index")
function get_error_message_size_by_index(i: uint64) -> uint64
{
	return if (i < errors.size()) { errors[i].message.size() } else { 0u64 };
}

@comptime_error_checking("get_error_message_by_index")
function get_error_message_char_by_index(i: uint64, buffer: *uint8)
{
	if (i < errors.size())
	{
		__builtin_memcpy(buffer, errors[i].message.data(), errors[i].message.size());
	}
}

@comptime_error_checking("get_error_call_stack_size_by_index")
function get_error_call_stack_size_by_index(i: uint64) -> uint64
{
	return if (i < errors.size()) { errors[i].call_stack.size() } else { 0u64 };
}

@comptime_error_checking("get_error_call_stack_element_by_index")
function get_error_call_stack_element_by_index(i: uint64, j: uint64) -> uint64
{
	return if (i < errors.size() && j < errors[i].call_stack.size()) { errors[i].call_stack[j] } else { 0u64 };
}

@comptime_error_checking("has_errors")
function has_errors() -> bool
{
	for (let &const error in errors)
	{
		if (error.kind == warning_kind_error)
		{
			return true;
		}
	}
	return false;
}

@no_comptime_checking
function str_from_c_str(c_str: *const uint8) -> str
{
	let it = c_str;
	while (*it != 0u)
	{
		++it;
	}
	return __builtin_str_from_ptrs(c_str, it);
}

@no_comptime_checking
function get_call_stack_array_copy() -> [: uint64]
{
	const call_stack_size = call_stack.size();
	if (call_stack_size == 0u)
	{
		const result = __builtin_slice_from_ptrs(null as *uint64, null as *uint64);
		return result;
	}
	else
	{
		const ptr = alloc(uint64, call_stack_size);
		const result = __builtin_slice_from_ptrs(ptr, ptr + call_stack_size);
		for (let i = 0u; i < call_stack_size; ++i)
		{
			result[i] = call_stack[i];
		}
		return result;
	}
}

@comptime_error_checking("add_error")
function add_error(kind: uint32, begin: uint64, pivot: uint64, end: uint64, message: *const uint8)
{
	const call_stack_array = get_call_stack_array_copy();
	const message_str = str_from_c_str(message);
	errors.push_back(error_t[ kind, src_tokens_t[ begin, pivot, end ], std::string(message_str), call_stack_array ]);
}

@comptime_error_checking("push_call")
function push_call(call: uint64)
{
	call_stack.push_back(call);
}

@comptime_error_checking("pop_call")
function pop_call()
{
	call_stack.pop_back();
}

@comptime_error_checking("clear_errors")
function clear_errors()
{
	errors.clear();
}


@no_comptime_checking
function make_index_error_message(index: usize, size: usize) -> std::string
{
	let result = std::string("index ");
	{
		const [buffer, str_size] = get_uint_as_string(index);
		result ..= __builtin_str_from_ptrs(buffer.end() - str_size, buffer.end());
	}
	result ..= " is out-of-bounds for an array of size ";
	{
		const [buffer, str_size] = get_uint_as_string(size);
		result ..= __builtin_str_from_ptrs(buffer.end() - str_size, buffer.end());
	}
	return result;
}

@no_comptime_checking
function make_index_error_message(index: isize, size: usize) -> std::string
{
	if (index < 0)
	{
		let result = std::string("negative index ");
		{
			const [buffer, str_size] = get_int_as_string(if (index < 0) { (-index) as usize } else { index as usize }, index < 0);
			result ..= __builtin_str_from_ptrs(buffer.end() - str_size, buffer.end());
		}
		result ..= " in subscript for an array of size ";
		{
			const [buffer, str_size] = get_uint_as_string(size);
			result ..= __builtin_str_from_ptrs(buffer.end() - str_size, buffer.end());
		}
		return result;
	}
	else
	{
		return make_index_error_message(index as usize, size);
	}
}

@comptime_error_checking("index_check_unsigned")
function index_check_unsigned(
	index: usize,
	size: usize,
	kind: uint32,
	begin: uint64,
	pivot: uint64,
	end: uint64
) -> bool
{
	if (index >= size)
	{
		const call_stack_array = get_call_stack_array_copy();
		errors.push_back(error_t[ kind, src_tokens_t[begin, pivot, end], make_index_error_message(index, size), call_stack_array ]);
		return false;
	}
	else
	{
		return true;
	}
}

@comptime_error_checking("index_check_signed")
function index_check_signed(
	index: isize,
	size: usize,
	kind: uint32,
	begin: uint64,
	pivot: uint64,
	end: uint64
) -> bool
{
	if (index < 0 || index as usize >= size)
	{
		const call_stack_array = get_call_stack_array_copy();
		errors.push_back(error_t[ kind, src_tokens_t[begin, pivot, end], make_index_error_message(index, size), call_stack_array ]);
		return false;
	}
	else
	{
		return true;
	}
}

// builtins for error emission in comptime code

@no_comptime_checking
@__builtin("comptime_compile_error_src_tokens")
function __builtin_comptime_compile_error_src_tokens(message: str, begin: uint64, pivot: uint64, end: uint64)
{
	const call_stack_array = get_call_stack_array_copy();
	errors.push_back(error_t[ warning_kind_error, src_tokens_t[ begin, pivot, end ], std::string(message), call_stack_array ]);
}

@no_comptime_checking
@__builtin("comptime_compile_warning_src_tokens")
function __builtin_comptime_compile_warning_src_tokens(message: str, begin: uint64, pivot: uint64, end: uint64)
{
	const call_stack_array = get_call_stack_array_copy();
	errors.push_back(error_t[ warning_kind_comptime_warning, src_tokens_t[ begin, pivot, end ], std::string(message), call_stack_array ]);
}
