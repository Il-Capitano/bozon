import ::std::unicode;

consteval warning_kind_int_overflow      = 0u32;
consteval warning_kind_float_nan_math    = 4u32;
consteval warning_kind_math_domain_error = 17u32;
consteval warning_kind_comptime_warning  = 23u32;
consteval warning_kind_error             = 24u32;

function alloc = __builtin_comptime_malloc_type;
function free  = __builtin_comptime_free;
function memcpy = __builtin_memcpy;

/*
function alloc(T: typename, count: usize) -> *T
{
	return __builtin_comptime_malloc_type(T, count);
}

function free(p: *void)
{
	__builtin_comptime_free(p);
}

function memcpy(dest: *void, src: *const void, n: usize)
{
	__builtin_memcpy(dest, src, n);
}
*/

function swap(a: &auto, b: &auto)
{
	const temp = a;
	a = b;
	b = temp;
}

function release(value: &auto) -> __builtin_remove_reference(typeof value)
{
	return value;
}

function round_to_next_power_of_two(n: usize) -> usize
{
	// https://stackoverflow.com/a/466242/11488457
	n -= 1u;
	n |= n >> 1;
	n |= n >> 2;
	n |= n >> 4;
	n |= n >> 8;
	n |= n >> 16;
	n |= n >> 32;
	n += 1u;
	return n;
}

function rounded_alloc(T: typename, n: usize) -> [*T, usize]
{
	if (n == 0u)
	{
		return [ null, 0u ];
	}
	else
	{
		const rounded_n = round_to_next_power_of_two(n);
		return [ alloc(T, rounded_n), rounded_n ];
	}
}

function move_range(begin: *auto, end: *auto, other_begin: *auto)
{
	for (let [it, other_it] = [ begin, other_begin ]; it != end; ++it, ++other_it)
	{
		__builtin_inplace_construct(it, other_it->release());
	}
}

function copy_range(begin: *auto, end: *auto, other_begin: *const auto)
{
	for (let [it, other_it] = [ begin, other_begin ]; it != end; ++it, ++other_it)
	{
		__builtin_inplace_construct(it, *other_it);
	}
}

struct vector<T: typename>
{
	type value_type = T;
	type _self_t = vector<T>;

	._data_begin: *T;
	._data_end:   *T;
	._alloc_end:  *T;

	destructor(&self)
	{
		self.clear();
		free(self._data_begin);
	}

	constructor()
	{
		return _self_t[ null, null, null ];
	}

	constructor(other: &const _self_t)
	{
		return _self_t(other.as_slice());
	}

	constructor(slice: [: const value_type])
	{
		const size = slice.size();
		if (size == 0u)
		{
			return _self_t();
		}

		const [data_begin, alloc_size] = rounded_alloc(T, size);
		const data_end = data_begin + size;
		const alloc_end = data_begin + alloc_size;
		copy_range(data_begin, data_end, slice.begin());
		return _self_t[ data_begin, data_end, alloc_end ];
	}

	operator = (self: &_self_t, other: &const _self_t) -> &_self_t
	{
		if (&self == &other)
		{
			return self;
		}
		self = other.as_slice();
		return self;
	}

	operator = (self: &_self_t, other: _self_t) -> &_self_t
	{
		self.swap(other);
		return self;
	}

	operator = (self: &_self_t, other: [: const value_type]) -> &_self_t
	{
		const size = other.size();
		self.clear();
		self.reserve(size);
		self._data_end = self._data_begin + size;
		copy_range(self._data_begin, self._data_end, other.begin());
		return self;
	}

	function size(self: #const _self_t) -> usize
	{
		return (self._data_end - self._data_begin) as usize;
	}

	function capacity(self: #const _self_t) -> usize
	{
		return (self._alloc_end - self._data_begin) as usize;
	}

	function as_slice(self: &_self_t) -> [: value_type]
	{
		return __builtin_slice_from_ptrs(self._data_begin, self._data_end);
	}

	function as_slice(self: &const _self_t) -> [: const value_type]
	{
		return __builtin_slice_from_const_ptrs(self._data_begin, self._data_end);
	}

	operator [] (self: &_self_t, i: int64) -> &value_type
	{
		return *(self._data_begin + i);
	}

	operator [] (self: &_self_t, i: uint64) -> &value_type
	{
		return *(self._data_begin + i);
	}

	operator [] (self: &const _self_t, i: int64) -> &const value_type
	{
		return *(self._data_begin + i);
	}

	operator [] (self: &const _self_t, i: uint64) -> &const value_type
	{
		return *(self._data_begin + i);
	}

	function front(self: &_self_t) -> &value_type
	{
		return self[0];
	}

	function front(self: &const _self_t) -> &const value_type
	{
		return self[0];
	}

	function back(self: &_self_t) -> &value_type
	{
		return self[self.size() - 1u];
	}

	function back(self: &const _self_t) -> &const value_type
	{
		return self[self.size() - 1u];
	}


	function reserve(self: &_self_t, new_capacity: usize)
	{
		if (new_capacity > self.capacity())
		{
			const [new_data_begin, new_alloc_size] = rounded_alloc(T, new_capacity);
			const new_data_end = new_data_begin + self.size();
			const new_alloc_end = new_data_begin + new_alloc_size;
			move_range(new_data_begin, new_data_end, self._data_begin);
			self.clear();
			free(self._data_begin);
			self._data_begin = new_data_begin;
			self._data_end   = new_data_end;
			self._alloc_end  = new_alloc_end;
		}
	}

	function release(self: &_self_t) -> _self_t
	{
		const data_begin = self._data_begin;
		const data_end   = self._data_end;
		const alloc_end  = self._alloc_end;
		self._data_begin = null;
		self._data_end   = null;
		self._alloc_end  = null;
		return _self_t[ data_begin, data_end, alloc_end ];
	}

	function clear(self: &_self_t)
	{
		for (let it = self._data_end; it != self._data_begin;)
		{
			--it;
			__builtin_call_destructor(*it);
		}
		self._data_end = self._data_begin;
	}

	function push_back(self: &_self_t, value: ##value_type)
	{
		self.reserve(self.size() + 1u);
		__builtin_inplace_construct(self._data_end, value_type(value));
		memcpy(null, null, 0u);
		self._data_end += 1;
	}

	function pop_back(self: &_self_t)
	{
		if (self._data_end != self._data_begin)
		{
			self._data_end -= 1;
			__builtin_call_destructor(*self._data_end);
		}
	}

	function emplace_back(self: &_self_t, ...##args)
	{
		self.reserve(self.size() + 1u);
		__builtin_inplace_construct(self._data_end, value_type(...args));
		self._data_end += 1;
	}

	function append(self: &_self_t, slice: [: const value_type])
	{
		const slice_size = slice.size();
		self.reserve(self.size() + slice_size);
		copy_range(self._data_end, self._data_end + slice_size, slice.begin());
		self._data_end += slice_size;
	}

	function begin(vec: &_self_t) -> *value_type
	{
		return vec._data_begin;
	}

	function end(vec: &_self_t) -> *value_type
	{
		return vec._data_end;
	}

	function begin(vec: &const _self_t) -> *const value_type
	{
		return vec._data_begin;
	}

	function end(vec: &const _self_t) -> *const value_type
	{
		return vec._data_end;
	}
}

function swap(a: &vector, b: &vector)
{
	swap(a._data_begin, b._data_begin);
	swap(a._data_end,   b._data_end);
	swap(a._alloc_end,  b._alloc_end);
}

struct string
{
	._buffer: vector<uint8>;

	constructor()
	{
		return string[ vector<uint8>() ];
	}

	constructor(s: str)
	{
		const slice = __builtin_slice_from_const_ptrs(s.begin_ptr(), s.end_ptr());
		return string[ vector<uint8>(slice) ];
	}

	operator = (self: &string, rhs: str) -> &string
	{
		const slice = __builtin_slice_from_const_ptrs(rhs.begin_ptr(), rhs.end_ptr());
		self._buffer = slice;
		return self;
	}

	function as_str(self: &const string) -> str
	{
		return __builtin_str_from_ptrs(self._buffer.begin(), self._buffer.end());
	}

	function as_str(self: move string) -> str
	{
		return __builtin_str_from_ptrs(self._buffer.begin(), self._buffer.end());
	}

	function size(self: &const string) -> usize
	{
		return self._buffer.size();
	}

	function capacity(self: &const string) -> usize
	{
		return self._buffer.capacity();
	}

	function release(self: &string) -> string
	{
		return string[ self._buffer.release() ];
	}

	function reserve(self: &string, new_capacity: usize)
	{
		self._buffer.reserve(new_capacity);
	}

	function begin_ptr(self: &const string) -> *const uint8
	{
		return self._buffer.begin();
	}

	function end_ptr(self: &const string) -> *const uint8
	{
		return self._buffer.end();
	}

	operator ..= (lhs: &string, rhs: #const string) -> &string
	{
		lhs._buffer.append(rhs._buffer.as_slice());
		return lhs;
	}

	operator ..= (lhs: &string, rhs: str) -> &string
	{
		const slice = __builtin_slice_from_const_ptrs(rhs.begin_ptr(), rhs.end_ptr());
		lhs._buffer.append(slice);
		return lhs;
	}

	operator ..= (lhs: &string, rhs: char) -> &string
	{
		const [rhs_buffer, rhs_size] = std::encode_char_utf8(rhs);
		if (rhs_size == 1u)
		{
			lhs._buffer.push_back(rhs_buffer[0]);
		}
		else
		{
			lhs._buffer.append(__builtin_slice_from_const_ptrs(rhs_buffer.begin(), rhs_buffer.begin() + rhs_size));
		}
		return lhs;
	}
}

function swap(a: &string, b: &string)
{
	a._buffer.swap(b._buffer);
}

// copied from std::format

@__no_runtime_emit
consteval max_uint_string_length = 20uz;

function get_uint_as_string(n: uint64) -> [[max_uint_string_length: uint8], uint32]
{
	let result: [[max_uint_string_length: uint8], uint32];
	if (n < 10u)
	{
		result[0, max_uint_string_length - 1u] = ('0' + n) as uint8;
		result[1] = 1u;
	}
	else
	{
		let it = result[0].end();
		while (n != 0u)
		{
			const digit = n % 10u;
			n /= 10u;
			--it;
			*it = ('0' + digit) as uint8;
		}
		result[1] = (result[0].end() - it) as uint32;
	}
	return result;
}

@__no_runtime_emit
consteval max_int_string_length = 20uz;

function get_int_as_string(abs_val: uint64, is_negative: bool) -> [[max_int_string_length: uint8], uint32]
{
	let n = abs_val;
	let result: [[max_int_string_length: uint8], uint32];
	if (n < 10u)
	{
		result[0, max_int_string_length - 1u] = ('0' + n) as uint8;
		result[1] = 1u;
	}
	else
	{
		let it = result[0].end();
		while (n != 0u)
		{
			const digit = n % 10u;
			n /= 10u;
			--it;
			*it = ('0' + digit) as uint8;
		}
		result[1] = (result[0].end() - it) as uint32;
	}
	if (is_negative)
	{
		*(result[0].end() - result[1] - 1u) = '-' as uint8;
		++result[1];
	}
	return result;
}

function concat_helper(buffer: &string, s: str)
{
	buffer ..= s;
}

function concat_helper(buffer: &string, s: &const string)
{
	buffer ..= s.as_str();
}

function concat_helper(buffer: &string, n: int64)
{
	const [num_buffer, size] = get_int_as_string(if (n < 0) { (-n) as uint64 } else { n as uint64 }, n < 0);
	buffer ..= __builtin_str_from_ptrs(num_buffer.end() - size, num_buffer.end());
}

function concat_helper(buffer: &string, n: uint64)
{
	const [num_buffer, size] = get_uint_as_string(n);
	buffer ..= __builtin_str_from_ptrs(num_buffer.end() - size, num_buffer.end());
}

@__builtin @symbol_name("__bozon_builtin_format_float32") consteval function __builtin_comptime_format_float32(x: float32, buffer: *uint8) -> *uint8;
@__builtin @symbol_name("__bozon_builtin_format_float64") consteval function __builtin_comptime_format_float64(x: float64, buffer: *uint8) -> *uint8;

function concat_helper(buffer: &string, x: float32)
{
	let result_buffer: [15: uint8];
	const end = __builtin_comptime_format_float32(x, result_buffer.begin());
	buffer ..= __builtin_str_from_ptrs(result_buffer.begin(), end);
}

function concat_helper(buffer: &string, x: float64)
{
	let result_buffer: [24: uint8];
	const end = __builtin_comptime_format_float64(x, result_buffer.begin());
	buffer ..= __builtin_str_from_ptrs(result_buffer.begin(), end);
}

function concat(...##args) -> string
{
	let buffer = string();
	[ ...(concat_helper(buffer, args), 0) ];
	return buffer.release();
}

/*
function print = __builtin_print_stdout;
function println = __builtin_println_stdout;

function print_ascii_char(c: char)
{
	const c_int_val = c as uint8;
	print(__builtin_str_from_ptrs(&c_int_val, &c_int_val + 1));
}

function print_uint_impl(n: uint64, base: consteval uint64)
{
	if (n < 10u)
	{
		print_ascii_char('0' + n);
	}
	else if (n < base)
	{
		print_ascii_char('a' + n - 10);
	}
	else
	{
		print_uint_impl(n / base, base);
		const mod = n % base;
		const c = if (mod < 10u) { '0' + mod } else { 'a' + mod - 10 };
		print_ascii_char(c);
	}
}

function print_uint(n: uint64, base: consteval uint64)
{
	if (n == 0u)
	{
		print("0");
	}
	else
	{
		print_uint_impl(n, base);
	}
}

export function print(n: uint64)
{
	print_uint(n, 10u);
}

export function print(p: *const void)
{
	print("0x"), print_uint(__builtin_pointer_to_int(p), 16u);
}

export function println(n: uint64)
{
	print_uint(n, 10u), println("");
}

export function println(p: *const void)
{
	print("0x"), print_uint(__builtin_pointer_to_int(p), 16u), println("");
}

// */


struct src_tokens_t
{
	.begin: uint64;
	.pivot: uint64;
	.end:   uint64;
}

struct error_t
{
	.kind: uint32;
	.src_tokens: src_tokens_t;
	.message: string;
	.call_stack: vector<uint64>;
}

function swap(a: &error_t, b: &error_t)
{
	a.kind.swap(b.kind);
	a.src_tokens.swap(b.src_tokens);
	a.message.swap(b.message);
	a.call_stack.swap(b.call_stack);
}

@__no_runtime_emit
@__comptime_error_checking("errors_var")
let errors = vector<error_t>[ null, null, null ];

@__no_runtime_emit
@__comptime_error_checking("call_stack_var")
let call_stack = vector<uint64>[ null, null, null ];


@__comptime_error_checking("cleanup")
function cleanup()
{
	__builtin_call_destructor(global_strings);
	__builtin_call_destructor(malloc_infos);
	__builtin_call_destructor(errors);
	__builtin_call_destructor(call_stack);
}

@__comptime_error_checking("get_error_count")
function get_error_count() -> uint64
{
	return errors.size();
}

@__comptime_error_checking("get_error_kind_by_index")
function get_error_kind_by_index(i: uint64) -> uint32
{
	return if (i < errors.size()) { errors[i].kind } else { 0u32 };
}

@__comptime_error_checking("get_error_begin_by_index")
function get_error_begin_by_index(i: uint64) -> uint64
{
	return if (i < errors.size()) { errors[i].src_tokens.begin } else { 0u64 };
}

@__comptime_error_checking("get_error_pivot_by_index")
function get_error_pivot_by_index(i: uint64) -> uint64
{
	return if (i < errors.size()) { errors[i].src_tokens.pivot } else { 0u64 };
}

@__comptime_error_checking("get_error_end_by_index")
function get_error_end_by_index(i: uint64) -> uint64
{
	return if (i < errors.size()) { errors[i].src_tokens.end } else { 0u64 };
}

@__comptime_error_checking("get_error_message_size_by_index")
function get_error_message_size_by_index(i: uint64) -> uint64
{
	return if (i < errors.size()) { errors[i].message.size() } else { 0u64 };
}

@__comptime_error_checking("get_error_message_by_index")
function get_error_message_char_by_index(i: uint64, buffer: *uint8)
{
	if (i < errors.size())
	{
		memcpy(buffer, errors[i].message.begin_ptr(), errors[i].message.size());
	}
}

@__comptime_error_checking("get_error_call_stack_size_by_index")
function get_error_call_stack_size_by_index(i: uint64) -> uint64
{
	return if (i < errors.size()) { errors[i].call_stack.size() } else { 0u64 };
}

@__comptime_error_checking("get_error_call_stack_element_by_index")
function get_error_call_stack_element_by_index(i: uint64, j: uint64) -> uint64
{
	return if (i < errors.size() && j < errors[i].call_stack.size()) { errors[i].call_stack[j] } else { 0u64 };
}

@__comptime_error_checking("has_errors")
function has_errors() -> bool
{
	for (let &const error in errors.as_slice())
	{
		if (error.kind == warning_kind_error)
		{
			return true;
		}
	}
	return false;
}

function str_from_c_str(c_str: *const uint8) -> str
{
	let it = c_str;
	while (*it != 0u)
	{
		++it;
	}
	return __builtin_str_from_ptrs(c_str, it);
}

@__comptime_error_checking("add_error")
function add_error(kind: uint32, begin: uint64, pivot: uint64, end: uint64, message: *const uint8)
{
	const message_str = str_from_c_str(message);
	errors.push_back(error_t[ kind, src_tokens_t[ begin, pivot, end ], string(message_str), call_stack ]);
}

@__comptime_error_checking("push_call")
function push_call(call: uint64)
{
	call_stack.push_back(call);
}

@__comptime_error_checking("pop_call")
function pop_call()
{
	call_stack.pop_back();
}

@__comptime_error_checking("clear_errors")
function clear_errors()
{
	errors.clear();
}

struct malloc_info_t
{
	.ptr: *uint8;
	.size: usize;
	.malloc_src_tokens: src_tokens_t;
	.malloc_call_stack: vector<uint64>;
	.is_freed: bool;
	.free_src_tokens: src_tokens_t;
	.free_call_stack: vector<uint64>;

	constructor()
	{
		return malloc_info_t[
			null, 0uz, src_tokens_t(), vector<uint64>(),
			false, src_tokens_t(), vector<uint64>(),
		];
	}

	constructor(ptr: *uint8, size: usize, malloc_src_tokens: src_tokens_t)
	{
		return malloc_info_t[
			ptr, size, malloc_src_tokens, call_stack,
			false, src_tokens_t[ 0u, 0u, 0u ], vector<uint64>(),
		];
	}
}

function swap(a: &malloc_info_t, b: &malloc_info_t)
{
	a.ptr.swap(b.ptr);
	a.size.swap(b.size);
	a.malloc_src_tokens.swap(b.malloc_src_tokens);
	a.malloc_call_stack.swap(b.malloc_call_stack);
	a.is_freed.swap(b.is_freed);
	a.free_src_tokens.swap(b.free_src_tokens);
	a.free_call_stack.swap(b.free_call_stack);
}

@__no_runtime_emit
@__comptime_error_checking("malloc_infos_var")
let malloc_infos = vector<malloc_info_t>[ null, null, null ];

@__comptime_error_checking("register_malloc")
function register_malloc(ptr: *uint8, size: usize, begin: uint64, pivot: uint64, end: uint64)
{
	for (let &malloc_info in malloc_infos.as_slice())
	{
		if (malloc_info.is_freed && malloc_info.ptr == ptr)
		{
			malloc_info.size = size;
			malloc_info.malloc_src_tokens = src_tokens_t[ begin, pivot, end ];
			malloc_info.malloc_call_stack = call_stack;
			malloc_info.is_freed = false;
			malloc_info.free_src_tokens = src_tokens_t();
			malloc_info.free_call_stack = vector<uint64>();
			return;
		}
	}

	malloc_infos.push_back(malloc_info_t(ptr, size, src_tokens_t[ begin, pivot, end ]));
}

@__comptime_error_checking("register_free")
function register_free(ptr: *uint8, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (ptr == null)
	{
		return true;
	}

	for (let &malloc_info in malloc_infos.as_slice())
	{
		if (malloc_info.ptr == ptr)
		{
			if (malloc_info.is_freed)
			{
				emit_diagnostic(warning_kind_error, "double free detected", begin, pivot, end);
				return false;
			}
			else
			{
				malloc_info.is_freed = true;
				malloc_info.free_src_tokens = src_tokens_t[ begin, pivot, end ];
				malloc_info.free_call_stack = call_stack;
				return true;
			}
		}
	}
	emit_diagnostic(warning_kind_error, "freeing an unknown pointer", begin, pivot, end);
	return false;
}

@__comptime_error_checking("check_leaks")
function check_leaks() -> bool
{
	const has_previous_errors = has_errors();
	let good = true;
	for (let &malloc_info in malloc_infos.as_slice())
	{
		if (!malloc_info.is_freed)
		{
			let &const call_stack = malloc_info.malloc_call_stack;
			if (!has_previous_errors)
			{
				emit_diagnostic(
					warning_kind_error,
					"allocated memory was never freed",
					call_stack,
					malloc_info.malloc_src_tokens.begin,
					malloc_info.malloc_src_tokens.pivot,
					malloc_info.malloc_src_tokens.end,
				);
			}
			good = false;
			free(malloc_info.ptr);
		}
	}
	malloc_infos.clear();
	return good;
}


function make_index_error_message(index: usize, size: usize) -> string
{
	return concat("index ", index, " is out-of-bounds for an array of size ", size);
}

function make_index_error_message(index: isize, size: usize) -> string
{
	if (index < 0)
	{
		return concat("negative index ", index, " in subscript for an array of size ", size);
	}
	else
	{
		return make_index_error_message(index as usize, size);
	}
}

@__comptime_error_checking("index_check_unsigned")
function index_check_unsigned(
	index: usize,
	size: usize,
	kind: uint32,
	begin: uint64,
	pivot: uint64,
	end: uint64
) -> bool
{
	if (index >= size)
	{
		errors.push_back(error_t[ kind, src_tokens_t[ begin, pivot, end ], make_index_error_message(index, size), call_stack ]);
		return false;
	}
	else
	{
		return true;
	}
}

@__comptime_error_checking("index_check_signed")
function index_check_signed(
	index: isize,
	size: usize,
	kind: uint32,
	begin: uint64,
	pivot: uint64,
	end: uint64
) -> bool
{
	if (index < 0 || index as usize >= size)
	{
		errors.push_back(error_t[ kind, src_tokens_t[ begin, pivot, end ], make_index_error_message(index, size), call_stack ]);
		return false;
	}
	else
	{
		return true;
	}
}

function make_malloc_error_message(size: usize) -> string
{
	return concat("failed to allocate ", size, " bytes in compile-time malloc");
}

@__comptime_error_checking("comptime_malloc_check")
function comptime_malloc_check(
	ptr: *void,
	size: usize,
	begin: uint64,
	pivot: uint64,
	end: uint64
) -> bool
{
	if (ptr == null)
	{
		const message = make_malloc_error_message(size);
		emit_diagnostic(warning_kind_error, message.as_str(), begin, pivot, end);
		return false;
	}
	else
	{
		return true;
	}
}

@__comptime_error_checking("comptime_memcpy_check")
// dest and src are passed as *const uint8 because pointer casts are not allowed in comptime code
function comptime_memcpy_check(dest: *const uint8, src: *const uint8, size: usize, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (size == 0u)
	{
		return true;
	}

	if (dest == null)
	{
		emit_diagnostic(warning_kind_error, "'memcpy' called with null as the destination pointer", begin, pivot, end);
		return false;
	}
	else if (src == null)
	{
		emit_diagnostic(warning_kind_error, "'memcpy' called with null as the source pointer", begin, pivot, end);
		return false;
	}
	else if (dest != src && dest < src + size && src < dest + size)
	{
		emit_diagnostic(warning_kind_error, "'memcpy' called with overlapping ranges", begin, pivot, end);
		return false;
	}
	else
	{
		return true;
	}
}

@__comptime_error_checking("comptime_memmove_check")
// dest and src are passed as *const uint8 because pointer casts are not allowed in comptime code
function comptime_memmove_check(dest: *const uint8, src: *const uint8, size: usize, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (size == 0u)
	{
		return true;
	}

	if (dest == null)
	{
		emit_diagnostic(warning_kind_error, "'memmove' called with null as the destination pointer", begin, pivot, end);
		return false;
	}
	else if (src == null)
	{
		emit_diagnostic(warning_kind_error, "'memmove' called with null as the source pointer", begin, pivot, end);
		return false;
	}
	else
	{
		return true;
	}
}

@__comptime_error_checking("comptime_memset_check")
// dest is passed as *const uint8 because pointer casts are not allowed in comptime code
function comptime_memset_check(dest: *const uint8, : uint8, size: usize, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (size == 0u)
	{
		return true;
	}

	if (dest == null)
	{
		emit_diagnostic(warning_kind_error, "'memset' called with null as the destination pointer", begin, pivot, end);
		return false;
	}
	else
	{
		return true;
	}
}

function get_divide_overflow_error_message(type_name: str, lhs: int64, rhs: int64) -> string
{
	return concat("overflow in compile-time execution of '", lhs, " / ", "' with type '", type_name, "' results in ", lhs);
}

function get_divide_by_zero_error_message(type_name: str, lhs: int64, rhs: int64) -> string
{
	return concat("dividing by zero in compile-time execution of '", lhs, " / ", rhs, "' with type '", type_name, "'");
}

function get_divide_by_zero_error_message(type_name: str, lhs: uint64, rhs: uint64) -> string
{
	return concat("dividing by zero in compile-time execution of '", lhs, " / ", rhs, "' with type '", type_name, "'");
}

@__comptime_error_checking("i8_divide_check")
function i8_divide_check(lhs: int8, rhs: int8, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	consteval i8_min = (((1u8 << 7) as int8));
	static_assert(((i8_min - 1i8)) > 0);
	if (rhs == 0)
	{
		const message = get_divide_by_zero_error_message("int8", lhs, rhs);
		emit_diagnostic(warning_kind_error, message.as_str(), begin, pivot, end);
		return false;
	}
	else if (lhs == i8_min && rhs == -1)
	{
		const message = get_divide_overflow_error_message("int8", lhs, rhs);
		emit_diagnostic(warning_kind_int_overflow, message.as_str(), begin, pivot, end);
		return false;
	}
	else
	{
		return true;
	}
}

@__comptime_error_checking("i16_divide_check")
function i16_divide_check(lhs: int16, rhs: int16, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	consteval i16_min = (((1u16 << 15) as int16));
	static_assert(((i16_min - 1i16)) > 0);
	if (rhs == 0)
	{
		const message = get_divide_by_zero_error_message("int16", lhs, rhs);
		emit_diagnostic(warning_kind_error, message.as_str(), begin, pivot, end);
		return false;
	}
	else if (lhs == i16_min && rhs == -1)
	{
		const message = get_divide_overflow_error_message("int16", lhs, rhs);
		emit_diagnostic(warning_kind_int_overflow, message.as_str(), begin, pivot, end);
		return false;
	}
	else
	{
		return true;
	}
}

@__comptime_error_checking("i32_divide_check")
function i32_divide_check(lhs: int32, rhs: int32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	consteval i32_min = (((1u32 << 31) as int32));
	static_assert(((i32_min - 1i32)) > 0);
	if (rhs == 0)
	{
		const message = get_divide_by_zero_error_message("int32", lhs, rhs);
		emit_diagnostic(warning_kind_error, message.as_str(), begin, pivot, end);
		return false;
	}
	else if (lhs == i32_min && rhs == -1)
	{
		const message = get_divide_overflow_error_message("int32", lhs, rhs);
		emit_diagnostic(warning_kind_int_overflow, message.as_str(), begin, pivot, end);
		return false;
	}
	else
	{
		return true;
	}
}

@__comptime_error_checking("i64_divide_check")
function i64_divide_check(lhs: int64, rhs: int64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	consteval i64_min = (((1u64 << 63) as int64));
	static_assert(((i64_min - 1i64)) > 0);
	if (rhs == 0)
	{
		const message = get_divide_by_zero_error_message("int64", lhs, rhs);
		emit_diagnostic(warning_kind_error, message.as_str(), begin, pivot, end);
		return false;
	}
	else if (lhs == i64_min && rhs == -1)
	{
		const message = get_divide_overflow_error_message("int64", lhs, rhs);
		emit_diagnostic(warning_kind_int_overflow, message.as_str(), begin, pivot, end);
		return false;
	}
	else
	{
		return true;
	}
}

@__comptime_error_checking("u8_divide_check")
function u8_divide_check(lhs: uint8, rhs: uint8, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (rhs == 0u)
	{
		const message = get_divide_by_zero_error_message("uint8", lhs, rhs);
		emit_diagnostic(warning_kind_error, message.as_str(), begin, pivot, end);
		return false;
	}
	else
	{
		return true;
	}
}

@__comptime_error_checking("u16_divide_check")
function u16_divide_check(lhs: uint16, rhs: uint16, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (rhs == 0u)
	{
		const message = get_divide_by_zero_error_message("uint16", lhs, rhs);
		emit_diagnostic(warning_kind_error, message.as_str(), begin, pivot, end);
		return false;
	}
	else
	{
		return true;
	}
}

@__comptime_error_checking("u32_divide_check")
function u32_divide_check(lhs: uint32, rhs: uint32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (rhs == 0u)
	{
		const message = get_divide_by_zero_error_message("uint32", lhs, rhs);
		emit_diagnostic(warning_kind_error, message.as_str(), begin, pivot, end);
		return false;
	}
	else
	{
		return true;
	}
}

@__comptime_error_checking("u64_divide_check")
function u64_divide_check(lhs: uint64, rhs: uint64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (rhs == 0u)
	{
		const message = get_divide_by_zero_error_message("uint64", lhs, rhs);
		emit_diagnostic(warning_kind_error, message.as_str(), begin, pivot, end);
		return false;
	}
	else
	{
		return true;
	}
}

function get_modulo_by_zero_error_message(type_name: str, lhs: int64, rhs: int64) -> string
{
	return concat("taking modulo by zero in compile-time execution of '", lhs, " % ", rhs, "' with type '", type_name, "'");
}

function get_modulo_by_zero_error_message(type_name: str, lhs: uint64, rhs: uint64) -> string
{
	return concat("taking modulo by zero in compile-time execution of '", lhs, " % ", rhs, "' with type '", type_name, "'");
}

@__comptime_error_checking("i8_modulo_check")
function i8_modulo_check(lhs: int8, rhs: int8, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (rhs == 0)
	{
		const message = get_modulo_by_zero_error_message("int8", lhs, rhs);
		emit_diagnostic(warning_kind_error, message.as_str(), begin, pivot, end);
		return false;
	}
	else
	{
		return true;
	}
}

@__comptime_error_checking("i16_modulo_check")
function i16_modulo_check(lhs: int16, rhs: int16, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (rhs == 0)
	{
		const message = get_modulo_by_zero_error_message("int16", lhs, rhs);
		emit_diagnostic(warning_kind_error, message.as_str(), begin, pivot, end);
		return false;
	}
	else
	{
		return true;
	}
}

@__comptime_error_checking("i32_modulo_check")
function i32_modulo_check(lhs: int32, rhs: int32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (rhs == 0)
	{
		const message = get_modulo_by_zero_error_message("int32", lhs, rhs);
		emit_diagnostic(warning_kind_error, message.as_str(), begin, pivot, end);
		return false;
	}
	else
	{
		return true;
	}
}

@__comptime_error_checking("i64_modulo_check")
function i64_modulo_check(lhs: int64, rhs: int64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (rhs == 0)
	{
		const message = get_modulo_by_zero_error_message("int64", lhs, rhs);
		emit_diagnostic(warning_kind_error, message.as_str(), begin, pivot, end);
		return false;
	}
	else
	{
		return true;
	}
}

@__comptime_error_checking("u8_modulo_check")
function u8_modulo_check(lhs: uint8, rhs: uint8, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (rhs == 0u)
	{
		const message = get_modulo_by_zero_error_message("uint8", lhs, rhs);
		emit_diagnostic(warning_kind_error, message.as_str(), begin, pivot, end);
		return false;
	}
	else
	{
		return true;
	}
}

@__comptime_error_checking("u16_modulo_check")
function u16_modulo_check(lhs: uint16, rhs: uint16, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (rhs == 0u)
	{
		const message = get_modulo_by_zero_error_message("uint16", lhs, rhs);
		emit_diagnostic(warning_kind_error, message.as_str(), begin, pivot, end);
		return false;
	}
	else
	{
		return true;
	}
}

@__comptime_error_checking("u32_modulo_check")
function u32_modulo_check(lhs: uint32, rhs: uint32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (rhs == 0u)
	{
		const message = get_modulo_by_zero_error_message("uint32", lhs, rhs);
		emit_diagnostic(warning_kind_error, message.as_str(), begin, pivot, end);
		return false;
	}
	else
	{
		return true;
	}
}

@__comptime_error_checking("u64_modulo_check")
function u64_modulo_check(lhs: uint64, rhs: uint64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (rhs == 0u)
	{
		const message = get_modulo_by_zero_error_message("uint64", lhs, rhs);
		emit_diagnostic(warning_kind_error, message.as_str(), begin, pivot, end);
		return false;
	}
	else
	{
		return true;
	}
}

function float_to_bits(x: float32) -> uint32
{
	let result = 0u32;
	memcpy(&result, &x, sizeof float32);
	return result;
}

function bits_to_float(bits: uint32) -> float32
{
	let result = 0.0f32;
	memcpy(&result, &bits, sizeof float32);
	return result;
}

function double_to_bits(x: float64) -> uint64
{
	let result = 0u64;
	memcpy(&result, &x, sizeof float64);
	return result;
}

function bits_to_double(bits: uint64) -> float64
{
	let result = 0.0;
	memcpy(&result, &bits, sizeof float64);
	return result;
}

function isnan(x: float32) -> bool
{
	const bits = float_to_bits(x);
	consteval exponent_mask = 0x7f80'0000u32;
	consteval mantissa_mask = 0x007f'ffffu32;
	return (bits & exponent_mask) == exponent_mask && (bits & mantissa_mask) != 0u;
}

function isnan(x: float64) -> bool
{
	const bits = double_to_bits(x);
	consteval exponent_mask = 0x7ff0'0000'0000'0000u64;
	consteval mantissa_mask = 0x000f'ffff'ffff'ffffu64;
	return (bits & exponent_mask) == exponent_mask && (bits & mantissa_mask) != 0u;
}

function isinf(x: float32) -> bool
{
	const bits = float_to_bits(x);
	consteval exponent_mask = 0x7f80'0000u32;
	consteval mantissa_mask = 0x007f'ffffu32;
	return (bits & exponent_mask) == exponent_mask && (bits & mantissa_mask) == 0u;
}

function isinf(x: float64) -> bool
{
	const bits = double_to_bits(x);
	consteval exponent_mask = 0x7ff0'0000'0000'0000u64;
	consteval mantissa_mask = 0x000f'ffff'ffff'ffffu64;
	return (bits & exponent_mask) == exponent_mask && (bits & mantissa_mask) == 0u;
}

function isfinite(x: float32) -> bool
{
	const bits = float_to_bits(x);
	consteval exponent_mask = 0x7f80'0000u32;
	return (bits & exponent_mask) != exponent_mask;
}

function isfinite(x: float64) -> bool
{
	const bits = double_to_bits(x);
	consteval exponent_mask = 0x7ff0'0000'0000'0000u64;
	return (bits & exponent_mask) != exponent_mask;
}

function isint(x: float32) -> bool
{
	const bits = float_to_bits(x);
	consteval exponent_mask = 0x7f80'0000u32;
	consteval mantissa_mask = 0x007f'ffffu32;
	consteval exponent_bias = 127u32;
	consteval exponent_inf = exponent_mask >> __builtin_ctz_u32(exponent_mask);
	consteval mantissa_size = __builtin_popcount_u32(mantissa_mask);

	// special case for 0.0
	if ((bits & (mantissa_mask | exponent_mask)) == 0u)
	{
		return true;
	}

	const exponent = (bits & exponent_mask) >> __builtin_ctz_u32(exponent_mask);
	const mantissa_non_zero = mantissa_size - __builtin_ctz_u32((bits & mantissa_mask) | (1u32 << mantissa_size));
	return exponent != exponent_inf
		&& exponent >= exponent_bias
		&& exponent - exponent_bias >= mantissa_non_zero;
}


function isint(x: float64) -> bool
{
	const bits = double_to_bits(x);
	consteval exponent_mask = 0x7ff0'0000'0000'0000u64;
	consteval mantissa_mask = 0x000f'ffff'ffff'ffffu64;
	consteval exponent_bias = 1023u64;
	consteval exponent_inf = exponent_mask >> __builtin_ctz_u64(exponent_mask);
	consteval mantissa_size = __builtin_popcount_u64(mantissa_mask);

	// special case for 0.0
	if ((bits & (mantissa_mask | exponent_mask)) == 0u)
	{
		return true;
	}

	const exponent = (bits & exponent_mask) >> __builtin_ctz_u64(exponent_mask);
	const mantissa_non_zero = mantissa_size - __builtin_ctz_u64((bits & mantissa_mask) | (1u64 << mantissa_size));
	return exponent != exponent_inf
		&& exponent >= exponent_bias
		&& exponent - exponent_bias >= mantissa_non_zero;
}

function abs(x: float32) -> float32
{
	const bits = float_to_bits(x);
	consteval sign_mask = 0x8000'0000u32;
	return bits_to_float(bits & ~sign_mask);
}

function abs(x: float64) -> float64
{
	const bits = double_to_bits(x);
	consteval sign_mask = 0x8000'0000'0000'0000u64;
	return bits_to_double(bits & ~sign_mask);
}

consteval inf_f32: float32 = ((1.0f32 / 0.0f32));
consteval inf_f64: float64 = ((1.0 / 0.0));

function get_regular_math_error_message(func_name: str, x: float32, result: float32) -> string
{
	return concat("calling '", func_name, "' with ", x, " results in ", result);
}

function get_regular_math_error_message(func_name: str, x: float64, result: float64) -> string
{
	return concat("calling '", func_name, "' with ", x, " results in ", result);
}

function get_negative_math_error_message(func_name: str, x: float32, result: float32) -> string
{
	return concat("calling '", func_name, "' with a negative value ", x, " results in ", result);
}

function get_negative_math_error_message(func_name: str, x: float64, result: float64) -> string
{
	return concat("calling '", func_name, "' with a negative value ", x, " results in ", result);
}

function get_negative_integer_math_error_message(func_name: str, x: float32, result: float32) -> string
{
	return concat("calling '", func_name, "' with a negative integer ", x, " results in ", result);
}

function get_negative_integer_math_error_message(func_name: str, x: float64, result: float64) -> string
{
	return concat("calling '", func_name, "' with a negative integer ", x, " results in ", result);
}

@__comptime_error_checking("exp_f32_check")
function exp_f32_check(x: float32, result: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("exp", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("exp_f64_check")
function exp_f64_check(x: float64, result: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("exp", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("exp2_f32_check")
function exp2_f32_check(x: float32, result: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("exp2", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("exp2_f64_check")
function exp2_f64_check(x: float64, result: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("exp2", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("expm1_f32_check")
function expm1_f32_check(x: float32, result: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("expm1", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("expm1_f64_check")
function expm1_f64_check(x: float64, result: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("expm1", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("log_f32_check")
function log_f32_check(x: float32, result: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x) || x == 0.0f32)
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("log", x, result).as_str(),
			begin, pivot, end
		);
	}
	else if (x < 0.0f32)
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_negative_math_error_message("log", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("log_f64_check")
function log_f64_check(x: float64, result: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x) || x == 0.0)
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("log", x, result).as_str(),
			begin, pivot, end
		);
	}
	else if (x < 0.0)
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_negative_math_error_message("log", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("log10_f32_check")
function log10_f32_check(x: float32, result: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x) || x == 0.0f32)
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("log10", x, result).as_str(),
			begin, pivot, end
		);
	}
	else if (x < 0.0f32)
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_negative_math_error_message("log10", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("log10_f64_check")
function log10_f64_check(x: float64, result: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x) || x == 0.0)
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("log10", x, result).as_str(),
			begin, pivot, end
		);
	}
	else if (x < 0.0)
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_negative_math_error_message("log10", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("log2_f32_check")
function log2_f32_check(x: float32, result: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x) || x == 0.0f32)
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("log2", x, result).as_str(),
			begin, pivot, end
		);
	}
	else if (x < 0.0f32)
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_negative_math_error_message("log2", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("log2_f64_check")
function log2_f64_check(x: float64, result: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x) || x == 0.0)
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("log2", x, result).as_str(),
			begin, pivot, end
		);
	}
	else if (x < 0.0)
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_negative_math_error_message("log2", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("log1p_f32_check")
function log1p_f32_check(x: float32, result: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x) || x <= -1.0f32)
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("log1p", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("log1p_f64_check")
function log1p_f64_check(x: float64, result: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x) || x <= -1.0)
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("log1p", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("sqrt_f32_check")
function sqrt_f32_check(x: float32, result: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'sqrt' results in nan", begin, pivot, end);
	}
	else if (x < 0.0f32)
	{
		emit_diagnostic(warning_kind_error, "calling 'sqrt' with a negative value", begin, pivot, end);
		return false;
	}
	return true;
}

@__comptime_error_checking("sqrt_f64_check")
function sqrt_f64_check(x: float64, result: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("sqrt", x, result).as_str(),
			begin, pivot, end
		);
	}
	else if (x < 0.0)
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_negative_math_error_message("sqrt", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("pow_f32_check")
function pow_f32_check(x: float32, y: float32, result: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (x == 0.0f32 && y < 0.0f32)
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			concat("calling 'pow' with base ", x, " and exponent ", y, " results in ", result).as_str(),
			begin, pivot, end
		);
	}
	else if (isfinite(x) && x < 0.0f32 && isfinite(y) && !isint(y))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			concat("calling 'pow' with a negative base ", x, " and a non-integer exponent ", y, " results in ", result).as_str(),
			begin, pivot, end
		);
	}
	else if (x != 0.0f32 && y != 0.0f32 && (isnan(x) || isnan(y)))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			concat("calling 'pow' with base ", x, " and exponent ", y, " results in ", result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("pow_f64_check")
function pow_f64_check(x: float64, y: float64, result: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (x == 0.0 && y < 0.0)
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			concat("calling 'pow' with base ", x, " and exponent ", y, " results in ", result).as_str(),
			begin, pivot, end
		);
	}
	else if (isfinite(x) && x < 0.0 && isfinite(y) && !isint(y))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			concat("calling 'pow' with a negative base ", x, " and a non-integer exponent ", y, " results in ", result).as_str(),
			begin, pivot, end
		);
	}
	else if (x != 0.0 && y != 0.0 && (isnan(x) || isnan(y)))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			concat("calling 'pow' with base ", x, " and exponent ", y, " results in ", result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("cbrt_f32_check")
function cbrt_f32_check(x: float32, result: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("cbrt", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("cbrt_f64_check")
function cbrt_f64_check(x: float64, result: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("cbrt", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("hypot_f32_check")
function hypot_f32_check(x: float32, y: float32, result: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (!isinf(x) && !isinf(y) && (isnan(x) || isnan(y)))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			concat("calling 'hypot' with ", x, " and ", y, " results in ", result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("hypot_f64_check")
function hypot_f64_check(x: float64, y: float64, result: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (!isinf(x) && !isinf(y) && (isnan(x) || isnan(y)))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			concat("calling 'hypot' with ", x, " and ", y, " results in ", result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("sin_f32_check")
function sin_f32_check(x: float32, result: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x) || isinf(x))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("sin", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("sin_f64_check")
function sin_f64_check(x: float64, result: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x) || isinf(x))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("sin", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("cos_f32_check")
function cos_f32_check(x: float32, result: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x) || isinf(x))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("cos", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("cos_f64_check")
function cos_f64_check(x: float64, result: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x) || isinf(x))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("cos", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("tan_f32_check")
function tan_f32_check(x: float32, result: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x) || isinf(x))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("tan", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("tan_f64_check")
function tan_f64_check(x: float64, result: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x) || isinf(x))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("tan", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("asin_f32_check")
function asin_f32_check(x: float32, result: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x) || abs(x) > 1.0f32)
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("asin", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("asin_f64_check")
function asin_f64_check(x: float64, result: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x) || abs(x) > 1.0)
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("asin", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("acos_f32_check")
function acos_f32_check(x: float32, result: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x) || abs(x) > 1.0f32)
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("acos", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("acos_f64_check")
function acos_f64_check(x: float64, result: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x) || abs(x) > 1.0)
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("acos", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("atan_f32_check")
function atan_f32_check(x: float32, result: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("atan", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("atan_f64_check")
function atan_f64_check(x: float64, result: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("atan", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("atan2_f32_check")
function atan2_f32_check(y: float32, x: float32, result: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(y) || isnan(x))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			concat("calling 'atan2' with ", y, " and ", x, " results in ", result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("atan2_f64_check")
function atan2_f64_check(y: float64, x: float64, result: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(y) || isnan(x))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			concat("calling 'atan2' with ", y, " and ", x, " results in ", result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("sinh_f32_check")
function sinh_f32_check(x: float32, result: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("sinh", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("sinh_f64_check")
function sinh_f64_check(x: float64, result: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("sinh", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("cosh_f32_check")
function cosh_f32_check(x: float32, result: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("cosh", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("cosh_f64_check")
function cosh_f64_check(x: float64, result: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("cosh", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("tanh_f32_check")
function tanh_f32_check(x: float32, result: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("tanh", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("tanh_f64_check")
function tanh_f64_check(x: float64, result: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("tanh", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("asinh_f32_check")
function asinh_f32_check(x: float32, result: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("asinh", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("asinh_f64_check")
function asinh_f64_check(x: float64, result: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("asinh", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("acosh_f32_check")
function acosh_f32_check(x: float32, result: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x) || x < 1.0f32)
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("acosh", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("acosh_f64_check")
function acosh_f64_check(x: float64, result: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x) || x < 1.0)
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("acosh", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("atanh_f32_check")
function atanh_f32_check(x: float32, result: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x) || abs(x) >= 1.0f32)
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("atanh", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("atanh_f64_check")
function atanh_f64_check(x: float64, result: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x) || abs(x) >= 1.0)
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("atanh", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("erf_f32_check")
function erf_f32_check(x: float32, result: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("erf", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("erf_f64_check")
function erf_f64_check(x: float64, result: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("erf", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("erfc_f32_check")
function erfc_f32_check(x: float32, result: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("erfc", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("erfc_f64_check")
function erfc_f64_check(x: float64, result: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("erfc", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("tgamma_f32_check")
function tgamma_f32_check(x: float32, result: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x) || x == 0.0f32 || x == -inf_f32)
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("tgamma", x, result).as_str(),
			begin, pivot, end
		);
	}
	else if (x < 0.0f32 && isint(x))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_negative_integer_math_error_message("tgamma", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("tgamma_f64_check")
function tgamma_f64_check(x: float64, result: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x) || x == 0.0 || x == -inf_f64)
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("tgamma", x, result).as_str(),
			begin, pivot, end
		);
	}
	else if (x < 0.0 && isint(x))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_negative_integer_math_error_message("tgamma", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("lgamma_f32_check")
function lgamma_f32_check(x: float32, result: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x) || x == 0.0f32)
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("lgamma", x, result).as_str(),
			begin, pivot, end
		);
	}
	else if (x < 0.0f32 && isint(x))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_negative_integer_math_error_message("lgamma", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

@__comptime_error_checking("lgamma_f64_check")
function lgamma_f64_check(x: float64, result: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x) || x == 0.0)
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_regular_math_error_message("lgamma", x, result).as_str(),
			begin, pivot, end
		);
	}
	else if (x < 0.0 && isint(x))
	{
		emit_diagnostic(
			warning_kind_math_domain_error,
			get_negative_integer_math_error_message("lgamma", x, result).as_str(),
			begin, pivot, end
		);
	}
	return true;
}

function emit_diagnostic(kind: uint32, message: str, error_call_stack: vector<uint64>, begin: uint64, pivot: uint64, end: uint64)
{
	errors.push_back(error_t[ kind, src_tokens_t[ begin, pivot, end ], string(message), error_call_stack.release() ]);
}

function emit_diagnostic(kind: uint32, message: str, begin: uint64, pivot: uint64, end: uint64)
{
	errors.push_back(error_t[ kind, src_tokens_t[ begin, pivot, end ], string(message), call_stack ]);
}


@__builtin
consteval function __builtin_comptime_compile_error_src_tokens(message: str, begin: uint64, pivot: uint64, end: uint64)
{
	emit_diagnostic(warning_kind_error, message, begin, pivot, end);
}

@__builtin
consteval function __builtin_comptime_compile_warning_src_tokens(message: str, begin: uint64, pivot: uint64, end: uint64)
{
	emit_diagnostic(warning_kind_comptime_warning, message, begin, pivot, end);
}

@__no_runtime_emit
@__comptime_error_checking("global_strings_var")
let global_strings = vector<string>[ null, null, null ];

@__builtin
export consteval function __builtin_comptime_create_global_string(s: str) -> str
{
	global_strings.emplace_back(s);
	return global_strings.back().as_str();
}
