import ::std::string;

consteval warning_kind_int_overflow     = 0u32;
consteval warning_kind_float_nan_math   = 4u32;
consteval warning_kind_comptime_warning = 22u32;
consteval warning_kind_error            = 23u32;


// copied from std::format

@no_runtime_emit
consteval max_uint_string_length = 20uz;

@no_comptime_checking
function get_uint_as_string(n: uint64) -> [[max_uint_string_length: uint8], uint32]
{
	let result: [[max_uint_string_length: uint8], uint32];
	if (n < 10u)
	{
		result[0, max_uint_string_length - 1u] = ('0' + n) as uint32 as uint8;
		result[1] = 1u;
	}
	else
	{
		let it = result[0].end();
		while (n != 0u)
		{
			const digit = n % 10u;
			n /= 10u;
			--it;
			*it = ('0' + digit) as uint32 as uint8;
		}
		result[1] = (result[0].end() - it) as uint32;
	}
	return result;
}

@no_runtime_emit
consteval max_int_string_length = 20uz;

@no_comptime_checking
function get_int_as_string(abs_val: uint64, is_negative: bool) -> [[max_int_string_length: uint8], uint32]
{
	let n = abs_val;
	let result: [[max_int_string_length: uint8], uint32];
	if (n < 10u)
	{
		result[0, max_int_string_length - 1u] = ('0' + n) as uint32 as uint8;
		result[1] = 1u;
	}
	else
	{
		let it = result[0].end();
		while (n != 0u)
		{
			const digit = n % 10u;
			n /= 10u;
			--it;
			*it = ('0' + digit) as uint32 as uint8;
		}
		result[1] = (result[0].end() - it) as uint32;
	}
	if (is_negative)
	{
		*(result[0].end() - result[1] - 1u) = '-' as uint32 as uint8;
		++result[1];
	}
	return result;
}

@no_comptime_checking
function append_number(s: &std::string, n: int64)
{
	const [buffer, size] = get_int_as_string(if (n < 0) { (-n) as uint64 } else { n as uint64 }, n < 0);
	s ..= __builtin_str_from_ptrs(buffer.end() - size, buffer.end());
}

@no_comptime_checking
function append_number(s: &std::string, n: uint64)
{
	const [buffer, size] = get_uint_as_string(n);
	s ..= __builtin_str_from_ptrs(buffer.end() - size, buffer.end());
}

/*
function print = __builtin_print_stdout;
function println = __builtin_println_stdout;

@no_comptime_checking
function print_ascii_char(c: char)
{
	const c_int_val = c as uint32 as uint8;
	print(__builtin_str_from_ptrs(&c_int_val, &c_int_val + 1));
}

@no_comptime_checking
function print_uint_impl(n: uint64, base: consteval uint64)
{
	if (n < 10u)
	{
		print_ascii_char('0' + n);
	}
	else if (n < base)
	{
		print_ascii_char('a' + n - 10);
	}
	else
	{
		print_uint_impl(n / base, base);
		const mod = n % base;
		const c = if (mod < 10u) { '0' + mod } else { 'a' + mod - 10 };
		print_ascii_char(c);
	}
}

@no_comptime_checking
function print_uint(n: uint64, base: consteval uint64)
{
	if (n == 0u)
	{
		print("0");
	}
	else
	{
		print_uint_impl(n, base);
	}
}

@no_comptime_checking
export function print(n: uint64)
{
	print_uint(n, 10u);
}

@no_comptime_checking
export function print(p: *const void)
{
	print("0x"), print_uint(__builtin_pointer_to_int(p), 16u);
}

@no_comptime_checking
export function println(n: uint64)
{
	print_uint(n, 10u), println("");
}

@no_comptime_checking
export function println(p: *const void)
{
	print("0x"), print_uint(__builtin_pointer_to_int(p), 16u), println("");
}

// */

// some functions to help create vectors easily until templates and std::vector are implemented
// this assumes that the following are implemented
//   - destructor in the form of `destructor(&self) { self.destruct_vector(); }`
//   - swap function in the form of `function swap(&lhs, &rhs) { lhs.swap_vector(rhs); }`
//   - operator = in the form of `operator = (&lhs, #const rhs) -> typeof lhs { lhs.assign_vector(rhs); return lhs; }`
// the structs must have ._data_begin, ._data_end, ._alloc_end members which are the same pointer types

function alloc = __builtin_comptime_malloc_type;
function free  = __builtin_comptime_free;

@no_comptime_checking
function destruct_vector(&vec)
{
	for (let &elem in vec.as_slice())
	{
		__builtin_call_destructor(elem);
	}
	free(vec._data_begin);
	vec._data_begin = null;
	vec._data_end   = null;
	vec._alloc_end  = null;
}

@no_comptime_checking
function swap(a: &auto, b: &auto)
{
	static_assert(typeof a == typeof b, "different types in swap");
	static_assert(typeof a != &std::string);
	const temp = a;
	a = b;
	b = temp;
}

@no_comptime_checking
function swap_vector(&lhs, &rhs)
{
	lhs._data_begin.swap(rhs._data_begin);
	lhs._data_end  .swap(rhs._data_end);
	lhs._alloc_end .swap(rhs._alloc_end);
}

@no_comptime_checking
function size(s: &const str) -> usize
{
	return __builtin_str_size(s);
}

@no_comptime_checking
function size(#const vec) -> usize
{
	return (vec._data_end - vec._data_begin) as usize;
}

@no_comptime_checking
function capacity(&const vec) -> usize
{
	return (vec._alloc_end - vec._data_begin) as usize;
}

@no_comptime_checking
function empty(&const vec) -> bool
{
	return vec._data_begin == vec._data_end;
}

@no_comptime_checking
function not_empty(&const vec) -> bool
{
	return vec._data_begin != vec._data_end;
}

@no_comptime_checking
function as_slice(&vec) -> [: typeof *vec._data_begin]
{
	return __builtin_slice_from_ptrs(vec._data_begin, vec._data_end);
}

@no_comptime_checking
function as_slice(&const vec) -> [: const typeof *vec._data_begin]
{
	return __builtin_slice_from_const_ptrs(vec._data_begin, vec._data_end);
}

@no_comptime_checking
operator [] (&vec, i: uint64) -> &typeof *vec._data_begin
{
	return *(vec._data_begin + i);
}

@no_comptime_checking
operator [] (&const vec, i: uint64) -> &const typeof *vec._data_begin
{
	return *(vec._data_begin + i);
}

@no_comptime_checking
operator [] (&vec, i: int64) -> &typeof *vec._data_begin
{
	return *(vec._data_begin + i);
}

@no_comptime_checking
operator [] (&const vec, i: int64) -> &const typeof *vec._data_begin
{
	return *(vec._data_begin + i);
}

@no_comptime_checking
function front(&vec) -> &typeof *vec._data_begin
{
	return *vec._data_begin;
}

@no_comptime_checking
function front(&const vec) -> &const typeof *vec._data_begin
{
	return *vec._data_begin;
}

@no_comptime_checking
function back(&vec) -> &typeof *vec._data_begin
{
	return *(vec._data_end - 1);
}

@no_comptime_checking
function back(&const vec) -> &const typeof *vec._data_begin
{
	return *(vec._data_end - 1);
}


@no_comptime_checking
function round_to_next_power_of_two(n: usize) -> usize
{
	// https://stackoverflow.com/a/466242/11488457
	n -= 1u;
	n |= n >> 1;
	n |= n >> 2;
	n |= n >> 4;
	n |= n >> 8;
	n |= n >> 16;
	n |= n >> 32;
	n += 1u;
	return n;
}

@no_comptime_checking
function reserve(&vec, new_capacity: usize)
{
	type value_type = typeof *vec._data_begin;

	new_capacity = round_to_next_power_of_two(new_capacity);

	if (vec.capacity() < new_capacity)
	{
		const size = vec.size();
		const new_array = alloc(value_type, new_capacity);
		for (let i = 0uz; i < size; ++i)
		{
			// __builtin_inplace_construct(new_array + i, value_type());
			__builtin_memset(new_array + i, 0u8, sizeof value_type);
			(new_array + i)->swap(*(vec._data_begin + i));
			__builtin_call_destructor(*(vec._data_begin + i));
		}
		free(vec._data_begin);
		vec._data_begin = new_array;
		vec._data_end   = new_array + size;
		vec._alloc_end  = new_array + new_capacity;
	}
}

@no_comptime_checking
function push_back(&vec, val)
{
	type value_type = typeof *vec._data_begin;
	static_assert(value_type == typeof val, "invalid type in push_back");

	vec.reserve(vec.size() + 1u);
	let &pushed_val = *vec._data_end;
	__builtin_inplace_construct(&pushed_val, value_type());
	val.swap(pushed_val);
	vec._data_end += 1;
}

@no_comptime_checking
function push_back(&vec, val: ##uint64)
{
	type value_type = typeof *vec._data_begin;
	static_assert(value_type == uint64, "invalid type in push_back");

	vec.reserve(vec.size() + 1u);
	*(vec._data_end) = val;
	vec._data_end += 1;
}

@no_comptime_checking
function emplace_back(&vec, ...##args)
{
	type value_type = typeof *vec._data_begin;

	vec.reserve(vec.size() + 1u);
	__builtin_inplace_construct(vec._data_end, value_type(...args));
	vec._data_end += 1;
}

@no_comptime_checking
function pop_back(&vec)
{
	if (vec._data_begin == vec._data_end)
	{
		return;
	}
	vec._data_end -= 1;
	__builtin_call_destructor(*vec._data_end);
}

@no_comptime_checking
function clear(&vec)
{
	for (let it = vec._data_end; it != vec._data_begin;)
	{
		--it;
		__builtin_call_destructor(*it);
	}
	vec._data_end = vec._data_begin;
}

@no_comptime_checking
function assign_vector(&lhs, &const rhs)
{
	lhs.clear();
	lhs.reserve(rhs.size());
	for (let &const elem in rhs.as_slice())
	{
		__builtin_inplace_construct(lhs._data_end, elem);
		lhs._data_end += 1;
	}
}

@no_comptime_checking
function assign_vector(&lhs, &rhs)
{
	lhs.swap_vector(rhs);
}


struct call_stack_t
{
	._data_begin: *uint64;
	._data_end:   *uint64;
	._alloc_end:  *uint64;

	// @no_comptime_checking
	destructor(&self)
	{
		self.destruct_vector();
	}
}

@no_comptime_checking
function swap(a: &call_stack_t, b: &call_stack_t)
{
	a.swap_vector(b);
}

operator = (lhs: &call_stack_t, rhs: &const call_stack_t) -> &call_stack_t
{
	lhs.assign_vector(rhs);
	return lhs;
}

operator = (lhs: &call_stack_t, rhs: call_stack_t) -> &call_stack_t
{
	lhs.assign_vector(rhs);
	return lhs;
}

struct src_tokens_t
{
	.begin: uint64;
	.pivot: uint64;
	.end:   uint64;
}

struct error_t
{
	.kind: uint32;
	.src_tokens: src_tokens_t;
	.message: std::string;
	.call_stack: [: uint64];

	constructor()
	{
		return error_t[
			0u,
			src_tokens_t[ 0u, 0u, 0u ],
			std::string(),
			__builtin_slice_from_ptrs(null as *uint64, null as *uint64)
		];
	}

	// @no_comptime_checking
	destructor(&self)
	{
		free(self.call_stack.begin());
	}
}

@no_comptime_checking
function swap(a: &error_t, b: &error_t)
{
	a.kind.swap(b.kind);
	a.src_tokens.swap(b.src_tokens);
	a.message.swap(b.message);
	a.call_stack.swap(b.call_stack);
}

@no_comptime_checking
operator = (lhs: &error_t, rhs: error_t) -> &error_t
{
	lhs.swap(rhs);
	return lhs;
}

struct error_array_t
{
	._data_begin: *error_t;
	._data_end:   *error_t;
	._alloc_end:  *error_t;

	// @no_comptime_checking
	destructor(&self)
	{
		self.destruct_vector();
	}
}

@no_comptime_checking
function swap(a: &error_array_t, b: &error_array_t)
{
	a.swap_vector(b);
}

@no_comptime_checking
operator = (lhs: &error_array_t, rhs: &const error_array_t) -> &error_array_t
{
	lhs.assign_vector(rhs);
	return lhs;
}

@no_comptime_checking
operator = (lhs: &error_array_t, rhs: error_array_t) -> &error_array_t
{
	lhs.assign_vector(rhs);
	return lhs;
}

@no_runtime_emit
@comptime_error_checking("errors_var")
let errors = error_array_t[ null, null, null ];

@no_runtime_emit
@comptime_error_checking("call_stack_var")
let call_stack = call_stack_t[ null, null, null ];


@comptime_error_checking("cleanup")
function cleanup()
{
	__builtin_call_destructor(global_strings); // needs to be first, because std::string functions need call stacks
	__builtin_call_destructor(errors);
	__builtin_call_destructor(call_stack);
}

@comptime_error_checking("get_error_count")
function get_error_count() -> uint64
{
	return errors.size();
}

@comptime_error_checking("get_error_kind_by_index")
function get_error_kind_by_index(i: uint64) -> uint32
{
	return if (i < errors.size()) { errors[i].kind } else { 0u32 };
}

@comptime_error_checking("get_error_begin_by_index")
function get_error_begin_by_index(i: uint64) -> uint64
{
	return if (i < errors.size()) { errors[i].src_tokens.begin } else { 0u64 };
}

@comptime_error_checking("get_error_pivot_by_index")
function get_error_pivot_by_index(i: uint64) -> uint64
{
	return if (i < errors.size()) { errors[i].src_tokens.pivot } else { 0u64 };
}

@comptime_error_checking("get_error_end_by_index")
function get_error_end_by_index(i: uint64) -> uint64
{
	return if (i < errors.size()) { errors[i].src_tokens.end } else { 0u64 };
}

@comptime_error_checking("get_error_message_size_by_index")
function get_error_message_size_by_index(i: uint64) -> uint64
{
	return if (i < errors.size()) { errors[i].message.size() } else { 0u64 };
}

@comptime_error_checking("get_error_message_by_index")
function get_error_message_char_by_index(i: uint64, buffer: *uint8)
{
	if (i < errors.size())
	{
		__builtin_memcpy(buffer, errors[i].message.data(), errors[i].message.size());
	}
}

@comptime_error_checking("get_error_call_stack_size_by_index")
function get_error_call_stack_size_by_index(i: uint64) -> uint64
{
	return if (i < errors.size()) { errors[i].call_stack.size() } else { 0u64 };
}

@comptime_error_checking("get_error_call_stack_element_by_index")
function get_error_call_stack_element_by_index(i: uint64, j: uint64) -> uint64
{
	return if (i < errors.size() && j < errors[i].call_stack.size()) { errors[i].call_stack[j] } else { 0u64 };
}

@comptime_error_checking("has_errors")
function has_errors() -> bool
{
	for (let &const error in errors.as_slice())
	{
		if (error.kind == warning_kind_error)
		{
			return true;
		}
	}
	return false;
}

@no_comptime_checking
function str_from_c_str(c_str: *const uint8) -> str
{
	let it = c_str;
	while (*it != 0u)
	{
		++it;
	}
	return __builtin_str_from_ptrs(c_str, it);
}

@no_comptime_checking
function get_call_stack_array_copy() -> [: uint64]
{
	const call_stack_size = call_stack.size();
	if (call_stack_size == 0u)
	{
		const result = __builtin_slice_from_ptrs(null as *uint64, null as *uint64);
		return result;
	}
	else
	{
		const ptr = alloc(uint64, call_stack_size);
		const result = __builtin_slice_from_ptrs(ptr, ptr + call_stack_size);
		for (let i = 0u; i < call_stack_size; ++i)
		{
			result[i] = call_stack[i];
		}
		return result;
	}
}

@comptime_error_checking("add_error")
function add_error(kind: uint32, begin: uint64, pivot: uint64, end: uint64, message: *const uint8)
{
	const call_stack_array = get_call_stack_array_copy();
	const message_str = str_from_c_str(message);
	errors.push_back(error_t[ kind, src_tokens_t[ begin, pivot, end ], std::string(message_str), call_stack_array ]);
}

@comptime_error_checking("push_call")
function push_call(call: uint64)
{
	call_stack.push_back(call);
}

@comptime_error_checking("pop_call")
function pop_call()
{
	call_stack.pop_back();
}

@comptime_error_checking("clear_errors")
function clear_errors()
{
	errors.clear();
}


@no_comptime_checking
function make_index_error_message(index: usize, size: usize) -> std::string
{
	let result = std::string("index ");
	result.append_number(index);
	result ..= " is out-of-bounds for an array of size ";
	result.append_number(size);
	return result.release();
}

@no_comptime_checking
function make_index_error_message(index: isize, size: usize) -> std::string
{
	if (index < 0)
	{
		let result = std::string("negative index ");
		result.append_number(index);
		result ..= " in subscript for an array of size ";
		result.append_number(size);
		return result.release();
	}
	else
	{
		return make_index_error_message(index as usize, size);
	}
}

@comptime_error_checking("index_check_unsigned")
function index_check_unsigned(
	index: usize,
	size: usize,
	kind: uint32,
	begin: uint64,
	pivot: uint64,
	end: uint64
) -> bool
{
	if (index >= size)
	{
		const call_stack_array = get_call_stack_array_copy();
		errors.push_back(error_t[ kind, src_tokens_t[ begin, pivot, end ], make_index_error_message(index, size), call_stack_array ]);
		return false;
	}
	else
	{
		return true;
	}
}

@comptime_error_checking("index_check_signed")
function index_check_signed(
	index: isize,
	size: usize,
	kind: uint32,
	begin: uint64,
	pivot: uint64,
	end: uint64
) -> bool
{
	if (index < 0 || index as usize >= size)
	{
		const call_stack_array = get_call_stack_array_copy();
		errors.push_back(error_t[ kind, src_tokens_t[ begin, pivot, end ], make_index_error_message(index, size), call_stack_array ]);
		return false;
	}
	else
	{
		return true;
	}
}

@no_comptime_checking
function make_malloc_error_message(size: usize) -> std::string
{
	let result = std::string("failed to allocate ");
	result.append_number(size);
	result ..= " bytes in comptime malloc";
	return result.release();
}

@comptime_error_checking("comptime_malloc_check")
function comptime_malloc_check(
	ptr: *void,
	size: usize,
	begin: uint64,
	pivot: uint64,
	end: uint64
) -> bool
{
	if (ptr == null)
	{
		const message = make_malloc_error_message(size);
		emit_diagnostic(warning_kind_error, message.as_str(), begin, pivot, end);
		return false;
	}
	else
	{
		return true;
	}
}

@comptime_error_checking("comptime_memcpy_check")
// dest and src are passed as *const uint8 because pointer casts are not allowed in comptime code
function comptime_memcpy_check(dest: *const uint8, src: *const uint8, size: usize, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (size == 0u)
	{
		return true;
	}

	if (dest == null)
	{
		emit_diagnostic(warning_kind_error, "'memcpy' called with null as the destination pointer", begin, pivot, end);
		return false;
	}
	else if (src == null)
	{
		emit_diagnostic(warning_kind_error, "'memcpy' called with null as the source pointer", begin, pivot, end);
		return false;
	}
	else if (dest != src && dest < src + size && src < dest + size)
	{
		emit_diagnostic(warning_kind_error, "'memcpy' called with overlapping ranges", begin, pivot, end);
		return false;
	}
	else
	{
		return true;
	}
}

@comptime_error_checking("comptime_memmove_check")
// dest and src are passed as *const uint8 because pointer casts are not allowed in comptime code
function comptime_memmove_check(dest: *const uint8, src: *const uint8, size: usize, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (size == 0u)
	{
		return true;
	}

	if (dest == null)
	{
		emit_diagnostic(warning_kind_error, "'memmove' called with null as the destination pointer", begin, pivot, end);
		return false;
	}
	else if (src == null)
	{
		emit_diagnostic(warning_kind_error, "'memmove' called with null as the source pointer", begin, pivot, end);
		return false;
	}
	else
	{
		return true;
	}
}

@comptime_error_checking("comptime_memset_check")
// dest is passed as *const uint8 because pointer casts are not allowed in comptime code
function comptime_memset_check(dest: *const uint8, : uint8, size: usize, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (size == 0u)
	{
		return true;
	}

	if (dest == null)
	{
		emit_diagnostic(warning_kind_error, "'memset' called with null as the destination pointer", begin, pivot, end);
		return false;
	}
	else
	{
		return true;
	}
}

@no_comptime_checking
function get_divide_overflow_error_message(type_name: str, lhs: int64, rhs: int64) -> std::string
{
	let result = std::string("overflow in compile time execution of '");
	result.append_number(lhs);
	result ..= " / ";
	result.append_number(rhs);
	result ..= "' with type '";
	result ..= type_name;
	result ..= "' results in ";
	result.append_number(lhs);
	return result.release();
}

@no_comptime_checking
function get_divide_by_zero_error_message(type_name: str, lhs: int64, rhs: int64) -> std::string
{
	let result = std::string("dividing by zero in compile time execution of '");
	result.append_number(lhs);
	result ..= " / ";
	result.append_number(rhs);
	result ..= "' with type '";
	result ..= type_name;
	result ..= '\'';
	return result.release();
}

@no_comptime_checking
function get_divide_by_zero_error_message(type_name: str, lhs: uint64, rhs: uint64) -> std::string
{
	let result = std::string("dividing by zero in compile time execution of '");
	result.append_number(lhs);
	result ..= " / ";
	result.append_number(rhs);
	result ..= "' with type '";
	result ..= type_name;
	result ..= '\'';
	return result.release();
}

@comptime_error_checking("i8_divide_check")
function i8_divide_check(lhs: int8, rhs: int8, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	consteval i8_min = (((1u8 << 7) as int8));
	static_assert(((i8_min - 1i8)) > 0);
	if (rhs == 0)
	{
		const message = get_divide_by_zero_error_message("int8", lhs, rhs);
		emit_diagnostic(warning_kind_error, message.as_str(), begin, pivot, end);
		return false;
	}
	else if (lhs == i8_min && rhs == -1)
	{
		const message = get_divide_overflow_error_message("int8", lhs, rhs);
		emit_diagnostic(warning_kind_int_overflow, message.as_str(), begin, pivot, end);
		return false;
	}
	else
	{
		return true;
	}
}

@comptime_error_checking("i16_divide_check")
function i16_divide_check(lhs: int16, rhs: int16, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	consteval i16_min = (((1u16 << 15) as int16));
	static_assert(((i16_min - 1i16)) > 0);
	if (rhs == 0)
	{
		const message = get_divide_by_zero_error_message("int16", lhs, rhs);
		emit_diagnostic(warning_kind_error, message.as_str(), begin, pivot, end);
		return false;
	}
	else if (lhs == i16_min && rhs == -1)
	{
		const message = get_divide_overflow_error_message("int16", lhs, rhs);
		emit_diagnostic(warning_kind_int_overflow, message.as_str(), begin, pivot, end);
		return false;
	}
	else
	{
		return true;
	}
}

@comptime_error_checking("i32_divide_check")
function i32_divide_check(lhs: int32, rhs: int32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	consteval i32_min = (((1u32 << 31) as int32));
	static_assert(((i32_min - 1i32)) > 0);
	if (rhs == 0)
	{
		const message = get_divide_by_zero_error_message("int32", lhs, rhs);
		emit_diagnostic(warning_kind_error, message.as_str(), begin, pivot, end);
		return false;
	}
	else if (lhs == i32_min && rhs == -1)
	{
		const message = get_divide_overflow_error_message("int32", lhs, rhs);
		emit_diagnostic(warning_kind_int_overflow, message.as_str(), begin, pivot, end);
		return false;
	}
	else
	{
		return true;
	}
}

@comptime_error_checking("i64_divide_check")
function i64_divide_check(lhs: int64, rhs: int64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	consteval i64_min = (((1u64 << 63) as int64));
	static_assert(((i64_min - 1i64)) > 0);
	if (rhs == 0)
	{
		const message = get_divide_by_zero_error_message("int64", lhs, rhs);
		emit_diagnostic(warning_kind_error, message.as_str(), begin, pivot, end);
		return false;
	}
	else if (lhs == i64_min && rhs == -1)
	{
		const message = get_divide_overflow_error_message("int64", lhs, rhs);
		emit_diagnostic(warning_kind_int_overflow, message.as_str(), begin, pivot, end);
		return false;
	}
	else
	{
		return true;
	}
}

@comptime_error_checking("u8_divide_check")
function u8_divide_check(lhs: uint8, rhs: uint8, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (rhs == 0u)
	{
		const message = get_divide_by_zero_error_message("uint8", lhs, rhs);
		emit_diagnostic(warning_kind_error, message.as_str(), begin, pivot, end);
		return false;
	}
	else
	{
		return true;
	}
}

@comptime_error_checking("u16_divide_check")
function u16_divide_check(lhs: uint16, rhs: uint16, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (rhs == 0u)
	{
		const message = get_divide_by_zero_error_message("uint16", lhs, rhs);
		emit_diagnostic(warning_kind_error, message.as_str(), begin, pivot, end);
		return false;
	}
	else
	{
		return true;
	}
}

@comptime_error_checking("u32_divide_check")
function u32_divide_check(lhs: uint32, rhs: uint32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (rhs == 0u)
	{
		const message = get_divide_by_zero_error_message("uint32", lhs, rhs);
		emit_diagnostic(warning_kind_error, message.as_str(), begin, pivot, end);
		return false;
	}
	else
	{
		return true;
	}
}

@comptime_error_checking("u64_divide_check")
function u64_divide_check(lhs: uint64, rhs: uint64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (rhs == 0u)
	{
		const message = get_divide_by_zero_error_message("uint64", lhs, rhs);
		emit_diagnostic(warning_kind_error, message.as_str(), begin, pivot, end);
		return false;
	}
	else
	{
		return true;
	}
}

@no_comptime_checking
function float_to_bits(x: float32) -> uint32
{
	let result = 0u32;
	__builtin_memcpy(&result, &x, sizeof float32);
	return result;
}

@no_comptime_checking
function double_to_bits(x: float64) -> uint64
{
	let result = 0u64;
	__builtin_memcpy(&result, &x, sizeof float64);
	return result;
}

@no_comptime_checking
function isnan(x: float32) -> bool
{
	const bits = float_to_bits(x);
	consteval exponent_mask = 0x7f80'0000u32;
	consteval mantissa_mask = 0x007f'ffffu32;
	return (bits & exponent_mask) == exponent_mask && (bits & mantissa_mask) != 0u;
}

@no_comptime_checking
function isnan(x: float64) -> bool
{
	const bits = double_to_bits(x);
	consteval exponent_mask = 0x7ff0'0000'0000'0000u64;
	consteval mantissa_mask = 0x000f'ffff'ffff'ffffu64;
	return (bits & exponent_mask) == exponent_mask && (bits & mantissa_mask) != 0u;
}

@comptime_error_checking("exp_f32_check")
function exp_f32_check(x: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'exp' results in nan", begin, pivot, end);
	}
	return true;
}

@comptime_error_checking("exp_f64_check")
function exp_f64_check(x: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'exp' results in nan", begin, pivot, end);
	}
	return true;
}

@comptime_error_checking("exp2_f32_check")
function exp2_f32_check(x: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'exp2' results in nan", begin, pivot, end);
	}
	return true;
}

@comptime_error_checking("exp2_f64_check")
function exp2_f64_check(x: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'exp2' results in nan", begin, pivot, end);
	}
	return true;
}

@comptime_error_checking("expm1_f32_check")
function expm1_f32_check(x: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'expm1' results in nan", begin, pivot, end);
	}
	return true;
}

@comptime_error_checking("expm1_f64_check")
function expm1_f64_check(x: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'expm1' results in nan", begin, pivot, end);
	}
	return true;
}

@comptime_error_checking("log_f32_check")
function log_f32_check(x: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'log' results in nan", begin, pivot, end);
	}
	else if (x < 0.0f32)
	{
		emit_diagnostic(warning_kind_error, "calling 'log' with a negative value", begin, pivot, end);
		return false;
	}
	return true;
}

@comptime_error_checking("log_f64_check")
function log_f64_check(x: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'log' results in nan", begin, pivot, end);
	}
	else if (x < 0.0)
	{
		emit_diagnostic(warning_kind_error, "calling 'log' with a negative value", begin, pivot, end);
		return false;
	}
	return true;
}

@comptime_error_checking("log10_f32_check")
function log10_f32_check(x: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'log10' results in nan", begin, pivot, end);
	}
	else if (x < 0.0f32)
	{
		emit_diagnostic(warning_kind_error, "calling 'log10' with a negative value", begin, pivot, end);
		return false;
	}
	return true;
}

@comptime_error_checking("log10_f64_check")
function log10_f64_check(x: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'log10' results in nan", begin, pivot, end);
	}
	else if (x < 0.0)
	{
		emit_diagnostic(warning_kind_error, "calling 'log10' with a negative value", begin, pivot, end);
		return false;
	}
	return true;
}

@comptime_error_checking("log2_f32_check")
function log2_f32_check(x: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'log2' results in nan", begin, pivot, end);
	}
	else if (x < 0.0f32)
	{
		emit_diagnostic(warning_kind_error, "calling 'log2' with a negative value", begin, pivot, end);
		return false;
	}
	return true;
}

@comptime_error_checking("log2_f64_check")
function log2_f64_check(x: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'log2' results in nan", begin, pivot, end);
	}
	else if (x < 0.0)
	{
		emit_diagnostic(warning_kind_error, "calling 'log2' with a negative value", begin, pivot, end);
		return false;
	}
	return true;
}

@comptime_error_checking("log1p_f32_check")
function log1p_f32_check(x: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'log1p' results in nan", begin, pivot, end);
	}
	else if (x < -1.0f32)
	{
		emit_diagnostic(warning_kind_error, "calling 'log1p' with a value less than -1", begin, pivot, end);
		return false;
	}
	return true;
}

@comptime_error_checking("log1p_f64_check")
function log1p_f64_check(x: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'log1p' results in nan", begin, pivot, end);
	}
	else if (x < -1.0)
	{
		emit_diagnostic(warning_kind_error, "calling 'log1p' with a value less than -1", begin, pivot, end);
		return false;
	}
	return true;
}

@comptime_error_checking("sqrt_f32_check")
function sqrt_f32_check(x: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'sqrt' results in nan", begin, pivot, end);
	}
	else if (x < 0.0f32)
	{
		emit_diagnostic(warning_kind_error, "calling 'sqrt' with a negative value", begin, pivot, end);
		return false;
	}
	return true;
}

@comptime_error_checking("sqrt_f64_check")
function sqrt_f64_check(x: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'sqrt' results in nan", begin, pivot, end);
	}
	else if (x < 0.0)
	{
		emit_diagnostic(warning_kind_error, "calling 'sqrt' with a negative value", begin, pivot, end);
		return false;
	}
	return true;
}

@comptime_error_checking("pow_f32_check")
function pow_f32_check(x: float32, y: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x) || isnan(y))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'pow' results in nan", begin, pivot, end);
	}
	return true;
}

@comptime_error_checking("pow_f64_check")
function pow_f64_check(x: float64, y: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x) || isnan(y))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'pow' results in nan", begin, pivot, end);
	}
	return true;
}

@comptime_error_checking("cbrt_f32_check")
function cbrt_f32_check(x: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'cbrt' results in nan", begin, pivot, end);
	}
	return true;
}

@comptime_error_checking("cbrt_f64_check")
function cbrt_f64_check(x: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'cbrt' results in nan", begin, pivot, end);
	}
	return true;
}

@comptime_error_checking("hypot_f32_check")
function hypot_f32_check(x: float32, y: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x) || isnan(y))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'hypot' results in nan", begin, pivot, end);
	}
	return true;
}

@comptime_error_checking("hypot_f64_check")
function hypot_f64_check(x: float64, y: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x) || isnan(y))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'hypot' results in nan", begin, pivot, end);
	}
	return true;
}

@comptime_error_checking("sin_f32_check")
function sin_f32_check(x: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'sin' results in nan", begin, pivot, end);
	}
	return true;
}

@comptime_error_checking("sin_f64_check")
function sin_f64_check(x: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'sin' results in nan", begin, pivot, end);
	}
	return true;
}

@comptime_error_checking("cos_f32_check")
function cos_f32_check(x: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'cos' results in nan", begin, pivot, end);
	}
	return true;
}

@comptime_error_checking("cos_f64_check")
function cos_f64_check(x: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'cos' results in nan", begin, pivot, end);
	}
	return true;
}

@comptime_error_checking("tan_f32_check")
function tan_f32_check(x: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'tan' results in nan", begin, pivot, end);
	}
	return true;
}

@comptime_error_checking("tan_f64_check")
function tan_f64_check(x: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'tan' results in nan", begin, pivot, end);
	}
	return true;
}

@comptime_error_checking("asin_f32_check")
function asin_f32_check(x: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'asin' results in nan", begin, pivot, end);
	}
	else if (x < -1.0f32 || x > 1.0f32)
	{
		emit_diagnostic(warning_kind_error, "calling 'asin' with a value not in the range [-1, 1]", begin, pivot, end);
		return false;
	}
	return true;
}

@comptime_error_checking("asin_f64_check")
function asin_f64_check(x: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'asin' results in nan", begin, pivot, end);
	}
	else if (x < -1.0 || x > 1.0)
	{
		emit_diagnostic(warning_kind_error, "calling 'asin' with a value not in the range [-1, 1]", begin, pivot, end);
		return false;
	}
	return true;
}

@comptime_error_checking("acos_f32_check")
function acos_f32_check(x: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'acos' results in nan", begin, pivot, end);
	}
	else if (x < -1.0f32 || x > 1.0f32)
	{
		emit_diagnostic(warning_kind_error, "calling 'acos' with a value not in the range [-1, 1]", begin, pivot, end);
		return false;
	}
	return true;
}

@comptime_error_checking("acos_f64_check")
function acos_f64_check(x: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'acos' results in nan", begin, pivot, end);
	}
	else if (x < -1.0 || x > 1.0)
	{
		emit_diagnostic(warning_kind_error, "calling 'acos' with a value not in the range [-1, 1]", begin, pivot, end);
		return false;
	}
	return true;
}

@comptime_error_checking("atan_f32_check")
function atan_f32_check(x: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'atan' results in nan", begin, pivot, end);
	}
	return true;
}

@comptime_error_checking("atan_f64_check")
function atan_f64_check(x: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'atan' results in nan", begin, pivot, end);
	}
	return true;
}

@comptime_error_checking("atan2_f32_check")
function atan2_f32_check(y: float32, x: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x) || isnan(y))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'atan2' results in nan", begin, pivot, end);
	}
	return true;
}

@comptime_error_checking("atan2_f64_check")
function atan2_f64_check(y: float64, x: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x) || isnan(y))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'atan2' results in nan", begin, pivot, end);
	}
	return true;
}

@comptime_error_checking("sinh_f32_check")
function sinh_f32_check(x: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'sinh' results in nan", begin, pivot, end);
	}
	return true;
}

@comptime_error_checking("sinh_f64_check")
function sinh_f64_check(x: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'sinh' results in nan", begin, pivot, end);
	}
	return true;
}

@comptime_error_checking("cosh_f32_check")
function cosh_f32_check(x: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'cosh' results in nan", begin, pivot, end);
	}
	return true;
}

@comptime_error_checking("cosh_f64_check")
function cosh_f64_check(x: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'cosh' results in nan", begin, pivot, end);
	}
	return true;
}

@comptime_error_checking("tanh_f32_check")
function tanh_f32_check(x: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'tanh' results in nan", begin, pivot, end);
	}
	return true;
}

@comptime_error_checking("tanh_f64_check")
function tanh_f64_check(x: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'tanh' results in nan", begin, pivot, end);
	}
	return true;
}

@comptime_error_checking("asinh_f32_check")
function asinh_f32_check(x: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'asinh' results in nan", begin, pivot, end);
	}
	return true;
}

@comptime_error_checking("asinh_f64_check")
function asinh_f64_check(x: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'asinh' results in nan", begin, pivot, end);
	}
	return true;
}

@comptime_error_checking("acosh_f32_check")
function acosh_f32_check(x: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'acosh' results in nan", begin, pivot, end);
	}
	else if (x < 1.0f32)
	{
		emit_diagnostic(warning_kind_error, "calling 'acosh' with a value less than 1", begin, pivot, end);
		return false;
	}
	return true;
}

@comptime_error_checking("acosh_f64_check")
function acosh_f64_check(x: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'acosh' results in nan", begin, pivot, end);
	}
	else if (x < 1.0)
	{
		emit_diagnostic(warning_kind_error, "calling 'acosh' with a value less than 1", begin, pivot, end);
		return false;
	}
	return true;
}

@comptime_error_checking("atanh_f32_check")
function atanh_f32_check(x: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'atanh' results in nan", begin, pivot, end);
	}
	else if (x < -1.0f32 || x > 1.0f32)
	{
		emit_diagnostic(warning_kind_error, "calling 'atanh' with a value not in the range [-1, 1]", begin, pivot, end);
		return false;
	}
	return true;
}

@comptime_error_checking("atanh_f64_check")
function atanh_f64_check(x: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'atanh' results in nan", begin, pivot, end);
	}
	else if (x < -1.0 || x > 1.0)
	{
		emit_diagnostic(warning_kind_error, "calling 'atanh' with a value not in the range [-1, 1]", begin, pivot, end);
		return false;
	}
	return true;
}

@comptime_error_checking("erf_f32_check")
function erf_f32_check(x: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'erf' results in nan", begin, pivot, end);
	}
	return true;
}

@comptime_error_checking("erf_f64_check")
function erf_f64_check(x: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'erf' results in nan", begin, pivot, end);
	}
	return true;
}

@comptime_error_checking("erfc_f32_check")
function erfc_f32_check(x: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'erfc' results in nan", begin, pivot, end);
	}
	return true;
}

@comptime_error_checking("erfc_f64_check")
function erfc_f64_check(x: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'erfc' results in nan", begin, pivot, end);
	}
	return true;
}

@comptime_error_checking("tgamma_f32_check")
function tgamma_f32_check(x: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'tgamma' results in nan", begin, pivot, end);
	}
	else if (x < 0.0f32)
	{
		emit_diagnostic(warning_kind_error, "calling 'tgamma' with a negative value", begin, pivot, end);
		return false;
	}
	return true;
}

@comptime_error_checking("tgamma_f64_check")
function tgamma_f64_check(x: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'tgamma' results in nan", begin, pivot, end);
	}
	else if (x < 0.0)
	{
		emit_diagnostic(warning_kind_error, "calling 'tgamma' with a negative value", begin, pivot, end);
		return false;
	}
	return true;
}

@comptime_error_checking("lgamma_f32_check")
function lgamma_f32_check(x: float32, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'lgamma' results in nan", begin, pivot, end);
	}
	else if (x < 0.0f32)
	{
		emit_diagnostic(warning_kind_error, "calling 'lgamma' with a negative value", begin, pivot, end);
		return false;
	}
	return true;
}

@comptime_error_checking("lgamma_f64_check")
function lgamma_f64_check(x: float64, begin: uint64, pivot: uint64, end: uint64) -> bool
{
	if (isnan(x))
	{
		emit_diagnostic(warning_kind_float_nan_math, "passing nan to 'lgamma' results in nan", begin, pivot, end);
	}
	else if (x < 0.0)
	{
		emit_diagnostic(warning_kind_error, "calling 'lgamma' with a negative value", begin, pivot, end);
		return false;
	}
	return true;
}

@no_comptime_checking
function emit_diagnostic(kind: uint32, message: str, begin: uint64, pivot: uint64, end: uint64)
{
	const call_stack_array = get_call_stack_array_copy();
	errors.push_back(error_t[ kind, src_tokens_t[ begin, pivot, end ], std::string(message), call_stack_array ]);
}


@no_comptime_checking
@__builtin("comptime_compile_error_src_tokens")
function __builtin_comptime_compile_error_src_tokens(message: str, begin: uint64, pivot: uint64, end: uint64)
{
	emit_diagnostic(warning_kind_error, message, begin, pivot, end);
}

@no_comptime_checking
@__builtin("comptime_compile_warning_src_tokens")
function __builtin_comptime_compile_warning_src_tokens(message: str, begin: uint64, pivot: uint64, end: uint64)
{
	emit_diagnostic(warning_kind_comptime_warning, message, begin, pivot, end);
}

struct vector_str
{
	._data_begin: *std::string;
	._data_end:   *std::string;
	._alloc_end:  *std::string;

	destructor(&self)
	{
		self.destruct_vector();
	}
}

@no_comptime_checking
function swap(a: &vector_str, b: &vector_str)
{
	a.swap_vector(b);
}

@no_comptime_checking
operator = (lhs: &vector_str, rhs: &const vector_str) -> &vector_str
{
	lhs.assign_vector(rhs);
	return lhs;
}

@no_comptime_checking
operator = (lhs: &vector_str, rhs: vector_str) -> &vector_str
{
	lhs.assign_vector(rhs);
	return lhs;
}

@no_runtime_emit
@comptime_error_checking("global_strings_var")
let global_strings = vector_str[ null, null, null ];

@no_comptime_checking
@__builtin("comptime_create_global_string")
consteval function __builtin_comptime_create_global_string(s: str) -> str
{
	global_strings.emplace_back(s);
	return global_strings.back().as_str();
}
