@__builtin export struct i8
{
	@__builtin export operator + (n: i8) -> i8;
	@__builtin export operator - (n: i8) -> i8;
	@__builtin export operator ++ (n: &mut i8) -> &mut i8;
	@__builtin export operator -- (n: &mut i8) -> &mut i8;

	@__builtin_assign export operator = (lhs: &mut i8, rhs: i8) -> &mut i8;
	@__builtin export operator + (lhs: i8, rhs: i8) -> i8;
	@__builtin export operator - (lhs: i8, rhs: i8) -> i8;
	@__builtin export operator * (lhs: i8, rhs: i8) -> i8;
	@__builtin export operator / (lhs: i8, rhs: i8) -> i8;
	@__builtin export operator % (lhs: i8, rhs: i8) -> i8;
	@__builtin export operator += (lhs: &mut i8, rhs: i8) -> &mut i8;
	@__builtin export operator -= (lhs: &mut i8, rhs: i8) -> &mut i8;
	@__builtin export operator *= (lhs: &mut i8, rhs: i8) -> &mut i8;
	@__builtin export operator /= (lhs: &mut i8, rhs: i8) -> &mut i8;
	@__builtin export operator %= (lhs: &mut i8, rhs: i8) -> &mut i8;

	@__builtin export operator == (lhs: i8, rhs: i8) -> bool;
	@__builtin export operator != (lhs: i8, rhs: i8) -> bool;
	@__builtin export operator <  (lhs: i8, rhs: i8) -> bool;
	@__builtin export operator <= (lhs: i8, rhs: i8) -> bool;
	@__builtin export operator >  (lhs: i8, rhs: i8) -> bool;
	@__builtin export operator >= (lhs: i8, rhs: i8) -> bool;

	export consteval min: i8 = ((0x80u8 as i8));
	export consteval max: i8 = ((0x7fu8 as i8));
}

@__builtin export struct i16
{
	@__builtin export operator + (n: i16) -> i16;
	@__builtin export operator - (n: i16) -> i16;
	@__builtin export operator ++ (n: &mut i16) -> &mut i16;
	@__builtin export operator -- (n: &mut i16) -> &mut i16;

	@__builtin_assign export operator = (lhs: &mut i16, rhs: i16) -> &mut i16;
	@__builtin export operator + (lhs: i16, rhs: i16) -> i16;
	@__builtin export operator - (lhs: i16, rhs: i16) -> i16;
	@__builtin export operator * (lhs: i16, rhs: i16) -> i16;
	@__builtin export operator / (lhs: i16, rhs: i16) -> i16;
	@__builtin export operator % (lhs: i16, rhs: i16) -> i16;
	@__builtin export operator += (lhs: &mut i16, rhs: i16) -> &mut i16;
	@__builtin export operator -= (lhs: &mut i16, rhs: i16) -> &mut i16;
	@__builtin export operator *= (lhs: &mut i16, rhs: i16) -> &mut i16;
	@__builtin export operator /= (lhs: &mut i16, rhs: i16) -> &mut i16;
	@__builtin export operator %= (lhs: &mut i16, rhs: i16) -> &mut i16;

	@__builtin export operator == (lhs: i16, rhs: i16) -> bool;
	@__builtin export operator != (lhs: i16, rhs: i16) -> bool;
	@__builtin export operator <  (lhs: i16, rhs: i16) -> bool;
	@__builtin export operator <= (lhs: i16, rhs: i16) -> bool;
	@__builtin export operator >  (lhs: i16, rhs: i16) -> bool;
	@__builtin export operator >= (lhs: i16, rhs: i16) -> bool;

	export consteval min: i16 = ((0x8000u16 as i16));
	export consteval max: i16 = ((0x7fffu16 as i16));
}

@__builtin export struct i32
{
	@__builtin export operator + (n: i32) -> i32;
	@__builtin export operator - (n: i32) -> i32;
	@__builtin export operator ++ (n: &mut i32) -> &mut i32;
	@__builtin export operator -- (n: &mut i32) -> &mut i32;

	@__builtin_assign export operator = (lhs: &mut i32, rhs: i32) -> &mut i32;
	@__builtin export operator + (lhs: i32, rhs: i32) -> i32;
	@__builtin export operator - (lhs: i32, rhs: i32) -> i32;
	@__builtin export operator * (lhs: i32, rhs: i32) -> i32;
	@__builtin export operator / (lhs: i32, rhs: i32) -> i32;
	@__builtin export operator % (lhs: i32, rhs: i32) -> i32;
	@__builtin export operator += (lhs: &mut i32, rhs: i32) -> &mut i32;
	@__builtin export operator -= (lhs: &mut i32, rhs: i32) -> &mut i32;
	@__builtin export operator *= (lhs: &mut i32, rhs: i32) -> &mut i32;
	@__builtin export operator /= (lhs: &mut i32, rhs: i32) -> &mut i32;
	@__builtin export operator %= (lhs: &mut i32, rhs: i32) -> &mut i32;

	@__builtin export operator == (lhs: i32, rhs: i32) -> bool;
	@__builtin export operator != (lhs: i32, rhs: i32) -> bool;
	@__builtin export operator <  (lhs: i32, rhs: i32) -> bool;
	@__builtin export operator <= (lhs: i32, rhs: i32) -> bool;
	@__builtin export operator >  (lhs: i32, rhs: i32) -> bool;
	@__builtin export operator >= (lhs: i32, rhs: i32) -> bool;

	export consteval min: i32 = ((0x8000'0000u32 as i32));
	export consteval max: i32 = ((0x7fff'ffffu32 as i32));
}

@__builtin export struct i64
{
	@__builtin export operator + (n: i64) -> i64;
	@__builtin export operator - (n: i64) -> i64;
	@__builtin export operator ++ (n: &mut i64) -> &mut i64;
	@__builtin export operator -- (n: &mut i64) -> &mut i64;

	@__builtin_assign export operator = (lhs: &mut i64, rhs: i64) -> &mut i64;
	@__builtin export operator + (lhs: i64, rhs: i64) -> i64;
	@__builtin export operator - (lhs: i64, rhs: i64) -> i64;
	@__builtin export operator * (lhs: i64, rhs: i64) -> i64;
	@__builtin export operator / (lhs: i64, rhs: i64) -> i64;
	@__builtin export operator % (lhs: i64, rhs: i64) -> i64;
	@__builtin export operator += (lhs: &mut i64, rhs: i64) -> &mut i64;
	@__builtin export operator -= (lhs: &mut i64, rhs: i64) -> &mut i64;
	@__builtin export operator *= (lhs: &mut i64, rhs: i64) -> &mut i64;
	@__builtin export operator /= (lhs: &mut i64, rhs: i64) -> &mut i64;
	@__builtin export operator %= (lhs: &mut i64, rhs: i64) -> &mut i64;

	@__builtin export operator == (lhs: i64, rhs: i64) -> bool;
	@__builtin export operator != (lhs: i64, rhs: i64) -> bool;
	@__builtin export operator <  (lhs: i64, rhs: i64) -> bool;
	@__builtin export operator <= (lhs: i64, rhs: i64) -> bool;
	@__builtin export operator >  (lhs: i64, rhs: i64) -> bool;
	@__builtin export operator >= (lhs: i64, rhs: i64) -> bool;

	export consteval min: i64 = ((0x8000'0000'0000'0000u64 as i64));
	export consteval max: i64 = ((0x7fff'ffff'ffff'ffffu64 as i64));
}

@__builtin export struct u8
{
	@__builtin export operator + (n: u8) -> u8;
	@__builtin export operator ~ (n: u8) -> u8;
	@__builtin export operator ++ (n: &mut u8) -> &mut u8;
	@__builtin export operator -- (n: &mut u8) -> &mut u8;

	@__builtin_assign export operator = (lhs: &mut u8, rhs: u8) -> &mut u8;
	@__builtin export operator + (lhs: u8, rhs: u8) -> u8;
	@__builtin export operator - (lhs: u8, rhs: u8) -> u8;
	@__builtin export operator * (lhs: u8, rhs: u8) -> u8;
	@__builtin export operator / (lhs: u8, rhs: u8) -> u8;
	@__builtin export operator % (lhs: u8, rhs: u8) -> u8;
	@__builtin export operator += (lhs: &mut u8, rhs: u8) -> &mut u8;
	@__builtin export operator -= (lhs: &mut u8, rhs: u8) -> &mut u8;
	@__builtin export operator *= (lhs: &mut u8, rhs: u8) -> &mut u8;
	@__builtin export operator /= (lhs: &mut u8, rhs: u8) -> &mut u8;
	@__builtin export operator %= (lhs: &mut u8, rhs: u8) -> &mut u8;

	@__builtin export operator == (lhs: u8, rhs: u8) -> bool;
	@__builtin export operator != (lhs: u8, rhs: u8) -> bool;
	@__builtin export operator <  (lhs: u8, rhs: u8) -> bool;
	@__builtin export operator <= (lhs: u8, rhs: u8) -> bool;
	@__builtin export operator >  (lhs: u8, rhs: u8) -> bool;
	@__builtin export operator >= (lhs: u8, rhs: u8) -> bool;

	@__builtin export operator & (lhs: u8, rhs: u8) -> u8;
	@__builtin export operator ^ (lhs: u8, rhs: u8) -> u8;
	@__builtin export operator | (lhs: u8, rhs: u8) -> u8;
	@__builtin @overload_priority(0) export operator << (lhs: u8, rhs: i64) -> u8;
	@__builtin @overload_priority(1) export operator << (lhs: u8, rhs: u64) -> u8;
	@__builtin @overload_priority(0) export operator >> (lhs: u8, rhs: i64) -> u8;
	@__builtin @overload_priority(1) export operator >> (lhs: u8, rhs: u64) -> u8;
	@__builtin export operator &= (lhs: &mut u8, rhs: u8) -> &mut u8;
	@__builtin export operator ^= (lhs: &mut u8, rhs: u8) -> &mut u8;
	@__builtin export operator |= (lhs: &mut u8, rhs: u8) -> &mut u8;
	@__builtin @overload_priority(0) export operator <<= (lhs: &mut u8, rhs: i64) -> &mut u8;
	@__builtin @overload_priority(1) export operator <<= (lhs: &mut u8, rhs: u64) -> &mut u8;
	@__builtin @overload_priority(0) export operator >>= (lhs: &mut u8, rhs: i64) -> &mut u8;
	@__builtin @overload_priority(1) export operator >>= (lhs: &mut u8, rhs: u64) -> &mut u8;

	export consteval min: u8 = 0u8;
	export consteval max: u8 = 0xffu8;
}

@__builtin export struct u16
{
	@__builtin export operator + (n: u16) -> u16;
	@__builtin export operator ~ (n: u16) -> u16;
	@__builtin export operator ++ (n: &mut u16) -> &mut u16;
	@__builtin export operator -- (n: &mut u16) -> &mut u16;

	@__builtin_assign export operator = (lhs: &mut u16, rhs: u16) -> &mut u16;
	@__builtin export operator + (lhs: u16, rhs: u16) -> u16;
	@__builtin export operator - (lhs: u16, rhs: u16) -> u16;
	@__builtin export operator * (lhs: u16, rhs: u16) -> u16;
	@__builtin export operator / (lhs: u16, rhs: u16) -> u16;
	@__builtin export operator % (lhs: u16, rhs: u16) -> u16;
	@__builtin export operator += (lhs: &mut u16, rhs: u16) -> &mut u16;
	@__builtin export operator -= (lhs: &mut u16, rhs: u16) -> &mut u16;
	@__builtin export operator *= (lhs: &mut u16, rhs: u16) -> &mut u16;
	@__builtin export operator /= (lhs: &mut u16, rhs: u16) -> &mut u16;
	@__builtin export operator %= (lhs: &mut u16, rhs: u16) -> &mut u16;

	@__builtin export operator == (lhs: u16, rhs: u16) -> bool;
	@__builtin export operator != (lhs: u16, rhs: u16) -> bool;
	@__builtin export operator <  (lhs: u16, rhs: u16) -> bool;
	@__builtin export operator <= (lhs: u16, rhs: u16) -> bool;
	@__builtin export operator >  (lhs: u16, rhs: u16) -> bool;
	@__builtin export operator >= (lhs: u16, rhs: u16) -> bool;

	@__builtin export operator & (lhs: u16, rhs: u16) -> u16;
	@__builtin export operator ^ (lhs: u16, rhs: u16) -> u16;
	@__builtin export operator | (lhs: u16, rhs: u16) -> u16;
	@__builtin @overload_priority(0) export operator << (lhs: u16, rhs: i64) -> u16;
	@__builtin @overload_priority(1) export operator << (lhs: u16, rhs: u64) -> u16;
	@__builtin @overload_priority(0) export operator >> (lhs: u16, rhs: i64) -> u16;
	@__builtin @overload_priority(1) export operator >> (lhs: u16, rhs: u64) -> u16;
	@__builtin export operator &= (lhs: &mut u16, rhs: u16) -> &mut u16;
	@__builtin export operator ^= (lhs: &mut u16, rhs: u16) -> &mut u16;
	@__builtin export operator |= (lhs: &mut u16, rhs: u16) -> &mut u16;
	@__builtin @overload_priority(0) export operator <<= (lhs: &mut u16, rhs: i64) -> &mut u16;
	@__builtin @overload_priority(1) export operator <<= (lhs: &mut u16, rhs: u64) -> &mut u16;
	@__builtin @overload_priority(0) export operator >>= (lhs: &mut u16, rhs: i64) -> &mut u16;
	@__builtin @overload_priority(1) export operator >>= (lhs: &mut u16, rhs: u64) -> &mut u16;

	export consteval min: u16 = 0u16;
	export consteval max: u16 = 0xffffu16;
}

@__builtin export struct u32
{
	@__builtin export operator + (n: u32) -> u32;
	@__builtin export operator ~ (n: u32) -> u32;
	@__builtin export operator ++ (n: &mut u32) -> &mut u32;
	@__builtin export operator -- (n: &mut u32) -> &mut u32;

	@__builtin_assign export operator = (lhs: &mut u32, rhs: u32) -> &mut u32;
	@__builtin export operator + (lhs: u32, rhs: u32) -> u32;
	@__builtin export operator - (lhs: u32, rhs: u32) -> u32;
	@__builtin export operator * (lhs: u32, rhs: u32) -> u32;
	@__builtin export operator / (lhs: u32, rhs: u32) -> u32;
	@__builtin export operator % (lhs: u32, rhs: u32) -> u32;
	@__builtin export operator += (lhs: &mut u32, rhs: u32) -> &mut u32;
	@__builtin export operator -= (lhs: &mut u32, rhs: u32) -> &mut u32;
	@__builtin export operator *= (lhs: &mut u32, rhs: u32) -> &mut u32;
	@__builtin export operator /= (lhs: &mut u32, rhs: u32) -> &mut u32;
	@__builtin export operator %= (lhs: &mut u32, rhs: u32) -> &mut u32;

	@__builtin export operator == (lhs: u32, rhs: u32) -> bool;
	@__builtin export operator != (lhs: u32, rhs: u32) -> bool;
	@__builtin export operator <  (lhs: u32, rhs: u32) -> bool;
	@__builtin export operator <= (lhs: u32, rhs: u32) -> bool;
	@__builtin export operator >  (lhs: u32, rhs: u32) -> bool;
	@__builtin export operator >= (lhs: u32, rhs: u32) -> bool;

	@__builtin export operator & (lhs: u32, rhs: u32) -> u32;
	@__builtin export operator ^ (lhs: u32, rhs: u32) -> u32;
	@__builtin export operator | (lhs: u32, rhs: u32) -> u32;
	@__builtin @overload_priority(0) export operator << (lhs: u32, rhs: i64) -> u32;
	@__builtin @overload_priority(1) export operator << (lhs: u32, rhs: u64) -> u32;
	@__builtin @overload_priority(0) export operator >> (lhs: u32, rhs: i64) -> u32;
	@__builtin @overload_priority(1) export operator >> (lhs: u32, rhs: u64) -> u32;
	@__builtin export operator &= (lhs: &mut u32, rhs: u32) -> &mut u32;
	@__builtin export operator ^= (lhs: &mut u32, rhs: u32) -> &mut u32;
	@__builtin export operator |= (lhs: &mut u32, rhs: u32) -> &mut u32;
	@__builtin @overload_priority(0) export operator <<= (lhs: &mut u32, rhs: i64) -> &mut u32;
	@__builtin @overload_priority(1) export operator <<= (lhs: &mut u32, rhs: u64) -> &mut u32;
	@__builtin @overload_priority(0) export operator >>= (lhs: &mut u32, rhs: i64) -> &mut u32;
	@__builtin @overload_priority(1) export operator >>= (lhs: &mut u32, rhs: u64) -> &mut u32;

	export consteval min: u32 = 0u32;
	export consteval max: u32 = 0xffff'ffffu32;
}

@__builtin export struct u64
{
	@__builtin export operator + (n: u64) -> u64;
	@__builtin export operator ~ (n: u64) -> u64;
	@__builtin export operator ++ (n: &mut u64) -> &mut u64;
	@__builtin export operator -- (n: &mut u64) -> &mut u64;

	@__builtin_assign export operator = (lhs: &mut u64, rhs: u64) -> &mut u64;
	@__builtin export operator + (lhs: u64, rhs: u64) -> u64;
	@__builtin export operator - (lhs: u64, rhs: u64) -> u64;
	@__builtin export operator * (lhs: u64, rhs: u64) -> u64;
	@__builtin export operator / (lhs: u64, rhs: u64) -> u64;
	@__builtin export operator % (lhs: u64, rhs: u64) -> u64;
	@__builtin export operator += (lhs: &mut u64, rhs: u64) -> &mut u64;
	@__builtin export operator -= (lhs: &mut u64, rhs: u64) -> &mut u64;
	@__builtin export operator *= (lhs: &mut u64, rhs: u64) -> &mut u64;
	@__builtin export operator /= (lhs: &mut u64, rhs: u64) -> &mut u64;
	@__builtin export operator %= (lhs: &mut u64, rhs: u64) -> &mut u64;

	@__builtin export operator == (lhs: u64, rhs: u64) -> bool;
	@__builtin export operator != (lhs: u64, rhs: u64) -> bool;
	@__builtin export operator <  (lhs: u64, rhs: u64) -> bool;
	@__builtin export operator <= (lhs: u64, rhs: u64) -> bool;
	@__builtin export operator >  (lhs: u64, rhs: u64) -> bool;
	@__builtin export operator >= (lhs: u64, rhs: u64) -> bool;

	@__builtin export operator & (lhs: u64, rhs: u64) -> u64;
	@__builtin export operator ^ (lhs: u64, rhs: u64) -> u64;
	@__builtin export operator | (lhs: u64, rhs: u64) -> u64;
	@__builtin @overload_priority(0) export operator << (lhs: u64, rhs: i64) -> u64;
	@__builtin @overload_priority(1) export operator << (lhs: u64, rhs: u64) -> u64;
	@__builtin @overload_priority(0) export operator >> (lhs: u64, rhs: i64) -> u64;
	@__builtin @overload_priority(1) export operator >> (lhs: u64, rhs: u64) -> u64;
	@__builtin export operator &= (lhs: &mut u64, rhs: u64) -> &mut u64;
	@__builtin export operator ^= (lhs: &mut u64, rhs: u64) -> &mut u64;
	@__builtin export operator |= (lhs: &mut u64, rhs: u64) -> &mut u64;
	@__builtin @overload_priority(0) export operator <<= (lhs: &mut u64, rhs: i64) -> &mut u64;
	@__builtin @overload_priority(1) export operator <<= (lhs: &mut u64, rhs: u64) -> &mut u64;
	@__builtin @overload_priority(0) export operator >>= (lhs: &mut u64, rhs: i64) -> &mut u64;
	@__builtin @overload_priority(1) export operator >>= (lhs: &mut u64, rhs: u64) -> &mut u64;

	export consteval min: u64 = 0u64;
	export consteval max: u64 = 0xffff'ffff'ffff'ffffu64;
}

@__builtin export struct float32
{
	@__builtin export operator + (x: float32) -> float32;
	@__builtin export operator - (x: float32) -> float32;

	@__builtin_assign export operator = (lhs: &mut float32, rhs: float32) -> &mut float32;
	@__builtin export operator + (lhs: float32, rhs: float32) -> float32;
	@__builtin export operator += (lhs: &mut float32, rhs: float32) -> &mut float32;
	@__builtin export operator - (lhs: float32, rhs: float32) -> float32;
	@__builtin export operator -= (lhs: &mut float32, rhs: float32) -> &mut float32;
	@__builtin export operator * (lhs: float32, rhs: float32) -> float32;
	@__builtin export operator *= (lhs: &mut float32, rhs: float32) -> &mut float32;
	@__builtin export operator / (lhs: float32, rhs: float32) -> float32;
	@__builtin export operator /= (lhs: &mut float32, rhs: float32) -> &mut float32;
	@__builtin export operator == (lhs: float32, rhs: float32) -> bool;
	@__builtin export operator != (lhs: float32, rhs: float32) -> bool;
	@__builtin export operator < (lhs: float32, rhs: float32) -> bool;
	@__builtin export operator <= (lhs: float32, rhs: float32) -> bool;
	@__builtin export operator > (lhs: float32, rhs: float32) -> bool;
	@__builtin export operator >= (lhs: float32, rhs: float32) -> bool;

	export consteval min: float32 = 1.1754944e-38f32;
	export consteval denorm_min: float32 = 1e-45f32;
	export consteval epsilon: float32 = 1.1920929e-07f32;
	export consteval max: float32 = 3.4028235e+38f32;

	export consteval inf: float32 = ((1.0f32 / 0.0f32));
	export consteval nan: float32 = ((__builtin_abs_f32(((0.0f32 / 0.0f32)))));
}

@__builtin export struct float64
{
	@__builtin export operator + (x: float64) -> float64;
	@__builtin export operator - (x: float64) -> float64;

	@__builtin_assign export operator = (lhs: &mut float64, rhs: float64) -> &mut float64;
	@__builtin export operator + (lhs: float64, rhs: float64) -> float64;
	@__builtin export operator += (lhs: &mut float64, rhs: float64) -> &mut float64;
	@__builtin export operator - (lhs: float64, rhs: float64) -> float64;
	@__builtin export operator -= (lhs: &mut float64, rhs: float64) -> &mut float64;
	@__builtin export operator * (lhs: float64, rhs: float64) -> float64;
	@__builtin export operator *= (lhs: &mut float64, rhs: float64) -> &mut float64;
	@__builtin export operator / (lhs: float64, rhs: float64) -> float64;
	@__builtin export operator /= (lhs: &mut float64, rhs: float64) -> &mut float64;
	@__builtin export operator == (lhs: float64, rhs: float64) -> bool;
	@__builtin export operator != (lhs: float64, rhs: float64) -> bool;
	@__builtin export operator < (lhs: float64, rhs: float64) -> bool;
	@__builtin export operator <= (lhs: float64, rhs: float64) -> bool;
	@__builtin export operator > (lhs: float64, rhs: float64) -> bool;
	@__builtin export operator >= (lhs: float64, rhs: float64) -> bool;

	export consteval min: float64 = 2.2250738585072014e-308f64;
	export consteval denorm_min: float64 = 5e-324f64;
	export consteval epsilon: float64 = 2.220446049250313e-16f64;
	export consteval max: float64 = 1.7976931348623157e+308f64;

	export consteval inf: float64 = ((1.0f64 / 0.0f64));
	export consteval nan: float64 = ((__builtin_abs_f64(((0.0f64 / 0.0f64)))));
}

@__builtin export struct char
{
	@__builtin export operator ++ (c: &mut char) -> &mut char;
	@__builtin export operator -- (c: &mut char) -> &mut char;

	@__builtin_assign export operator = (lhs: &mut char, rhs: char) -> &mut char;

	@__builtin @overload_priority(1) export operator + (lhs: char, rhs: i64) -> char;
	@__builtin @overload_priority(0) export operator + (lhs: char, rhs: u64) -> char;
	@__builtin @overload_priority(1) export operator + (lhs: i64, rhs: char) -> char;
	@__builtin @overload_priority(0) export operator + (lhs: u64, rhs: char) -> char;
	@__builtin @overload_priority(1) export operator - (lhs: char, rhs: i64) -> char;
	@__builtin @overload_priority(0) export operator - (lhs: char, rhs: u64) -> char;
	@__builtin export operator - (lhs: char, rhs: char) -> i32;
	@__builtin @overload_priority(1) export operator += (lhs: &mut char, rhs: i64) -> &mut char;
	@__builtin @overload_priority(0) export operator += (lhs: &mut char, rhs: u64) -> &mut char;
	@__builtin @overload_priority(1) export operator -= (lhs: &mut char, rhs: i64) -> &mut char;
	@__builtin @overload_priority(0) export operator -= (lhs: &mut char, rhs: u64) -> &mut char;

	@__builtin export operator == (lhs: char, rhs: char) -> bool;
	@__builtin export operator != (lhs: char, rhs: char) -> bool;
	@__builtin export operator <  (lhs: char, rhs: char) -> bool;
	@__builtin export operator <= (lhs: char, rhs: char) -> bool;
	@__builtin export operator >  (lhs: char, rhs: char) -> bool;
	@__builtin export operator >= (lhs: char, rhs: char) -> bool;
}

@__builtin export struct str
{
	._begin: ?*u8;
	._end: ?*u8;

	export function size = __builtin_str_size;
	export function length = __builtin_str_length;

	export function starts_with = __builtin_str_starts_with;
	export function ends_with = __builtin_str_ends_with;

	export function begin_ptr = __builtin_str_begin_ptr;
	export function end_ptr = __builtin_str_end_ptr;

	@__builtin export operator == (lhs: str, rhs: str) -> bool
	{
		if (__builtin_str_size(lhs) != __builtin_str_size(rhs))
		{
			return false;
		}

		mut lhs_it = lhs._begin;
		mut rhs_it = rhs._begin;
		let lhs_end = lhs._end;
		if (lhs_it == rhs_it)
		{
			return true;
		}

		for (; lhs_it != lhs_end; ++lhs_it, ++rhs_it)
		{
			if (*lhs_it != *rhs_it)
			{
				return false;
			}
		}
		return true;
	}

	@__builtin export operator != (lhs: str, rhs: str) -> bool
	{
		if (__builtin_str_size(lhs) != __builtin_str_size(rhs))
		{
			return true;
		}

		mut lhs_it = lhs._begin;
		mut rhs_it = rhs._begin;
		let lhs_end = lhs._end;
		if (lhs_it == rhs_it)
		{
			return false;
		}

		for (; lhs_it != lhs_end; ++lhs_it, ++rhs_it)
		{
			if (*lhs_it != *rhs_it)
			{
				return true;
			}
		}
		return false;
	}
}

@__builtin export struct bool
{
	@__builtin export operator ~ (n: bool) -> bool;
	@__builtin export operator ! (n: bool) -> bool;

	@__builtin_assign export operator = (lhs: &mut bool, rhs: bool) -> &mut bool;

	@__builtin export operator == (lhs: bool, rhs: bool) -> bool;
	@__builtin export operator != (lhs: bool, rhs: bool) -> bool;

	@__builtin export operator & (lhs: bool, rhs: bool) -> bool;
	@__builtin export operator ^ (lhs: bool, rhs: bool) -> bool;
	@__builtin export operator | (lhs: bool, rhs: bool) -> bool;
	@__builtin export operator &= (lhs: &mut bool, rhs: bool) -> &mut bool;
	@__builtin export operator ^= (lhs: &mut bool, rhs: bool) -> &mut bool;
	@__builtin export operator |= (lhs: &mut bool, rhs: bool) -> &mut bool;
}

@__builtin export struct __null_t {}

@__builtin export type isize = 0;
@__builtin export type usize = 0;

struct __integer_range<T: typename>
{
	._begin: T;
	._end: T;

	type __value_type = T;
	type __iterator = __integer_range_iterator<T>;

	export function begin_value = __builtin_integer_range_begin_value;
	export function end_value   = __builtin_integer_range_end_value;

	export function begin = __builtin_integer_range_begin_iterator;
	export function end   = __builtin_integer_range_end_iterator;
}

struct __integer_range_iterator<T: typename>
{
	._value: T;

	type __value_type = T;

	export operator * = __builtin_integer_range_iterator_dereference;

	export operator == = __builtin_integer_range_iterator_equals;
	export operator != = __builtin_integer_range_iterator_not_equals;

	export operator ++ = __builtin_integer_range_iterator_plus_plus;
	export operator -- = __builtin_integer_range_iterator_minus_minus;
}

struct __integer_range_inclusive<T: typename>
{
	._begin: T;
	._end: T;

	type __value_type = T;
	type __begin_iterator = __integer_range_inclusive_iterator<T>;
	type __end_iterator = __integer_range_inclusive_end_iterator;

	export function begin_value = __builtin_integer_range_inclusive_begin_value;
	export function end_value   = __builtin_integer_range_inclusive_end_value;

	export function begin = __builtin_integer_range_inclusive_begin_iterator;
	export function end   = __builtin_integer_range_inclusive_end_iterator;
}

struct __integer_range_inclusive_iterator<T: typename>
{
	._value: T;
	._end: T;
	._at_end: bool;

	type __value_type = T;

	export operator * = __builtin_integer_range_inclusive_iterator_dereference;

	export operator == = __builtin_integer_range_inclusive_iterator_left_equals;
	export operator == = __builtin_integer_range_inclusive_iterator_right_equals;
	export operator != = __builtin_integer_range_inclusive_iterator_left_not_equals;
	export operator != = __builtin_integer_range_inclusive_iterator_right_not_equals;

	export operator ++ = __builtin_integer_range_inclusive_iterator_plus_plus;
}

struct __integer_range_inclusive_end_iterator
{}

struct __integer_range_from<T: typename>
{
	._begin: T;

	type __value_type = T;
	type __begin_iterator = __integer_range_from_iterator<T>;
	type __end_iterator = __integer_range_from_end_iterator;

	export function begin_value = __builtin_integer_range_from_begin_value;

	export function begin = __builtin_integer_range_from_begin_iterator;
	export function end   = __builtin_integer_range_from_end_iterator;
}

struct __integer_range_from_iterator<T: typename>
{
	._value: T;

	type __value_type = T;

	export operator * = __builtin_integer_range_from_iterator_dereference;

	export operator == = __builtin_integer_range_from_iterator_left_equals;
	export operator == = __builtin_integer_range_from_iterator_right_equals;
	export operator != = __builtin_integer_range_from_iterator_left_not_equals;
	export operator != = __builtin_integer_range_from_iterator_right_not_equals;

	export operator ++ = __builtin_integer_range_from_iterator_plus_plus;
}

struct __integer_range_from_end_iterator
{}

struct __integer_range_to<T: typename>
{
	._end: T;

	type __value_type = T;

	export function end_value = __builtin_integer_range_to_end_value;
}

struct __integer_range_to_inclusive<T: typename>
{
	._end: T;

	type __value_type = T;

	export function end_value = __builtin_integer_range_to_inclusive_end_value;
}

struct __range_unbounded
{}

@__builtin
export function __builtin_str_length(s: str) -> usize
{
	mut continuation_byte_count = 0uz;
	let begin = s._begin;
	let end   = s._end;
	for (mut it = begin; it != end; ++it)
	{
		let c = *it;
		if ((c & 0b1100'0000u8) == 0b1000'0000u8)
		{
			continuation_byte_count += 1;
		}
	}
	let size = __builtin_str_size(s);
	return size - continuation_byte_count;
}

@__builtin
export function __builtin_str_starts_with(s: str, prefix: str) -> bool
{
	if (__builtin_str_size(s) < __builtin_str_size(prefix))
	{
		return false;
	}

	mut s_it = s._begin;
	mut prefix_it = prefix._begin;
	let prefix_end = prefix._end;
	for (; prefix_it != prefix_end; ++s_it, ++prefix_it)
	{
		if (*s_it != *prefix_it)
		{
			return false;
		}
	}
	return true;
}

@__builtin
export function __builtin_str_ends_with(s: str, postfix: str) -> bool
{
	if (__builtin_str_size(s) < __builtin_str_size(postfix))
	{
		return false;
	}

	mut s_it = s._end - __builtin_str_size(postfix);
	mut postfix_it = postfix._begin;
	let postfix_end = postfix._end;
	for (; postfix_it != postfix_end; ++s_it, ++postfix_it)
	{
		if (*s_it != *postfix_it)
		{
			return false;
		}
	}
	return true;
}

@__builtin export function __builtin_str_begin_ptr(s: str) -> ?*u8;
@__builtin export function __builtin_str_end_ptr(s: str) -> ?*u8;
@__builtin
export function __builtin_str_size(s: str) -> usize
{
	return (s._end - s._begin) as usize;
}
@__builtin export function __builtin_str_from_ptrs(begin: ?*u8, end: ?*u8) -> str;

@__builtin export function __builtin_slice_begin_ptr(slice: [: auto]) -> ?*__builtin_slice_value_type(typeof slice);
@__builtin export function __builtin_slice_begin_mut_ptr(slice: [: mut auto]) -> ?*__builtin_slice_value_type(typeof slice);
@__builtin export function __builtin_slice_end_ptr(slice: [: auto]) -> ?*__builtin_slice_value_type(typeof slice);
@__builtin export function __builtin_slice_end_mut_ptr(slice: [: mut auto]) -> ?*__builtin_slice_value_type(typeof slice);
@__builtin
export function __builtin_slice_size(slice: [: auto]) -> usize
{
	return (__builtin_slice_end_ptr(slice) - __builtin_slice_begin_ptr(slice)) as usize;
}
@__builtin export function __builtin_slice_from_ptrs(begin: ?*auto, end: ?*auto)
	-> (if consteval (typeof begin != typeof end) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"mismatched pointer types '",
			__builtin_typename_as_str(__builtin_remove_optional(typeof begin)),
			"' and '",
			__builtin_typename_as_str(__builtin_remove_optional(typeof end)),
			"' in 'function __builtin_slice_from_ptrs'"
		)));
	} else {}, [: __builtin_remove_pointer(__builtin_remove_optional(typeof begin))]);
@__builtin export function __builtin_slice_from_mut_ptrs(begin: ?*mut auto, end: ?*mut auto)
	-> (if consteval (typeof begin != typeof end) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"mismatched pointer types '",
			__builtin_typename_as_str(__builtin_remove_optional(typeof begin)),
			"' and '",
			__builtin_typename_as_str(__builtin_remove_optional(typeof end)),
			"' in 'function __builtin_slice_from_mut_ptrs'"
		)));
	} else {}, [: __builtin_remove_pointer(__builtin_remove_optional(typeof begin))]);

@__builtin export function __builtin_array_begin_ptr(array: &[??: auto])
	-> *__builtin_array_value_type(__builtin_remove_reference(typeof array));
@__builtin export function __builtin_array_begin_mut_ptr(array: &mut [??: auto])
	-> *mut __builtin_array_value_type(__builtin_remove_mut(__builtin_remove_reference(typeof array)));
@__builtin export function __builtin_array_end_ptr(array: &[??: auto])
	-> *__builtin_array_value_type(__builtin_remove_reference(typeof array));
@__builtin export function __builtin_array_end_mut_ptr(array: &mut [??: auto])
	-> *mut __builtin_array_value_type(__builtin_remove_mut(__builtin_remove_reference(typeof array)));
@__builtin export function __builtin_array_size(array: &[??: auto]) -> usize;

@__builtin export function __builtin_integer_range_i8 (begin: i8,  end: i8)  -> __integer_range<i8>;
@__builtin export function __builtin_integer_range_i16(begin: i16, end: i16) -> __integer_range<i16>;
@__builtin export function __builtin_integer_range_i32(begin: i32, end: i32) -> __integer_range<i32>;
@__builtin export function __builtin_integer_range_i64(begin: i64, end: i64) -> __integer_range<i64>;

@__builtin export function __builtin_integer_range_u8 (begin: u8,  end: u8)  -> __integer_range<u8>;
@__builtin export function __builtin_integer_range_u16(begin: u16, end: u16) -> __integer_range<u16>;
@__builtin export function __builtin_integer_range_u32(begin: u32, end: u32) -> __integer_range<u32>;
@__builtin export function __builtin_integer_range_u64(begin: u64, end: u64) -> __integer_range<u64>;

@__builtin export function __builtin_integer_range_inclusive_i8 (begin: i8,  end: i8)  -> __integer_range_inclusive<i8>;
@__builtin export function __builtin_integer_range_inclusive_i16(begin: i16, end: i16) -> __integer_range_inclusive<i16>;
@__builtin export function __builtin_integer_range_inclusive_i32(begin: i32, end: i32) -> __integer_range_inclusive<i32>;
@__builtin export function __builtin_integer_range_inclusive_i64(begin: i64, end: i64) -> __integer_range_inclusive<i64>;

@__builtin export function __builtin_integer_range_inclusive_u8 (begin: u8,  end: u8)  -> __integer_range_inclusive<u8>;
@__builtin export function __builtin_integer_range_inclusive_u16(begin: u16, end: u16) -> __integer_range_inclusive<u16>;
@__builtin export function __builtin_integer_range_inclusive_u32(begin: u32, end: u32) -> __integer_range_inclusive<u32>;
@__builtin export function __builtin_integer_range_inclusive_u64(begin: u64, end: u64) -> __integer_range_inclusive<u64>;

@__builtin export function __builtin_integer_range_from_i8 (begin: i8)  -> __integer_range_from<i8>;
@__builtin export function __builtin_integer_range_from_i16(begin: i16) -> __integer_range_from<i16>;
@__builtin export function __builtin_integer_range_from_i32(begin: i32) -> __integer_range_from<i32>;
@__builtin export function __builtin_integer_range_from_i64(begin: i64) -> __integer_range_from<i64>;

@__builtin export function __builtin_integer_range_from_u8 (begin: u8)  -> __integer_range_from<u8>;
@__builtin export function __builtin_integer_range_from_u16(begin: u16) -> __integer_range_from<u16>;
@__builtin export function __builtin_integer_range_from_u32(begin: u32) -> __integer_range_from<u32>;
@__builtin export function __builtin_integer_range_from_u64(begin: u64) -> __integer_range_from<u64>;

@__builtin export function __builtin_integer_range_to_i8 (end: i8)  -> __integer_range_to<i8>;
@__builtin export function __builtin_integer_range_to_i16(end: i16) -> __integer_range_to<i16>;
@__builtin export function __builtin_integer_range_to_i32(end: i32) -> __integer_range_to<i32>;
@__builtin export function __builtin_integer_range_to_i64(end: i64) -> __integer_range_to<i64>;

@__builtin export function __builtin_integer_range_to_u8 (end: u8)  -> __integer_range_to<u8>;
@__builtin export function __builtin_integer_range_to_u16(end: u16) -> __integer_range_to<u16>;
@__builtin export function __builtin_integer_range_to_u32(end: u32) -> __integer_range_to<u32>;
@__builtin export function __builtin_integer_range_to_u64(end: u64) -> __integer_range_to<u64>;

@__builtin export function __builtin_integer_range_to_inclusive_i8 (end: i8)  -> __integer_range_to_inclusive<i8>;
@__builtin export function __builtin_integer_range_to_inclusive_i16(end: i16) -> __integer_range_to_inclusive<i16>;
@__builtin export function __builtin_integer_range_to_inclusive_i32(end: i32) -> __integer_range_to_inclusive<i32>;
@__builtin export function __builtin_integer_range_to_inclusive_i64(end: i64) -> __integer_range_to_inclusive<i64>;

@__builtin export function __builtin_integer_range_to_inclusive_u8 (end: u8)  -> __integer_range_to_inclusive<u8>;
@__builtin export function __builtin_integer_range_to_inclusive_u16(end: u16) -> __integer_range_to_inclusive<u16>;
@__builtin export function __builtin_integer_range_to_inclusive_u32(end: u32) -> __integer_range_to_inclusive<u32>;
@__builtin export function __builtin_integer_range_to_inclusive_u64(end: u64) -> __integer_range_to_inclusive<u64>;

@__builtin export function __builtin_range_unbounded() -> __range_unbounded;

@__builtin export function __builtin_integer_range_begin_value(range: __integer_range) -> (typeof range).__value_type;
@__builtin export function __builtin_integer_range_end_value(range: __integer_range) -> (typeof range).__value_type;
@__builtin export function __builtin_integer_range_inclusive_begin_value(range: __integer_range_inclusive) -> (typeof range).__value_type;
@__builtin export function __builtin_integer_range_inclusive_end_value(range: __integer_range_inclusive) -> (typeof range).__value_type;
@__builtin export function __builtin_integer_range_from_begin_value(range: __integer_range_from) -> (typeof range).__value_type;
@__builtin export function __builtin_integer_range_to_end_value(range: __integer_range_to) -> (typeof range).__value_type;
@__builtin export function __builtin_integer_range_to_inclusive_end_value(range: __integer_range_to_inclusive) -> (typeof range).__value_type;

@__builtin export function __builtin_integer_range_begin_iterator(range: __integer_range) -> (typeof range).__iterator;
@__builtin export function __builtin_integer_range_end_iterator(range: __integer_range) -> (typeof range).__iterator;
@__builtin function __builtin_integer_range_iterator_dereference(it: __integer_range_iterator) -> (typeof it).__value_type;
@__builtin function __builtin_integer_range_iterator_equals(lhs: __integer_range_iterator, rhs: __integer_range_iterator)
	-> (if consteval (typeof lhs != typeof rhs) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"mismatched iterator types '",
			__builtin_typename_as_str(typeof lhs),
			"' and '"
			__builtin_typename_as_str(typeof rhs),
			"' in 'function __builtin_integer_range_iterator_equals'"
		)));
	} else {}, bool);
@__builtin function __builtin_integer_range_iterator_not_equals(lhs: __integer_range_iterator, rhs: __integer_range_iterator)
	-> (if consteval (typeof lhs != typeof rhs) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"mismatched iterator types '",
			__builtin_typename_as_str(typeof lhs),
			"' and '",
			__builtin_typename_as_str(typeof rhs),
			"' in 'function __builtin_integer_range_iterator_not_equals'"
		)));
	} else {}, bool);
@__builtin function __builtin_integer_range_iterator_plus_plus(it: &mut __integer_range_iterator) -> typeof it;
@__builtin function __builtin_integer_range_iterator_minus_minus(it: &mut __integer_range_iterator) -> typeof it;

@__builtin export function __builtin_integer_range_inclusive_begin_iterator(range: __integer_range_inclusive) -> (typeof range).__begin_iterator;
@__builtin export function __builtin_integer_range_inclusive_end_iterator(range: __integer_range_inclusive) -> (typeof range).__end_iterator;
@__builtin function __builtin_integer_range_inclusive_iterator_dereference(it: #__integer_range_inclusive_iterator) -> (typeof it).__value_type;
@__builtin function __builtin_integer_range_inclusive_iterator_left_equals(lhs: #__integer_range_inclusive_iterator, rhs: __integer_range_inclusive_end_iterator) -> bool;
@__builtin function __builtin_integer_range_inclusive_iterator_right_equals(lhs: __integer_range_inclusive_end_iterator, rhs: #__integer_range_inclusive_iterator) -> bool;
@__builtin function __builtin_integer_range_inclusive_iterator_left_not_equals(lhs: #__integer_range_inclusive_iterator, rhs: __integer_range_inclusive_end_iterator) -> bool;
@__builtin function __builtin_integer_range_inclusive_iterator_right_not_equals(lhs: __integer_range_inclusive_end_iterator, rhs: #__integer_range_inclusive_iterator) -> bool;
@__builtin function __builtin_integer_range_inclusive_iterator_plus_plus(it: &mut __integer_range_inclusive_iterator) -> typeof it;

@__builtin function __builtin_integer_range_from_begin_iterator(range: __integer_range_from) -> (typeof range).__begin_iterator;
@__builtin function __builtin_integer_range_from_end_iterator(range: __integer_range_from) -> (typeof range).__end_iterator;
@__builtin function __builtin_integer_range_from_iterator_dereference(it: __integer_range_from_iterator) -> (typeof it).__value_type;
@__builtin function __builtin_integer_range_from_iterator_left_equals(lhs: __integer_range_from_iterator, rhs: __integer_range_from_end_iterator) -> bool;
@__builtin function __builtin_integer_range_from_iterator_right_equals(lhs: __integer_range_from_end_iterator, rhs: __integer_range_from_iterator) -> bool;
@__builtin function __builtin_integer_range_from_iterator_left_not_equals(lhs: __integer_range_from_iterator, rhs: __integer_range_from_end_iterator) -> bool;
@__builtin function __builtin_integer_range_from_iterator_right_not_equals(lhs: __integer_range_from_end_iterator, rhs: __integer_range_from_iterator) -> bool;
@__builtin function __builtin_integer_range_from_iterator_plus_plus(it: &mut __integer_range_from_iterator) -> typeof it;

@__builtin export function __builtin_optional_get_value_ref(value: &?auto)
	-> &__builtin_remove_optional(__builtin_remove_reference(typeof value));
@__builtin export function __builtin_optional_get_mut_value_ref(value: &mut ?auto)
	-> &mut __builtin_remove_optional(__builtin_remove_mut(__builtin_remove_reference(typeof value)));
@__builtin export function __builtin_optional_get_value(value: ?##auto)
	-> __builtin_remove_optional(typeof value);

@__builtin export function __builtin_pointer_cast(T: *typename, ptr: *void) -> T;
@__builtin export function __builtin_pointer_to_int(ptr: ?*void) -> usize;
@__builtin export function __builtin_int_to_pointer(T: *typename, n: usize) -> T;
@__builtin export function __builtin_enum_value(v: auto)
	-> (if consteval (!__builtin_is_enum(typeof v)) {
		((consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"invalid type '",
			__builtin_typename_as_str(typeof v),
			"' in 'function __builtin_enum_value'"
		))), i32)
	} else {
		__builtin_enum_underlying_type(typeof v)
	});

@__builtin export function __builtin_destruct_value(value: &mut auto);
@__builtin export function __builtin_inplace_construct(ptr: *mut auto, val: auto)
	-> (if consteval (__builtin_remove_mut(__builtin_remove_pointer(typeof ptr)) != typeof val) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"value of type '",
			__builtin_typename_as_str(typeof val),
			"' doesn't match the pointer type '",
			__builtin_typename_as_str(typeof ptr),
			"' in 'function __builtin_inplace_construct'"
		)));
	} else {}, void);
@__builtin export function __builtin_swap(lhs: &mut auto, rhs: &mut auto)
	-> (if consteval (typeof lhs != typeof rhs) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"different types '",
			__builtin_typename_as_str(typeof lhs),
			"' and '",
			__builtin_typename_as_str(typeof rhs),
			"' in 'function __builtin_swap'"
		)));
	} else {}, void);

@__builtin export function __builtin_is_comptime() -> bool;
@__builtin export consteval function __builtin_is_option_set(option: str) -> bool;

@__builtin export function __builtin_panic(message: str);

@__builtin export consteval function __builtin_comptime_malloc(T: typename, count: usize) -> *mut T;
@__builtin export consteval function __builtin_comptime_free(ptr: ?*mut void);

@__builtin export consteval function __builtin_comptime_print(s: str);

@__builtin export consteval function __builtin_comptime_compile_error(message: str);
@__builtin export consteval function __builtin_comptime_compile_warning(message: str);

@__builtin consteval function __builtin_comptime_add_global_array_data(begin: *auto, end: *auto)
	-> (if consteval (typeof begin != typeof end) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"mismatched pointer types '",
			__builtin_typename_as_str(typeof begin),
			"' and '",
			__builtin_typename_as_str(typeof end),
			"' in '__builtin_comptime_add_global_data'"
		)));
	} else {}, typeof begin);
@__builtin export consteval function __builtin_comptime_create_global_string(s: str) -> str
{
	if (__builtin_str_size(s) == 0)
	{
		return "";
	}
	else
	{
		let global_begin = __builtin_comptime_add_global_array_data(
			__builtin_optional_get_value(s._begin),
			__builtin_optional_get_value(s._end),
		);
		return __builtin_str_from_ptrs(global_begin, global_begin + __builtin_str_size(s));
	}
}

@__builtin consteval function __builtin_comptime_concatenate_strs(s: ...consteval str) -> str;

@__builtin export consteval function __builtin_typename_as_str(T: typename) -> str;

@__builtin export consteval function __builtin_is_mut(T: typename) -> bool;
@__builtin export consteval function __builtin_is_consteval(T: typename) -> bool;
@__builtin export consteval function __builtin_is_pointer(T: typename) -> bool;
@__builtin export consteval function __builtin_is_optional(T: typename) -> bool;
@__builtin export consteval function __builtin_is_reference(T: typename) -> bool;
@__builtin export consteval function __builtin_is_move_reference(T: typename) -> bool;
@__builtin export consteval function __builtin_is_slice(T: typename) -> bool;
@__builtin export consteval function __builtin_is_array(T: typename) -> bool;
@__builtin export consteval function __builtin_is_tuple(T: typename) -> bool;
@__builtin export consteval function __builtin_is_enum(T: typename) -> bool;

@__builtin export consteval function __builtin_remove_mut(T: typename) -> typename;
@__builtin export consteval function __builtin_remove_consteval(T: typename) -> typename;
@__builtin export consteval function __builtin_remove_pointer(T: typename) -> typename;
@__builtin export consteval function __builtin_remove_optional(T: typename) -> typename;
@__builtin export consteval function __builtin_remove_reference(T: typename) -> typename;
@__builtin export consteval function __builtin_remove_move_reference(T: typename) -> typename;
@__builtin export consteval function __builtin_slice_value_type(T: typename) -> typename;
@__builtin export consteval function __builtin_array_value_type(T: typename) -> typename;
@__builtin export consteval function __builtin_tuple_value_type(T: typename, index: consteval usize) -> typename;
@__builtin export consteval function __builtin_concat_tuple_types(lhs: typename, rhs: typename) -> typename;
@__builtin export consteval function __builtin_enum_underlying_type(T: typename) -> typename;

@__builtin export consteval function __builtin_is_default_constructible(T: typename) -> bool;
@__builtin export consteval function __builtin_is_copy_constructible(T: typename) -> bool;
@__builtin export consteval function __builtin_is_trivially_copy_constructible(T: typename) -> bool;
@__builtin export consteval function __builtin_is_move_constructible(T: typename) -> bool;
@__builtin export consteval function __builtin_is_trivially_move_constructible(T: typename) -> bool;
@__builtin export consteval function __builtin_is_trivially_destructible(T: typename) -> bool;
@__builtin export consteval function __builtin_is_trivially_move_destructible(T: typename) -> bool;
@__builtin export consteval function __builtin_is_trivially_relocatable(T: typename) -> bool;
@__builtin export consteval function __builtin_is_trivial(T: typename) -> bool;

@__builtin export function __builtin_create_initialized_array(T: [??: typename], value: ##auto)
	-> (if consteval (__builtin_array_value_type(T) != __builtin_remove_mut(__builtin_remove_reference(typeof value))) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"mismatched array type '",
			__builtin_typename_as_str(T),
			"' and value type '",
			__builtin_typename_as_str(__builtin_remove_mut(__builtin_remove_reference(typeof value))),
			"' in '__builtin_create_initialized_array'"
		)));
	} else {}, T);

@__builtin export function __builtin_trivially_copy_values(dest: ?*mut auto, source: ?*auto, count: usize)
	-> (if consteval (__builtin_remove_mut(__builtin_remove_pointer(__builtin_remove_optional(typeof dest))) != __builtin_remove_pointer(__builtin_remove_optional(typeof source))) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"mismatched pointer types '",
			__builtin_typename_as_str(typeof dest),
			"' and '",
			__builtin_typename_as_str(typeof source),
			"' in '__builtin_trivially_copy_values'"
		)));
	} else if consteval (!__builtin_is_trivially_copy_constructible(__builtin_remove_pointer(__builtin_remove_optional(typeof dest)))) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"value type '",
			__builtin_typename_as_str(__builtin_remove_pointer(__builtin_remove_optional(typeof dest))),
			"' is not trivially copy constructible in '__builtin_trivially_copy_values'"
		)));
	} else {}, void);

@__builtin export function __builtin_trivially_copy_overlapping_values(dest: ?*mut auto, source: ?*auto, count: usize)
	-> (if consteval (__builtin_remove_mut(__builtin_remove_pointer(__builtin_remove_optional(typeof dest))) != __builtin_remove_pointer(__builtin_remove_optional(typeof source))) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"mismatched pointer types '",
			__builtin_typename_as_str(typeof dest),
			"' and '",
			__builtin_typename_as_str(typeof source),
			"' in '__builtin_trivially_copy_overlapping_values'"
		)));
	} else if consteval (!__builtin_is_trivially_copy_constructible(__builtin_remove_pointer(__builtin_remove_optional(typeof dest)))) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"value type '",
			__builtin_typename_as_str(__builtin_remove_pointer(__builtin_remove_optional(typeof dest))),
			"' is not trivially copy constructible in '__builtin_trivially_copy_overlapping_values'"
		)));
	} else if consteval (!__builtin_is_trivially_destructible(__builtin_remove_pointer(__builtin_remove_optional(typeof dest)))) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"value type '",
			__builtin_typename_as_str(__builtin_remove_pointer(__builtin_remove_optional(typeof dest))),
			"' is not trivially destructible in '__builtin_trivially_copy_overlapping_values'"
		)));
	} else {}, void);

@__builtin export function __builtin_trivially_relocate_values(dest: ?*mut auto, source: ?*mut auto, count: usize)
	-> (if consteval (typeof dest != typeof source) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"mismatched pointer types '",
			__builtin_typename_as_str(typeof dest),
			"' and '",
			__builtin_typename_as_str(typeof source),
			"' in '__builtin_trivially_relocate_values'"
		)));
	} else if consteval (!__builtin_is_trivially_relocatable(__builtin_remove_pointer(__builtin_remove_optional(typeof dest)))) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"value type '",
			__builtin_typename_as_str(__builtin_remove_pointer(__builtin_remove_optional(typeof dest))),
			"' is not trivially relocatable in '__builtin_trivially_relocate_values'"
		)));
	} else {}, void);

@__builtin export function __builtin_trivially_set_values(dest: ?*mut auto, value: auto, count: usize)
	-> (if consteval (__builtin_remove_mut(__builtin_remove_pointer(__builtin_remove_optional(typeof dest))) != typeof value) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"mismatched pointer type '",
			__builtin_typename_as_str(typeof dest),
			"' and value type '",
			__builtin_typename_as_str(typeof value),
			"' in '__builtin_trivially_set_values'"
		)));
	} else if consteval (!__builtin_is_trivially_copy_constructible(typeof value)) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"value type '",
			__builtin_typename_as_str(typeof value),
			"' is not trivially copy constructible in '__builtin_trivially_set_values'"
		)));
	} else if consteval (!__builtin_is_trivially_destructible(typeof value)) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"value type '",
			__builtin_typename_as_str(typeof value),
			"' is not trivially destructible in '__builtin_trivially_set_values'"
		)));
	} else {}, void);

@__builtin export function __builtin_bit_cast(T: typename, value: auto) -> T;

@__builtin export function __builtin_trap();

@__builtin export function __builtin_memcpy(dest: ?*mut void, src: ?*void, n: usize);
@__builtin export function __builtin_memmove(dest: ?*mut void, src: ?*void, n: usize);
@__builtin export function __builtin_memset(dest: ?*mut void, val: u8, n: usize);

@__builtin export function __builtin_isnan_f32(x: float32) -> bool;
@__builtin export function __builtin_isnan_f64(x: float64) -> bool;
@__builtin export function __builtin_isinf_f32(x: float32) -> bool;
@__builtin export function __builtin_isinf_f64(x: float64) -> bool;
@__builtin export function __builtin_isfinite_f32(x: float32) -> bool;
@__builtin export function __builtin_isfinite_f64(x: float64) -> bool;
@__builtin export function __builtin_isnormal_f32(x: float32) -> bool;
@__builtin export function __builtin_isnormal_f64(x: float64) -> bool;
@__builtin export function __builtin_issubnormal_f32(x: float32) -> bool;
@__builtin export function __builtin_issubnormal_f64(x: float64) -> bool;
@__builtin export function __builtin_iszero_f32(x: float32) -> bool;
@__builtin export function __builtin_iszero_f64(x: float64) -> bool;

@__builtin @symbol_name("nextafterf") export function __builtin_nextafter_f32(from: float32, to: float32) -> float32;
@__builtin @symbol_name("nextafter")  export function __builtin_nextafter_f64(from: float64, to: float64) -> float64;

@__builtin export function __builtin_nextup_f32(x: float32) -> float32
{
	let is_nan_or_inf = __builtin_isnan_f32(x) || x == float32.inf;
	let is_zero = x == 0.0f32;

	let x_bits = __builtin_bit_cast(u32, x);
	let abs_x_bits = __builtin_bit_cast(u32, __builtin_abs_f32(x));
	let normalized_zero = if (is_zero) { abs_x_bits } else { x_bits };
	let d = __builtin_arithmetic_shift_right_u32(normalized_zero, 31) | 1u32;
	let finite_result = ((normalized_zero + d));
	let result = if (is_nan_or_inf) { x_bits } else { finite_result };
	return __builtin_bit_cast(float32, result);
}

@__builtin export function __builtin_nextup_f64(x: float64) -> float64
{
	let is_nan_or_inf = __builtin_isnan_f64(x) || x == float64.inf;
	let is_zero = x == 0.0f64;

	let x_bits = __builtin_bit_cast(u64, x);
	let abs_x_bits = __builtin_bit_cast(u64, __builtin_abs_f64(x));
	let normalized_zero = if (is_zero) { abs_x_bits } else { x_bits };
	let d = __builtin_arithmetic_shift_right_u64(normalized_zero, 63) | 1u64;
	let finite_result = ((normalized_zero + d));
	let result = if (is_nan_or_inf) { x_bits } else { finite_result };
	return __builtin_bit_cast(float64, result);
}

@__builtin export function __builtin_nextdown_f32(x: float32) -> float32
{
	let is_nan_or_inf = __builtin_isnan_f32(x) || x == -float32.inf;
	let is_zero = x == 0.0f32;

	let x_bits = __builtin_bit_cast(u32, x);
	let negative_x_bits = __builtin_bit_cast(u32, -__builtin_abs_f32(x));
	let normalized_zero = if (is_zero) { negative_x_bits } else { x_bits };
	let d = __builtin_arithmetic_shift_right_u32(normalized_zero, 31) | 1u32;
	let finite_result = ((normalized_zero - d));
	let result = if (is_nan_or_inf) { x_bits } else { finite_result };
	return __builtin_bit_cast(float32, result);
}

@__builtin export function __builtin_nextdown_f64(x: float64) -> float64
{
	let is_nan_or_inf = __builtin_isnan_f64(x) || x == -float64.inf;
	let is_zero = x == 0.0f64;

	let x_bits = __builtin_bit_cast(u64, x);
	let negative_x_bits = __builtin_bit_cast(u64, -__builtin_abs_f64(x));
	let normalized_zero = if (is_zero) { negative_x_bits } else { x_bits };
	let d = __builtin_arithmetic_shift_right_u64(normalized_zero, 63) | 1u64;
	let finite_result = ((normalized_zero - d));
	let result = if (is_nan_or_inf) { x_bits } else { finite_result };
	return __builtin_bit_cast(float64, result);
}

@__builtin export function __builtin_abs_i8 (n: i8)  -> i8;
@__builtin export function __builtin_abs_i16(n: i16) -> i16;
@__builtin export function __builtin_abs_i32(n: i32) -> i32;
@__builtin export function __builtin_abs_i64(n: i64) -> i64;
@__builtin export function __builtin_abs_f32(x: float32) -> float32;
@__builtin export function __builtin_abs_f64(x: float64) -> float64;

@__builtin export function __builtin_min_i8 (a: i8,  b: i8)  -> i8;
@__builtin export function __builtin_min_i16(a: i16, b: i16) -> i16;
@__builtin export function __builtin_min_i32(a: i32, b: i32) -> i32;
@__builtin export function __builtin_min_i64(a: i64, b: i64) -> i64;
@__builtin export function __builtin_min_u8 (a: u8,  b: u8)  -> u8;
@__builtin export function __builtin_min_u16(a: u16, b: u16) -> u16;
@__builtin export function __builtin_min_u32(a: u32, b: u32) -> u32;
@__builtin export function __builtin_min_u64(a: u64, b: u64) -> u64;
@__builtin export function __builtin_min_f32(a: float32, b: float32) -> float32;
@__builtin export function __builtin_min_f64(a: float64, b: float64) -> float64;

@__builtin export function __builtin_max_i8 (a: i8,  b: i8)  -> i8;
@__builtin export function __builtin_max_i16(a: i16, b: i16) -> i16;
@__builtin export function __builtin_max_i32(a: i32, b: i32) -> i32;
@__builtin export function __builtin_max_i64(a: i64, b: i64) -> i64;
@__builtin export function __builtin_max_u8 (a: u8,  b: u8)  -> u8;
@__builtin export function __builtin_max_u16(a: u16, b: u16) -> u16;
@__builtin export function __builtin_max_u32(a: u32, b: u32) -> u32;
@__builtin export function __builtin_max_u64(a: u64, b: u64) -> u64;
@__builtin export function __builtin_max_f32(a: float32, b: float32) -> float32;
@__builtin export function __builtin_max_f64(a: float64, b: float64) -> float64;

@__builtin @symbol_name("expf") export function __builtin_exp_f32(x: float32) -> float32;
@__builtin @symbol_name("exp")  export function __builtin_exp_f64(x: float64) -> float64;
@__builtin @symbol_name("exp2f") export function __builtin_exp2_f32(x: float32) -> float32;
@__builtin @symbol_name("exp2")  export function __builtin_exp2_f64(x: float64) -> float64;
@__builtin @symbol_name("expm1f") export function __builtin_expm1_f32(x: float32) -> float32;
@__builtin @symbol_name("expm1")  export function __builtin_expm1_f64(x: float64) -> float64;
@__builtin @symbol_name("logf") export function __builtin_log_f32(x: float32) -> float32;
@__builtin @symbol_name("log")  export function __builtin_log_f64(x: float64) -> float64;
@__builtin @symbol_name("log10f") export function __builtin_log10_f32(x: float32) -> float32;
@__builtin @symbol_name("log10")  export function __builtin_log10_f64(x: float64) -> float64;
@__builtin @symbol_name("log2f") export function __builtin_log2_f32(x: float32) -> float32;
@__builtin @symbol_name("log2")  export function __builtin_log2_f64(x: float64) -> float64;
@__builtin @symbol_name("log1pf") export function __builtin_log1p_f32(x: float32) -> float32;
@__builtin @symbol_name("log1p")  export function __builtin_log1p_f64(x: float64) -> float64;

@__builtin @symbol_name("sqrtf") export function __builtin_sqrt_f32(x: float32) -> float32;
@__builtin @symbol_name("sqrt")  export function __builtin_sqrt_f64(x: float64) -> float64;
@__builtin @symbol_name("powf") export function __builtin_pow_f32(x: float32, y: float32) -> float32;
@__builtin @symbol_name("pow")  export function __builtin_pow_f64(x: float64, y: float64) -> float64;
@__builtin @symbol_name("cbrtf") export function __builtin_cbrt_f32(x: float32) -> float32;
@__builtin @symbol_name("cbrt")  export function __builtin_cbrt_f64(x: float64) -> float64;
@__builtin @symbol_name("hypotf") export function __builtin_hypot_f32(x: float32, y: float32) -> float32;
@__builtin @symbol_name("hypot")  export function __builtin_hypot_f64(x: float64, y: float64) -> float64;

@__builtin @symbol_name("sinf") export function __builtin_sin_f32(x: float32) -> float32;
@__builtin @symbol_name("sin")  export function __builtin_sin_f64(x: float64) -> float64;
@__builtin @symbol_name("cosf") export function __builtin_cos_f32(x: float32) -> float32;
@__builtin @symbol_name("cos")  export function __builtin_cos_f64(x: float64) -> float64;
@__builtin @symbol_name("tanf") export function __builtin_tan_f32(x: float32) -> float32;
@__builtin @symbol_name("tan")  export function __builtin_tan_f64(x: float64) -> float64;
@__builtin @symbol_name("asinf") export function __builtin_asin_f32(x: float32) -> float32;
@__builtin @symbol_name("asin")  export function __builtin_asin_f64(x: float64) -> float64;
@__builtin @symbol_name("acosf") export function __builtin_acos_f32(x: float32) -> float32;
@__builtin @symbol_name("acos")  export function __builtin_acos_f64(x: float64) -> float64;
@__builtin @symbol_name("atanf") export function __builtin_atan_f32(x: float32) -> float32;
@__builtin @symbol_name("atan")  export function __builtin_atan_f64(x: float64) -> float64;
@__builtin @symbol_name("atan2f") export function __builtin_atan2_f32(y: float32, x: float32) -> float32;
@__builtin @symbol_name("atan2")  export function __builtin_atan2_f64(y: float64, x: float64) -> float64;

@__builtin @symbol_name("sinhf") export function __builtin_sinh_f32(x: float32) -> float32;
@__builtin @symbol_name("sinh")  export function __builtin_sinh_f64(x: float64) -> float64;
@__builtin @symbol_name("coshf") export function __builtin_cosh_f32(x: float32) -> float32;
@__builtin @symbol_name("cosh")  export function __builtin_cosh_f64(x: float64) -> float64;
@__builtin @symbol_name("tanhf") export function __builtin_tanh_f32(x: float32) -> float32;
@__builtin @symbol_name("tanh")  export function __builtin_tanh_f64(x: float64) -> float64;
@__builtin @symbol_name("asinhf") export function __builtin_asinh_f32(x: float32) -> float32;
@__builtin @symbol_name("asinh")  export function __builtin_asinh_f64(x: float64) -> float64;
@__builtin @symbol_name("acoshf") export function __builtin_acosh_f32(x: float32) -> float32;
@__builtin @symbol_name("acosh")  export function __builtin_acosh_f64(x: float64) -> float64;
@__builtin @symbol_name("atanhf") export function __builtin_atanh_f32(x: float32) -> float32;
@__builtin @symbol_name("atanh")  export function __builtin_atanh_f64(x: float64) -> float64;

@__builtin @symbol_name("erff") export function __builtin_erf_f32(x: float32) -> float32;
@__builtin @symbol_name("erf")  export function __builtin_erf_f64(x: float64) -> float64;
@__builtin @symbol_name("erfcf") export function __builtin_erfc_f32(x: float32) -> float32;
@__builtin @symbol_name("erfc")  export function __builtin_erfc_f64(x: float64) -> float64;
@__builtin @symbol_name("tgammaf") export function __builtin_tgamma_f32(x: float32) -> float32;
@__builtin @symbol_name("tgamma")  export function __builtin_tgamma_f64(x: float64) -> float64;
@__builtin @symbol_name("lgammaf") export function __builtin_lgamma_f32(x: float32) -> float32;
@__builtin @symbol_name("lgamma")  export function __builtin_lgamma_f64(x: float64) -> float64;

@__builtin export function __builtin_bitreverse_u8 (n: u8)  -> u8;
@__builtin export function __builtin_bitreverse_u16(n: u16) -> u16;
@__builtin export function __builtin_bitreverse_u32(n: u32) -> u32;
@__builtin export function __builtin_bitreverse_u64(n: u64) -> u64;
@__builtin export function __builtin_popcount_u8 (n: u8)  -> u8;
@__builtin export function __builtin_popcount_u16(n: u16) -> u16;
@__builtin export function __builtin_popcount_u32(n: u32) -> u32;
@__builtin export function __builtin_popcount_u64(n: u64) -> u64;
@__builtin export function __builtin_byteswap_u16(n: u16) -> u16;
@__builtin export function __builtin_byteswap_u32(n: u32) -> u32;
@__builtin export function __builtin_byteswap_u64(n: u64) -> u64;

@__builtin export function __builtin_clz_u8 (n: u8)  -> u8;
@__builtin export function __builtin_clz_u16(n: u16) -> u16;
@__builtin export function __builtin_clz_u32(n: u32) -> u32;
@__builtin export function __builtin_clz_u64(n: u64) -> u64;
@__builtin export function __builtin_ctz_u8 (n: u8)  -> u8;
@__builtin export function __builtin_ctz_u16(n: u16) -> u16;
@__builtin export function __builtin_ctz_u32(n: u32) -> u32;
@__builtin export function __builtin_ctz_u64(n: u64) -> u64;
@__builtin export function __builtin_fshl_u8 (a: u8,  b: u8,  amount: u8)  -> u8;
@__builtin export function __builtin_fshl_u16(a: u16, b: u16, amount: u16) -> u16;
@__builtin export function __builtin_fshl_u32(a: u32, b: u32, amount: u32) -> u32;
@__builtin export function __builtin_fshl_u64(a: u64, b: u64, amount: u64) -> u64;
@__builtin export function __builtin_fshr_u8 (a: u8,  b: u8,  amount: u8)  -> u8;
@__builtin export function __builtin_fshr_u16(a: u16, b: u16, amount: u16) -> u16;
@__builtin export function __builtin_fshr_u32(a: u32, b: u32, amount: u32) -> u32;
@__builtin export function __builtin_fshr_u64(a: u64, b: u64, amount: u64) -> u64;

@__builtin export function __builtin_arithmetic_shift_right_u8 (n: u8,  amount: u8)  -> u8;
@__builtin export function __builtin_arithmetic_shift_right_u16(n: u16, amount: u16) -> u16;
@__builtin export function __builtin_arithmetic_shift_right_u32(n: u32, amount: u32) -> u32;
@__builtin export function __builtin_arithmetic_shift_right_u64(n: u64, amount: u64) -> u64;

//
// unary operators
//

@__builtin export operator * (p: *auto) -> &__builtin_remove_pointer(typeof p);
@__builtin export operator * (p: *mut auto) -> &__builtin_remove_pointer(typeof p);
@__builtin export operator * (p: ?*auto) -> &__builtin_remove_pointer(__builtin_remove_optional(typeof p));
@__builtin export operator * (p: ?*mut auto) -> &__builtin_remove_pointer(__builtin_remove_optional(typeof p));

@__builtin export operator ++ (p: &mut *auto) -> typeof p;
@__builtin export operator ++ (p: &mut *mut auto) -> typeof p;
@__builtin export operator ++ (p: &mut ?*auto) -> typeof p;
@__builtin export operator ++ (p: &mut ?*mut auto) -> typeof p;

@__builtin export operator -- (p: &mut *auto) -> typeof p;
@__builtin export operator -- (p: &mut *mut auto) -> typeof p;
@__builtin export operator -- (p: &mut ?*auto) -> typeof p;
@__builtin export operator -- (p: &mut ?*mut auto) -> typeof p;


//
// binary operators
//

@__builtin_assign export operator = (lhs: &mut *auto, rhs: *auto)
	-> (if consteval (__builtin_remove_mut(__builtin_remove_reference(typeof lhs)) != typeof rhs) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"mismatched pointer types '",
			__builtin_typename_as_str(__builtin_remove_reference(typeof lhs)),
			"' and '",
			__builtin_typename_as_str(typeof rhs),
			"' in assignment"
		)));
	} else {}, typeof lhs);
@__builtin_assign export operator = (lhs: &mut *mut auto, rhs: *mut auto)
	-> (if consteval (__builtin_remove_mut(__builtin_remove_reference(typeof lhs)) != typeof rhs) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"mismatched pointer types '",
			__builtin_typename_as_str(__builtin_remove_reference(typeof lhs)),
			"' and '",
			__builtin_typename_as_str(typeof rhs),
			"' in assignment"
		)));
	} else {}, typeof lhs);
@__builtin_assign export operator = (lhs: &mut function(...##auto) -> ##auto, rhs: function(...##auto) -> ##auto)
	-> (if consteval (__builtin_remove_mut(__builtin_remove_reference(typeof lhs)) != typeof rhs) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"mismatched function types '",
			__builtin_typename_as_str(__builtin_remove_reference(typeof lhs)),
			"' and '",
			__builtin_typename_as_str(typeof rhs),
			"' in assignment"
		)));
	} else {}, typeof lhs);
@__builtin_assign export operator = (lhs: &mut ?##auto, rhs: ##auto) -> typeof lhs;
@__builtin_assign export operator = (lhs: &mut ?##auto, rhs: __null_t) -> typeof lhs;
@__builtin_assign export operator = (lhs: &mut [: auto], rhs: [: auto])
	-> (if consteval (__builtin_remove_mut(__builtin_remove_reference(typeof lhs)) != typeof rhs) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"mismatched slice types '",
			__builtin_typename_as_str(__builtin_remove_reference(typeof lhs)),
			"' and '",
			__builtin_typename_as_str(typeof rhs),
			"' in assignment"
		)));
	} else {}, typeof lhs);
@__builtin_assign export operator = (lhs: &mut [: mut auto], rhs: [: mut auto])
	-> (if consteval (__builtin_remove_mut(__builtin_remove_reference(typeof lhs)) != typeof rhs) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"mismatched slice types '",
			__builtin_typename_as_str(__builtin_remove_reference(typeof lhs)),
			"' and '",
			__builtin_typename_as_str(typeof rhs),
			"' in assignment"
		)));
	} else {}, typeof lhs);
@__builtin_assign export operator = (lhs: &mut [...auto], rhs: ##[...auto]) -> typeof lhs;
@__builtin_assign export operator = (lhs: &mut [??: auto], rhs: ##[??: auto]) -> typeof lhs;

@__builtin @overload_priority(1) export operator + (lhs: *auto, rhs: i64) -> typeof lhs;
@__builtin @overload_priority(0) export operator + (lhs: *auto, rhs: u64) -> typeof lhs;
@__builtin @overload_priority(1) export operator + (lhs: *mut auto, rhs: i64) -> typeof lhs;
@__builtin @overload_priority(0) export operator + (lhs: *mut auto, rhs: u64) -> typeof lhs;
@__builtin @overload_priority(1) export operator + (lhs: ?*auto, rhs: i64) -> typeof lhs;
@__builtin @overload_priority(0) export operator + (lhs: ?*auto, rhs: u64) -> typeof lhs;
@__builtin @overload_priority(1) export operator + (lhs: ?*mut auto, rhs: i64) -> typeof lhs;
@__builtin @overload_priority(0) export operator + (lhs: ?*mut auto, rhs: u64) -> typeof lhs;
@__builtin @overload_priority(1) export operator + (lhs: i64, rhs: *auto) -> typeof rhs;
@__builtin @overload_priority(0) export operator + (lhs: u64, rhs: *auto) -> typeof rhs;
@__builtin @overload_priority(1) export operator + (lhs: i64, rhs: *mut auto) -> typeof rhs;
@__builtin @overload_priority(0) export operator + (lhs: u64, rhs: *mut auto) -> typeof rhs;
@__builtin @overload_priority(1) export operator + (lhs: i64, rhs: ?*auto) -> typeof rhs;
@__builtin @overload_priority(0) export operator + (lhs: u64, rhs: ?*auto) -> typeof rhs;
@__builtin @overload_priority(1) export operator + (lhs: i64, rhs: ?*mut auto) -> typeof rhs;
@__builtin @overload_priority(0) export operator + (lhs: u64, rhs: ?*mut auto) -> typeof rhs;

@__builtin @overload_priority(1) export operator += (lhs: &mut *auto, rhs: i64) -> typeof lhs;
@__builtin @overload_priority(0) export operator += (lhs: &mut *auto, rhs: u64) -> typeof lhs;
@__builtin @overload_priority(1) export operator += (lhs: &mut *mut auto, rhs: i64) -> typeof lhs;
@__builtin @overload_priority(0) export operator += (lhs: &mut *mut auto, rhs: u64) -> typeof lhs;
@__builtin @overload_priority(1) export operator += (lhs: &mut ?*auto, rhs: i64) -> typeof lhs;
@__builtin @overload_priority(0) export operator += (lhs: &mut ?*auto, rhs: u64) -> typeof lhs;
@__builtin @overload_priority(1) export operator += (lhs: &mut ?*mut auto, rhs: i64) -> typeof lhs;
@__builtin @overload_priority(0) export operator += (lhs: &mut ?*mut auto, rhs: u64) -> typeof lhs;

consteval function are_compatible_pointer_types(lhs: typename, rhs: typename) -> bool
{
	if consteval (
		(__builtin_is_pointer(lhs) || (__builtin_is_optional(lhs) && __builtin_is_pointer(__builtin_remove_optional(lhs))))
		&& (__builtin_is_pointer(rhs) || (__builtin_is_optional(rhs) && __builtin_is_pointer(__builtin_remove_optional(rhs))))
	)
	{
		return are_compatible_pointer_types(
			__builtin_remove_mut(__builtin_remove_pointer(__builtin_remove_optional(lhs))),
			__builtin_remove_mut(__builtin_remove_pointer(__builtin_remove_optional(rhs))),
		);
	}
	else
	{
		return lhs == rhs;
	}
}

@__builtin @overload_priority(1) export operator - (lhs: *auto, rhs: i64) -> typeof lhs;
@__builtin @overload_priority(0) export operator - (lhs: *auto, rhs: u64) -> typeof lhs;
@__builtin @overload_priority(1) export operator - (lhs: *mut auto, rhs: i64) -> typeof lhs;
@__builtin @overload_priority(0) export operator - (lhs: *mut auto, rhs: u64) -> typeof lhs;
@__builtin @overload_priority(1) export operator - (lhs: ?*auto, rhs: i64) -> typeof lhs;
@__builtin @overload_priority(0) export operator - (lhs: ?*auto, rhs: u64) -> typeof lhs;
@__builtin @overload_priority(1) export operator - (lhs: ?*mut auto, rhs: i64) -> typeof lhs;
@__builtin @overload_priority(0) export operator - (lhs: ?*mut auto, rhs: u64) -> typeof lhs;
@__builtin export operator - (lhs: *auto, rhs: *auto)
	-> (if consteval (!are_compatible_pointer_types(typeof lhs, typeof rhs)) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"mismatched pointer types '",
			__builtin_typename_as_str(__builtin_remove_reference(typeof lhs)),
			"' and '",
			__builtin_typename_as_str(typeof rhs),
			"' in 'operator -'"
		)));
	} else {}, isize);
@__builtin export operator - (lhs: ?*auto, rhs: ?*auto)
	-> (if consteval (!are_compatible_pointer_types(typeof lhs, typeof rhs)) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"mismatched optional pointer types '",
			__builtin_typename_as_str(__builtin_remove_reference(typeof lhs)),
			"' and '",
			__builtin_typename_as_str(typeof rhs),
			"' in 'operator -'"
		)));
	} else {}, isize);

@__builtin @overload_priority(1) export operator -= (lhs: &mut *auto, rhs: i64) -> typeof lhs;
@__builtin @overload_priority(0) export operator -= (lhs: &mut *auto, rhs: u64) -> typeof lhs;
@__builtin @overload_priority(1) export operator -= (lhs: &mut *mut auto, rhs: i64) -> typeof lhs;
@__builtin @overload_priority(0) export operator -= (lhs: &mut *mut auto, rhs: u64) -> typeof lhs;
@__builtin @overload_priority(1) export operator -= (lhs: &mut ?*auto, rhs: i64) -> typeof lhs;
@__builtin @overload_priority(0) export operator -= (lhs: &mut ?*auto, rhs: u64) -> typeof lhs;
@__builtin @overload_priority(1) export operator -= (lhs: &mut ?*mut auto, rhs: i64) -> typeof lhs;
@__builtin @overload_priority(0) export operator -= (lhs: &mut ?*mut auto, rhs: u64) -> typeof lhs;

@__builtin export operator == (lhs: [: auto], rhs: [: auto]) -> bool
{
	if (__builtin_slice_size(lhs) != __builtin_slice_size(rhs))
	{
		return false;
	}

	mut lhs_it = __builtin_slice_begin_ptr(lhs);
	mut rhs_it = __builtin_slice_begin_ptr(rhs);
	let lhs_end = __builtin_slice_end_ptr(lhs);
	if consteval (typeof lhs == typeof rhs)
	{
		if (lhs_it == rhs_it)
		{
			return true;
		}
	}

	for (; lhs_it != lhs_end; ++lhs_it, ++rhs_it)
	{
		if (!(*lhs_it == *rhs_it))
		{
			return false;
		}
	}
	return true;
}
@__builtin export operator == (lhs: *auto, rhs: *auto)
	-> (if consteval (!are_compatible_pointer_types(typeof lhs, typeof rhs)) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"mismatched pointer types '",
			__builtin_typename_as_str(__builtin_remove_reference(typeof lhs)),
			"' and '",
			__builtin_typename_as_str(typeof rhs),
			"' in comparison operator"
		)));
	} else {}, bool);
@__builtin export operator == (lhs: ?*auto, rhs: ?*auto)
	-> (if consteval (!are_compatible_pointer_types(typeof lhs, typeof rhs)) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"mismatched optional pointer types '",
			__builtin_typename_as_str(__builtin_remove_reference(typeof lhs)),
			"' and '",
			__builtin_typename_as_str(typeof rhs),
			"' in comparison operator"
		)));
	} else {}, bool);
@__builtin export operator == (lhs: function(...##auto) -> ##auto, rhs: function(...##auto) -> ##auto)
	-> (if consteval (typeof lhs != typeof rhs) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"mismatched function types '",
			__builtin_typename_as_str(__builtin_remove_reference(typeof lhs)),
			"' and '",
			__builtin_typename_as_str(typeof rhs),
			"' in comparison operator"
		)));
	} else {}, bool);
@__builtin export operator == (lhs: ?function(...##auto) -> ##auto, rhs: ?function(...##auto) -> ##auto)
	-> (if consteval (typeof lhs != typeof rhs) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"mismatched optional function types '",
			__builtin_typename_as_str(__builtin_remove_reference(typeof lhs)),
			"' and '",
			__builtin_typename_as_str(typeof rhs),
			"' in comparison operator"
		)));
	} else {}, bool);
@__builtin export operator == (lhs: #?auto, rhs: __null_t) -> bool;
@__builtin export operator == (lhs: __null_t, rhs: #?auto) -> bool;

@__builtin export operator != (lhs: [: auto], rhs: [: auto]) -> bool
{
	if (__builtin_slice_size(lhs) != __builtin_slice_size(rhs))
	{
		return true;
	}

	mut lhs_it = __builtin_slice_begin_ptr(lhs);
	mut rhs_it = __builtin_slice_begin_ptr(rhs);
	let lhs_end = __builtin_slice_end_ptr(lhs);
	if consteval (typeof lhs == typeof rhs)
	{
		if (lhs_it == rhs_it)
		{
			return false;
		}
	}

	for (; lhs_it != lhs_end; ++lhs_it, ++rhs_it)
	{
		if (*lhs_it != *rhs_it)
		{
			return true;
		}
	}
	return false;
}
@__builtin export operator != (lhs: *auto, rhs: *auto)
	-> (if consteval (!are_compatible_pointer_types(typeof lhs, typeof rhs)) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"mismatched pointer types '",
			__builtin_typename_as_str(__builtin_remove_reference(typeof lhs)),
			"' and '",
			__builtin_typename_as_str(typeof rhs),
			"' in comparison operator"
		)));
	} else {}, bool);
@__builtin export operator != (lhs: ?*auto, rhs: ?*auto)
	-> (if consteval (!are_compatible_pointer_types(typeof lhs, typeof rhs)) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"mismatched optional pointer types '",
			__builtin_typename_as_str(__builtin_remove_reference(typeof lhs)),
			"' and '",
			__builtin_typename_as_str(typeof rhs),
			"' in comparison operator"
		)));
	} else {}, bool);
@__builtin export operator != (lhs: function(...##auto) -> ##auto, rhs: function(...##auto) -> ##auto)
	-> (if consteval (typeof lhs != typeof rhs) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"mismatched function types '",
			__builtin_typename_as_str(__builtin_remove_reference(typeof lhs)),
			"' and '",
			__builtin_typename_as_str(typeof rhs),
			"' in comparison operator"
		)));
	} else {}, bool);
@__builtin export operator != (lhs: ?function(...##auto) -> ##auto, rhs: ?function(...##auto) -> ##auto)
	-> (if consteval (typeof lhs != typeof rhs) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"mismatched optional function types '",
			__builtin_typename_as_str(__builtin_remove_reference(typeof lhs)),
			"' and '",
			__builtin_typename_as_str(typeof rhs),
			"' in comparison operator"
		)));
	} else {}, bool);
@__builtin export operator != (lhs: #?auto, rhs: __null_t) -> bool;
@__builtin export operator != (lhs: __null_t, rhs: #?auto) -> bool;

@__builtin export operator < (lhs: *auto, rhs: *auto)
	-> (if consteval (!are_compatible_pointer_types(typeof lhs, typeof rhs)) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"mismatched pointer types '",
			__builtin_typename_as_str(__builtin_remove_reference(typeof lhs)),
			"' and '",
			__builtin_typename_as_str(typeof rhs),
			"' in comparison operator"
		)));
	} else {}, bool);
@__builtin export operator < (lhs: ?*auto, rhs: ?*auto)
	-> (if consteval (!are_compatible_pointer_types(typeof lhs, typeof rhs)) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"mismatched optional pointer types '",
			__builtin_typename_as_str(__builtin_remove_reference(typeof lhs)),
			"' and '",
			__builtin_typename_as_str(typeof rhs),
			"' in comparison operator"
		)));
	} else {}, bool);

@__builtin export operator <= (lhs: *auto, rhs: *auto)
	-> (if consteval (!are_compatible_pointer_types(typeof lhs, typeof rhs)) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"mismatched pointer types '",
			__builtin_typename_as_str(__builtin_remove_reference(typeof lhs)),
			"' and '",
			__builtin_typename_as_str(typeof rhs),
			"' in comparison operator"
		)));
	} else {}, bool);
@__builtin export operator <= (lhs: ?*auto, rhs: ?*auto)
	-> (if consteval (!are_compatible_pointer_types(typeof lhs, typeof rhs)) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"mismatched optional pointer types '",
			__builtin_typename_as_str(__builtin_remove_reference(typeof lhs)),
			"' and '",
			__builtin_typename_as_str(typeof rhs),
			"' in comparison operator"
		)));
	} else {}, bool);

@__builtin export operator > (lhs: *auto, rhs: *auto)
	-> (if consteval (!are_compatible_pointer_types(typeof lhs, typeof rhs)) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"mismatched pointer types '",
			__builtin_typename_as_str(__builtin_remove_reference(typeof lhs)),
			"' and '",
			__builtin_typename_as_str(typeof rhs),
			"' in comparison operator"
		)));
	} else {}, bool);
@__builtin export operator > (lhs: ?*auto, rhs: ?*auto)
	-> (if consteval (!are_compatible_pointer_types(typeof lhs, typeof rhs)) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"mismatched optional pointer types '",
			__builtin_typename_as_str(__builtin_remove_reference(typeof lhs)),
			"' and '",
			__builtin_typename_as_str(typeof rhs),
			"' in comparison operator"
		)));
	} else {}, bool);

@__builtin export operator >= (lhs: *auto, rhs: *auto)
	-> (if consteval (!are_compatible_pointer_types(typeof lhs, typeof rhs)) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"mismatched pointer types '",
			__builtin_typename_as_str(__builtin_remove_reference(typeof lhs)),
			"' and '",
			__builtin_typename_as_str(typeof rhs),
			"' in comparison operator"
		)));
	} else {}, bool);
@__builtin export operator >= (lhs: ?*auto, rhs: ?*auto)
	-> (if consteval (!are_compatible_pointer_types(typeof lhs, typeof rhs)) {
		(consteval __builtin_comptime_compile_error(__builtin_comptime_concatenate_strs(
			"mismatched optional pointer types '",
			__builtin_typename_as_str(__builtin_remove_reference(typeof lhs)),
			"' and '",
			__builtin_typename_as_str(typeof rhs),
			"' in comparison operator"
		)));
	} else {}, bool);

@__builtin @overload_priority(0) export operator [] (array: #[: auto], index: i64);
@__builtin @overload_priority(1) export operator [] (array: #[: auto], index: u64);
@__builtin @overload_priority(0) export operator [] (array: #[: mut auto], index: i64);
@__builtin @overload_priority(1) export operator [] (array: #[: mut auto], index: u64);
@__builtin @overload_priority(0) export operator [] (array: ##[??: auto], index: i64);
@__builtin @overload_priority(1) export operator [] (array: ##[??: auto], index: u64);
@__builtin @overload_priority(0) export operator [] (tuple: ##[...##auto], index: consteval i64);
@__builtin @overload_priority(1) export operator [] (tuple: ##[...##auto], index: consteval u64);

@__builtin export operator [] (array: #[: auto], index: __integer_range)
	-> __builtin_remove_mut(__builtin_remove_reference(typeof array));
@__builtin export operator [] (array: #[: auto], index: __integer_range_from)
	-> __builtin_remove_mut(__builtin_remove_reference(typeof array));
@__builtin export operator [] (array: #[: auto], index: __integer_range_to)
	-> __builtin_remove_mut(__builtin_remove_reference(typeof array));
@__builtin export operator [] (array: #[: auto], index: __range_unbounded)
	-> __builtin_remove_mut(__builtin_remove_reference(typeof array));

@__builtin export operator [] (array: #[: mut auto], index: __integer_range)
	-> __builtin_remove_mut(__builtin_remove_reference(typeof array));
@__builtin export operator [] (array: #[: mut auto], index: __integer_range_from)
	-> __builtin_remove_mut(__builtin_remove_reference(typeof array));
@__builtin export operator [] (array: #[: mut auto], index: __integer_range_to)
	-> __builtin_remove_mut(__builtin_remove_reference(typeof array));
@__builtin export operator [] (array: #[: mut auto], index: __range_unbounded)
	-> __builtin_remove_mut(__builtin_remove_reference(typeof array));

@__builtin export operator [] (array: move [??: auto], index: __integer_range)
	-> [: __builtin_array_value_type(__builtin_remove_move_reference(typeof array))];
@__builtin export operator [] (array: move [??: auto], index: __integer_range_from)
	-> [: __builtin_array_value_type(__builtin_remove_move_reference(typeof array))];
@__builtin export operator [] (array: move [??: auto], index: __integer_range_to)
	-> [: __builtin_array_value_type(__builtin_remove_move_reference(typeof array))];
@__builtin export operator [] (array: move [??: auto], index: __range_unbounded)
	-> [: __builtin_array_value_type(__builtin_remove_move_reference(typeof array))];

@__builtin export operator [] (array: &[??: auto], index: __integer_range)
	-> [: __builtin_array_value_type(__builtin_remove_reference(typeof array))];
@__builtin export operator [] (array: &[??: auto], index: __integer_range_from)
	-> [: __builtin_array_value_type(__builtin_remove_reference(typeof array))];
@__builtin export operator [] (array: &[??: auto], index: __integer_range_to)
	-> [: __builtin_array_value_type(__builtin_remove_reference(typeof array))];
@__builtin export operator [] (array: &[??: auto], index: __range_unbounded)
	-> [: __builtin_array_value_type(__builtin_remove_reference(typeof array))];

@__builtin export operator [] (array: &mut [??: auto], index: __integer_range)
	-> [: mut __builtin_array_value_type(__builtin_remove_mut(__builtin_remove_reference(typeof array)))];
@__builtin export operator [] (array: &mut [??: auto], index: __integer_range_from)
	-> [: mut __builtin_array_value_type(__builtin_remove_mut(__builtin_remove_reference(typeof array)))];
@__builtin export operator [] (array: &mut [??: auto], index: __integer_range_to)
	-> [: mut __builtin_array_value_type(__builtin_remove_mut(__builtin_remove_reference(typeof array)))];
@__builtin export operator [] (array: &mut [??: auto], index: __range_unbounded)
	-> [: mut __builtin_array_value_type(__builtin_remove_mut(__builtin_remove_reference(typeof array)))];
