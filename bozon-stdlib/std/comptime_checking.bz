@builtin("str_eq")
function builtin_str_eq(lhs: str, rhs: str) -> bool
{
	if (__builtin_str_size(lhs) != __builtin_str_size(rhs))
	{
		return false;
	}

	let lhs_it = __builtin_str_begin_ptr(lhs);
	let rhs_it = __builtin_str_begin_ptr(rhs);
	const lhs_end = __builtin_str_end_ptr(lhs);
	if (lhs_it == rhs_it)
	{
		return true;
	}

	for (; lhs_it != lhs_end; ++lhs_it, ++rhs_it)
	{
		if (*lhs_it != *rhs_it)
		{
			return false;
		}
	}
	return true;
}

@builtin("str_neq")
function builtin_str_neq(lhs: str, rhs: str) -> bool
{
	if (__builtin_str_size(lhs) != __builtin_str_size(rhs))
	{
		return true;
	}

	let lhs_it = __builtin_str_begin_ptr(lhs);
	let rhs_it = __builtin_str_begin_ptr(rhs);
	const lhs_end = __builtin_str_end_ptr(lhs);
	if (lhs_it == rhs_it)
	{
		return false;
	}

	for (; lhs_it != lhs_end; ++lhs_it, ++rhs_it)
	{
		if (*lhs_it != *rhs_it)
		{
			return true;
		}
	}
	return false;
}

@builtin("str_length")
function builtin_str_length(s: str) -> usize
{
	let continuation_byte_count = 0uz;
	const str_as_slice = __builtin_slice_from_const_ptrs(__builtin_str_begin_ptr(s), __builtin_str_end_ptr(s));
	for (const c in str_as_slice)
	{
		if ((c & 0b1100'0000u8) == 0b1000'0000u8)
		{
			continuation_byte_count += 1uz;
		}
	}
	const size = __builtin_str_size(s);
	return size - continuation_byte_count;
}

struct call_stack_t
{
	.data_begin: *uint64;
	.data_end:   *uint64;
	.alloc_end:  *uint64;

	// @no_comptime_checking
	destructor(&self)
	{
		for (let it = self.data_begin; it != self.data_end; ++it)
		{
			__builtin_call_destructor(*it);
		}
		free(self.data_begin);
		self.data_begin = null;
		self.data_end   = null;
		self.alloc_end  = null;
	}
}

struct error_t
{
	.kind: uint32;
	.ptr:  uint64;
	.call_stack: [: const uint64];

	// @no_comptime_checking
	destructor(&self)
	{
		free(self.call_stack.begin());
	}
}

struct error_array_t
{
	.data_begin: *error_t;
	.data_end:   *error_t;
	.alloc_end:  *error_t;

	// @no_comptime_checking
	destructor(&self)
	{
		for (let it = self.data_begin; it != self.data_end; ++it)
		{
			__builtin_call_destructor(*it);
		}
		free(self.data_begin);
		self.data_begin = null;
		self.data_end   = null;
		self.alloc_end  = null;
	}
}

@no_comptime_checking
function alloc(T: typename, count: usize) -> *T
{
	return __builtin_pointer_cast(*T, __builtin_comptime_malloc(count * sizeof T));
}

@no_comptime_checking
function free(p: *const void)
{
	__builtin_comptime_free(p);
}

@no_comptime_checking
function push_back(arr: &auto, val: auto)
{
	type value_type = typeof *arr.data_begin;
	static_assert(value_type == error_t || value_type == uint64);
	if (arr.data_begin == null)
	{
		const new_array = alloc(value_type, 1u);
		arr.data_begin = new_array;
		arr.data_end   = new_array;
		arr.alloc_end  = new_array + 1;
	}
	else if (arr.data_end == arr.alloc_end)
	{
		const old_capacity = (arr.alloc_end - arr.data_begin) as usize;
		const new_capacity = 2u * old_capacity;
		const new_array = alloc(value_type, new_capacity);
		for (let i = 0u64; i < old_capacity; ++i)
		{
			*(new_array + i) = *(arr.data_begin + i);
		}
		free(arr.data_begin);
		arr.data_begin = new_array;
		arr.data_end   = new_array + old_capacity;
		arr.alloc_end  = new_array + new_capacity;
	}

	*arr.data_end = val;
	++arr.data_end;
}

@no_comptime_checking
function pop_back(arr: &call_stack_t)
{
	if (arr.data_begin == arr.data_end)
	{
		return;
	}
	--arr.data_end;
}

@no_comptime_checking
function size(arr: &const auto) -> usize
{
	return (arr.data_end - arr.data_begin) as usize;
}

@no_comptime_checking
function empty(arr: &const auto) -> bool
{
	return arr.data_begin == arr.data_end;
}

@no_comptime_checking
function clear(arr: &call_stack_t)
{
	for (let it = arr.data_end; it != arr.data_begin;)
	{
		--it;
		__builtin_call_destructor(*it);
	}
	arr.data_end = arr.data_begin;
}

@no_comptime_checking
function clear(arr: &error_array_t)
{
	for (let it = arr.data_end; it != arr.data_begin;)
	{
		--it;
		__builtin_call_destructor(*it);
	}
	arr.data_end = arr.data_begin;
}

@no_comptime_checking
operator [] (arr: &auto, i: uint64) -> &typeof *arr.data_begin
{
	return *(arr.data_begin + i);
}

@no_comptime_checking
operator [] (arr: &const auto, i: uint64) -> &const typeof *arr.data_begin
{
	return *(arr.data_begin + i);
}

@no_comptime_checking
operator [] (arr: &auto, i: int64) -> &typeof *arr.data_begin
{
	return *(arr.data_begin + i);
}

@no_comptime_checking
operator [] (arr: &const auto, i: int64) -> &const typeof *arr.data_begin
{
	return *(arr.data_begin + i);
}

@no_runtime_emit
@comptime_error_checking("errors_var")
let errors = error_array_t[ null, null, null ];

@no_runtime_emit
@comptime_error_checking("call_stack_var")
let call_stack = call_stack_t[ null, null, null ];


@comptime_error_checking("cleanup")
function cleanup()
{
	__builtin_call_destructor(errors);
	__builtin_call_destructor(call_stack);
}

@comptime_error_checking("get_error_count")
function get_error_count() -> uint64
{
	return errors.size();
}

@comptime_error_checking("get_error_kind_by_index")
function get_error_kind_by_index(i: uint64) -> uint32
{
	return if (i < errors.size()) { errors[i].kind } else { 0u32 };
}

@comptime_error_checking("get_error_ptr_by_index")
function get_error_ptr_by_index(i: uint64) -> uint64
{
	return if (i < errors.size()) { errors[i].ptr } else { 0u64 };
}

@comptime_error_checking("get_error_call_stack_size_by_index")
function get_error_call_stack_size_by_index(i: uint64) -> uint64
{
	return if (i < errors.size()) { errors[i].call_stack.size() } else { 0u64 };
}

@comptime_error_checking("get_error_call_stack_element_by_index")
function get_error_call_stack_element_by_index(i: uint64, j: uint64) -> uint64
{
	return if (i < errors.size() && j < errors[i].call_stack.size()) { errors[i].call_stack[j] } else { 0u64 };
}

@comptime_error_checking("has_errors")
function has_errors() -> bool
{
	return !errors.empty();
}

@comptime_error_checking("add_error")
function add_error(kind: uint32, err: uint64)
{
	const call_stack_size = call_stack.size();
	const call_stack_array = if (call_stack_size == 0u) {
			__builtin_slice_from_const_ptrs(null as *const uint64, null as *const uint64)
		} else {
			const ptr = alloc(uint64, call_stack_size);
			const result = __builtin_slice_from_ptrs(ptr, ptr + call_stack_size);
			for (let i = 0u; i < call_stack_size; ++i)
			{
				result[i] = call_stack[i];
			}
			result
		};
	errors.push_back(error_t[ kind, err, call_stack_array ]);
}

@comptime_error_checking("push_call")
function push_call(call: uint64)
{
	call_stack.push_back(call);
}

@comptime_error_checking("pop_call")
function pop_call()
{
	call_stack.pop_back();
}

@comptime_error_checking("clear_errors")
function clear_errors()
{
	errors.clear();
}
