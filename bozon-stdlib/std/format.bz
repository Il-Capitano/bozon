import string;
import print;
import utils;
import ryu::d2s;
import ryu::f2s;
import ryu::digit_table;

export struct format_buffer
{
	._str: string;
}

export function write_into(buffer: &format_buffer, s: str)
{
	buffer._str ..= s;
}

export function write_into(buffer: &format_buffer, c: char)
{
	buffer._str ..= c;
}

function check_fmt_str(fmt_str: str)
{
	let it = fmt_str.begin_ptr();
	const end = fmt_str.end_ptr();

	for (; it != end; ++it)
	{
		if (*it == '{' as uint32 && (it + 1 == end || *(it + 1) != '}' as uint32))
		{
			const message = format_unchecked_fmt("invalid format string '{}'; expected closing '}' at '{}'", fmt_str, __builtin_str_from_ptrs(it + 1, end));
			__builtin_comptime_compile_error(message.as_str());
		}
	}
}

function count_args_in_str(fmt_str: str) -> usize
{
	let it = __builtin_str_begin_ptr(fmt_str);
	const end = __builtin_str_end_ptr(fmt_str);

	let result = 0uz;
	for (; it != end; ++it)
	{
		if (*it == '{' as uint32 && it + 1 != end && *(it + 1) == '}' as uint32)
		{
			++result;
		}
	}
	return result;
}

function get_slices(fmt_str: str, out: [: str])
{
	let it = __builtin_str_begin_ptr(fmt_str);
	let prev_begin = it;
	const end = __builtin_str_end_ptr(fmt_str);
	let index = 0uz;

	for (; it != end; ++it)
	{
		if (*it == '{' as uint32 && it + 1 != end && *(it + 1) == '}' as uint32)
		{
			out[index] = __builtin_str_from_ptrs(prev_begin, it);
			index += 1u;
			prev_begin = it + 2;
			// other increment will happen at the next start of the loop
			it += 1;
		}
	}
	out[index] = __builtin_str_from_ptrs(prev_begin, it);
}

function get_slices(fmt_str: str, args_count: consteval usize) -> [args_count + 1u: str]
{
	let result: [args_count + 1u: str];
	get_slices(fmt_str, result);
	return result;
}

function get_indices(start: consteval usize, end: consteval usize) -> [(if (end - start == 0u) { 1u } else { end - start }): usize]
{
	let result: [(if (end - start == 0u) { 1u } else { end - start }): usize];
	for (let [i, counter] = [ 0uz, start]; counter != end; ++i, ++counter)
	{
		result[i] = counter;
	}
	return result;
}

function format_into_impl(buffer: &format_buffer, index: consteval [1: usize], slices: [: const str], arg_ptrs: &const auto)
{
	consteval index = index[0];
	buffer.write_into(slices[index]);
	(*arg_ptrs[index]).format_to(buffer);
}

function format_into_impl(buffer: &format_buffer, indices: consteval auto, slices: [: const str], arg_ptrs: &const auto)
{
	consteval index = indices[0];
	buffer.write_into(slices[index]);
	(*arg_ptrs[index]).format_to(buffer);
	consteval rest_indices = get_indices(indices[1], indices[indices.size() - 1u] + 1u);
	buffer.format_into_impl(rest_indices, slices, arg_ptrs);
}

export function format_into(buffer: &format_buffer, fmt_str: consteval str, args: ...#const auto)
{
	const arg_ptrs = [ ...&args, null as *const int32 ];
	consteval args_count = count_args_in_str(fmt_str);
	consteval indices = get_indices(0uz, args_count);
	const slices = get_slices(fmt_str, args_count);
	if (slices.size() > 1u)
	{
		buffer.format_into_impl(indices, slices, arg_ptrs);
	}
	buffer.write_into(slices[args_count]);
}

function format_unchecked_fmt(fmt_str: consteval str, args: ...#const auto) -> string
{
	let buffer = format_buffer[ string() ];
	buffer.format_into(fmt_str, ...args);
	return buffer._str;
}

export function format(fmt_str: consteval str, args: ...#const auto) -> string
{
	(consteval check_fmt_str(fmt_str));
	return format_unchecked_fmt(fmt_str, ...args);
}

export function printf(fmt_str: consteval str, args: ...#const auto)
{
	(consteval check_fmt_str(fmt_str));
	let buf = format_buffer[ string() ];
	buf.format_into(fmt_str, ...args);
	print(buf._str.as_str());
}


function print_uint_to_reverse_buffer(it: *uint8, val: uint64, base: consteval uint64) -> *uint8
{
	if (val == 0u)
	{
		--it;
		*it = '0' as uint32 as uint8;
		return it;
	}
	while (val != 0u)
	{
		const digit_val = val % base;
		val /= base;
		if (digit_val < 10u)
		{
			--it;
			*it = ('0' + digit_val) as uint32 as uint8;
		}
		else
		{
			--it;
			*it = ('a' + digit_val - 10u) as uint32 as uint8;
		}
	}
	return it;
}

function decimal_length_u64(n: uint64) -> uint32
{
	return if (n < 10u64) { 1u }
		else if (n < 100u64) { 2u }
		else if (n < 1000u64) { 3u }
		else if (n < 10000u64) { 4u }
		else if (n < 100000u64) { 5u }
		else if (n < 1000000u64) { 6u }
		else if (n < 10000000u64) { 7u }
		else if (n < 100000000u64) { 8u }
		else if (n < 1000000000u64) { 9u }
		else if (n < 10000000000u64) { 10u }
		else if (n < 100000000000u64) { 11u }
		else if (n < 1000000000000u64) { 12u }
		else if (n < 10000000000000u64) { 13u }
		else if (n < 100000000000000u64) { 14u }
		else if (n < 1000000000000000u64) { 15u }
		else if (n < 10000000000000000u64) { 16u }
		else if (n < 100000000000000000u64) { 17u }
		else if (n < 1000000000000000000u64) { 18u }
		else if (n < 10000000000000000000u64) { 19u }
		else { 20u };
}

function print_uint_to_buffer(n: uint64, out: *uint8) -> *uint8
{
	const output_len = decimal_length_u64(n);
	let rev_out = out + output_len;
	// basically a copy of number printing in ryu::d2s
	while (n >= 10000u)
	{
		const c = n - 10000u * (n / 10000u);
		n /= 10000u;
		const c0 = (c % 100u) * 2u;
		const c1 = (c / 100u) * 2u;
		rev_out -= 4;
		memcpy(rev_out + 2, ryu::DIGIT_TABLE.begin() + c0, 2u);
		memcpy(rev_out,     ryu::DIGIT_TABLE.begin() + c1, 2u);
	}
	if (n >= 100u)
	{
		const c = (n % 100u) * 2u;
		n /= 100u;
		rev_out -= 2;
		memcpy(rev_out, ryu::DIGIT_TABLE.begin() + c, 2u);
	}
	if (n >= 10u)
	{
		const c = (n % 100u) * 2u;
		n /= 100u;
		rev_out -= 2;
		memcpy(rev_out, ryu::DIGIT_TABLE.begin() + c, 2u);
	}
	else
	{
		rev_out -= 1;
		*rev_out = ('0' + n) as uint32 as uint8;
	}
	return out + output_len;
}

consteval max_uint_string_length = 20uz;
static_assert(max_uint_string_length == {
	let uint64_max = ~0u64;
	let result = 0uz;
	while (uint64_max != 0u)
	{
		uint64_max /= 10u;
		++result;
	}
	result
});

function get_uint_as_string(n: uint64) -> [[max_uint_string_length: uint8], uint32]
{
	let result: [[max_uint_string_length: uint8], uint32];
	const end = print_uint_to_buffer(n, result[0].begin());
	result[1] = (end - result[0].begin()) as uint32;
	return result;
}

consteval max_int_string_length = 20uz;
static_assert(max_int_string_length == {
	// this is actually -int64_min, but its absolute value is larger than int64_max, so we use this instead
	let int64_max = 1u64 << 63u;
	let result = 0uz;
	while (int64_max != 0u)
	{
		int64_max /= 10u;
		++result;
	}
	result + 1u
});

function get_int_as_string(abs_val: uint64, is_negative: bool) -> [[max_int_string_length: uint8], uint32]
{
	let result: [[max_int_string_length: uint8], uint32];
	let out = result[0].begin();
	if (is_negative)
	{
		*out = '-' as uint32 as uint8;
		++out;
	}
	const end = print_uint_to_buffer(abs_val, out);
	result[1] = (end - result[0].begin()) as uint32;
	return result;
}

function format_to(s: str, buffer: &format_buffer)
{
	buffer.write_into(s);
}

function format_to(c: char, buffer: &format_buffer)
{
	buffer.write_into(c);
}

function format_to(n: uint64, buffer: &format_buffer)
{
	const [result_buffer, size] = get_uint_as_string(n);
	const result_str = __builtin_str_from_ptrs(result_buffer.begin(), result_buffer.begin() + size);
	buffer.write_into(result_str);
}

function format_to(n: int64, buffer: &format_buffer)
{
	// -n as uint64 works for int64_min
	const [result_buffer, size] = get_int_as_string(if (n < 0) { -n as uint64 } else { n as uint64 }, n < 0);
	const result_str = __builtin_str_from_ptrs(result_buffer.begin(), result_buffer.begin() + size);
	buffer.write_into(result_str);
}

function format_to(p: *const void, buffer: &format_buffer)
{
	const val = __builtin_pointer_to_int(p);
	static_assert(typeof val == const uint64);
	let result_buffer: [2 + 16: uint8];
	let it = print_uint_to_reverse_buffer(result_buffer.end(), val, 16u);
	--it;
	*it = 'x' as uint32 as uint8;
	--it;
	*it = '0' as uint32 as uint8;
	const result_str = __builtin_str_from_ptrs(it, result_buffer.end());
	buffer.write_into(result_str);
}

function format_to(b: bool, buffer: &format_buffer)
{
	if (b)
	{
		buffer.write_into("true");
	}
	else
	{
		buffer.write_into("false");
	}
}

function format_to(x: float32, buffer: &format_buffer)
{
	let result_buffer: [15: uint8];
	const end = ryu::f2s_shortest(x, result_buffer.begin());
	const s = __builtin_str_from_ptrs(result_buffer.begin(), end);
	buffer.write_into(s);
}

function format_to(x: float64, buffer: &format_buffer)
{
	let result_buffer: [24: uint8];
	const end = ryu::d2s_shortest(x, result_buffer.begin());
	const s = __builtin_str_from_ptrs(result_buffer.begin(), end);
	buffer.write_into(s);
}

function format_to(arr: [: const auto], buffer: &format_buffer)
{
	let it = arr.begin();
	const end = arr.end();

	if (it == end)
	{
		buffer.write_into("[]");
		return;
	}

	buffer.write_into("[ ");

	buffer.format_into("{}", *it);
	++it;
	for (; it != end; ++it)
	{
		buffer.write_into(", ");
		(*it).format_to(buffer);
	}

	buffer.write_into(" ]");
}

function tuple_format_to_impl(buffer: &format_buffer, [first])
{
	buffer.format_into("{}", *first);
}

function tuple_format_to_impl(buffer: &format_buffer, [first, second, ...rest])
{
	buffer.format_into("{}, ", *first);
	tuple_format_to_impl(buffer, [ second, ...rest ]);
}

function format_to([...elems], buffer: &format_buffer)
{
	buffer.write_into("[ ");
	tuple_format_to_impl(buffer, [ ...&elems ]);
	buffer.write_into(" ]");
}
