import string;
import print;
import utils;
import ryu::d2s;
import ryu::f2s;
import ryu::digit_table;
import meta::comptime;

export struct format_buffer
{
	._str: string;
}

export function write_into(buffer: &format_buffer, s: str)
{
	buffer._str ..= s;
}

export function write_into(buffer: &format_buffer, c: char)
{
	buffer._str ..= c;
}

export struct format_spec
{
	.fill: char;
	.align: char;
	.sign: char;
	.fmt_kind: char;
	.width: usize;
	.precision: usize;
	.zero_pad: bool;
}

export consteval precision_none = ((-1 as usize));

export function get_default_format_spec() -> format_spec
{
	return format_spec[ '\x00', '\x00', '\x00', '\x00', 0uz, precision_none, false ];
}

consteval function find_next_bracket(it: *const uint8, end: *const uint8) -> *const uint8
{
	for (; it != end; ++it)
	{
		if (*it == '{' as uint32 && (it + 1 == end || *(it + 1) != '{' as uint32))
		{
			return it;
		}
		else if (*it == '{' as uint32)
		{
			// next character must be '{' and can't be the end, so we can safely skip it
			++it;
		}
		else if (*it == '}' as uint32 && (it + 1 == end || *(it + 1) != '}' as uint32))
		{
			return it;
		}
		else if (*it == '}' as uint32)
		{
			// next character must be '}' and can't be the end, so we can safely skip it
			++it;
		}
	}

	return end;
}

consteval function string_contains(s: str, c: char) -> bool
{
	assert(c <= '\x7f');
	let it = s.begin_ptr();
	const end = s.end_ptr();
	for (; it != end; ++it)
	{
		if (*it == c as uint32)
		{
			return true;
		}
	}
	return false;
}

consteval function string_find(s: str, c: char) -> *const uint8
{
	assert(c <= '\x7f');
	let it = s.begin_ptr();
	const end = s.end_ptr();
	for (; it != end; ++it)
	{
		if (*it == c as uint32)
		{
			return it;
		}
	}
	return end;
}

consteval function check_format_spec_str(it: *const uint8, end: *const uint8, fmt_str: str)
{
	assert(it > fmt_str.begin_ptr());
	assert(it < fmt_str.end_ptr());
	const open_bracket_it = it - 1;
	assert(*open_bracket_it == '{' as uint32);
	if (it == end)
	{
		return;
	}

	if (*it != ':' as uint32)
	{
		const position = __builtin_str_from_ptrs(fmt_str.begin_ptr(), open_bracket_it).length();
		const message = format_unchecked_fmt(
			"invalid format string '{}'; expected ':' or '}}' after '{{' at position {} ('{}')",
			fmt_str, position, __builtin_str_from_ptrs(open_bracket_it, fmt_str.end_ptr())
		);
		meta::compile_error(message.as_str());
		return;
	}
	++it; // ':'
	if (it == end)
	{
		return;
	}
	// syntax: [[fill]align][sign][0][width][.precision][kind]
	function is_valid_align(c: char) -> bool
	{
		return c == '<' || c == '^' || c == '>';
	}
	function is_valid_sign(c: char) -> bool
	{
		return c == '+' || c == '-' || c == ' ';
	}
	function advance_number(it: &*const uint8, end: *const uint8)
	{
		while (it != end && {
			const c = *it as uint32 as char;
			c >= '0' && c <= '9'
		})
		{
			++it;
		}
	}

	if (it + 1 != end && is_valid_align(*(it + 1) as uint32 as char))
	{
		++it; // fill
		++it; // align
	}
	else if (is_valid_align(*it as uint32 as char))
	{
		++it; // align
	}

	if (it != end && is_valid_sign(*it as uint32 as char))
	{
		++it; // sign
	}
	advance_number(it, end); // [0][width]
	if (it != end && *it == '.' as uint32)
	{
		++it; // '.'
		if (it == end || {
			const c = *it as uint32 as char;
			c < '0' || c > '9'
		})
		{
			const dot_it = it - 1;
			const position = __builtin_str_from_ptrs(fmt_str.begin_ptr(), dot_it).length();
			const message = format_unchecked_fmt(
				"invalid format string '{}'; expected a number after '.' at position {} ('{}')",
				fmt_str, position, __builtin_str_from_ptrs(dot_it, fmt_str.end_ptr())
			);
			meta::compile_error(message.as_str());
			return;
		}
		advance_number(it, end); // precision
	}
	if (it != end && {
		const c = *it as uint32 as char;
		(c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')
	})
	{
		++it; // kind
	}

	if (it != end)
	{
		const position = __builtin_str_from_ptrs(fmt_str.begin_ptr(), it).length();
		const unexpected_chars = __builtin_str_from_ptrs(it, end);
		const message = format_unchecked_fmt(
			"invalid format string '{}'; unexpected characters '{}' at position {} ('{}')",
			fmt_str, unexpected_chars, position, __builtin_str_from_ptrs(it, fmt_str.end_ptr())
		);
		meta::compile_error(message.as_str());
		return;
	}
}

consteval function check_fmt_str(fmt_str: str)
{
	const begin = fmt_str.begin_ptr();
	const end   = fmt_str.end_ptr();
	let it = begin;

	while (true)
	{
		const next_bracket = find_next_bracket(it, end);
		if (next_bracket == end)
		{
			// break if we reached the end
			break;
		}

		switch (*next_bracket as uint32 as char)
		{
			'}' => {
				// stray closing bracket, report only as a warning
				it = next_bracket + 1;
				const position = __builtin_str_from_ptrs(begin, next_bracket).length();
				const message = format_unchecked_fmt(
					"invalid format string '{}'; stray '}}' at position {} ('{}')",
					fmt_str, position, __builtin_str_from_ptrs(next_bracket, end)
				);
				meta::compile_warning(message.as_str());
			},
			'{' => {
				it = next_bracket + 1;
				if (it == end || !string_contains(__builtin_str_from_ptrs(it, end), '}'))
				{
					const position = __builtin_str_from_ptrs(begin, next_bracket).length();
					const message = format_unchecked_fmt(
						"invalid format string '{}'; unclosed '{{' at position {} ('{}')",
						fmt_str, position, __builtin_str_from_ptrs(next_bracket, end)
					);
					meta::compile_error(message.as_str());
					return;
				}
				const closing_bracket_it = string_find(__builtin_str_from_ptrs(it, end), '}');
				assert(closing_bracket_it != end);
				check_format_spec_str(it, closing_bracket_it, fmt_str);
				it = closing_bracket_it + 1;
			},
			else => unreachable
		}
	}
}

consteval function count_args_in_str(fmt_str: str) -> usize
{
	let it = fmt_str.begin_ptr();
	const end = fmt_str.end_ptr();

	let result = 0uz;
	while (true)
	{
		const next_bracket = find_next_bracket(it, end);
		if (next_bracket == end)
		{
			break;
		}
		else if (*next_bracket == '{' as uint32)
		{
			++result;
		}
		it = next_bracket + 1;
	}
	return result;
}

consteval function remove_escaped_brackets(s: str) -> str
{
	let result = string();
	result.reserve(s.size());

	let it = s.begin_ptr();
	let prev_begin = it;
	const end = s.end_ptr();
	for (; it != end; ++it)
	{
		if (
			(*it == '{' as uint32 && it + 1 != end && *(it + 1) == '{' as uint32)
			|| (*it == '}' as uint32 && it + 1 != end && *(it + 1) == '}' as uint32)
		)
		{
			// escaped '{' or '}'
			result ..= __builtin_str_from_ptrs(prev_begin, it + 1);
			prev_begin = it + 2;
			// second increment will happen at end of the for loop
			++it;
		}
	}
	result ..= __builtin_str_from_ptrs(prev_begin, end);

	return result.as_str().meta::create_global_string();
}

consteval function get_slices(fmt_str: str, out: [: str])
{
	let it = fmt_str.begin_ptr();
	let prev_begin = it;
	const end = fmt_str.end_ptr();
	let index = 0uz;

	let contains_escaped_bracket = false;
	for (; it != end; ++it)
	{
		if (
			(*it == '{' as uint32 && it + 1 != end && *(it + 1) == '{' as uint32)
			|| (*it == '}' as uint32 && it + 1 != end && *(it + 1) == '}' as uint32)
		)
		{
			// escaped '{' or '}'
			// second increment will happen at end of the for loop
			++it;
			contains_escaped_bracket = true;
		}
		else if (*it == '{' as uint32)
		{
			if (contains_escaped_bracket)
			{
				const s = __builtin_str_from_ptrs(prev_begin, it);
				out[index] = remove_escaped_brackets(s);
			}
			else
			{
				out[index] = __builtin_str_from_ptrs(prev_begin, it);
			}
			contains_escaped_bracket = false; // reset value
			index += 1u;
			const closing_bracket_it = string_find(__builtin_str_from_ptrs(it, end), '}');
			assert(closing_bracket_it != end);
			prev_begin = closing_bracket_it + 1;
			// other increment will happen at the next start of the loop
			it = closing_bracket_it;
		}
	}
	out[index] = __builtin_str_from_ptrs(prev_begin, it);
}

consteval function get_slices(fmt_str: str, args_count: consteval usize) -> [args_count + 1u: str]
{
	let result: [args_count + 1u: str];
	get_slices(fmt_str, result);
	return result;
}

consteval function get_indices(start: consteval usize, end: consteval usize) -> [(if (end - start == 0u) { 1u } else { end - start }): usize]
{
	let result: [(if (end - start == 0u) { 1u } else { end - start }): usize];
	for (let [i, counter] = [ 0uz, start]; counter != end; ++i, ++counter)
	{
		result[i] = counter;
	}
	return result;
}

function format_into_impl(buffer: &format_buffer, index: consteval [1: usize], slices: [: const str], arg_ptrs: &const [...*const auto])
{
	consteval index = index[0];
	buffer.write_into(slices[index]);
	assert(arg_ptrs[index] != null);
	arg_ptrs[index]->format_to(buffer);
}

function format_into_impl(buffer: &format_buffer, indices: consteval auto, slices: [: const str], arg_ptrs: &const [...*const auto])
{
	consteval index = indices[0];
	buffer.write_into(slices[index]);
	arg_ptrs[index]->format_to(buffer);
	consteval rest_indices = get_indices(indices[1], indices[indices.size() - 1u] + 1u);
	buffer.format_into_impl(rest_indices, slices, arg_ptrs);
}

export function format_into(buffer: &format_buffer, fmt_str: consteval str, args: ...#const auto)
{
	const arg_ptrs = [ ...&args, null as *const int32 ];
	consteval args_count = count_args_in_str(fmt_str);
	consteval indices = get_indices(0uz, args_count);
	consteval slices = get_slices(fmt_str, args_count);
	if (slices.size() > 1u)
	{
		buffer.format_into_impl(indices, slices, arg_ptrs);
	}
	buffer.write_into(slices[args_count]);
}

function format_unchecked_fmt(fmt_str: consteval str, args: ...#const auto) -> string
{
	let buffer = format_buffer[ string() ];
	buffer.format_into(fmt_str, ...args);
	return buffer._str;
}

export function format(fmt_str: consteval str, args: ...#const auto) -> string
{
	(consteval check_fmt_str(fmt_str));
	return format_unchecked_fmt(fmt_str, ...args);
}

export function printf(fmt_str: consteval str, args: ...#const auto)
{
	(consteval check_fmt_str(fmt_str));
	let buf = format_buffer[ string() ];
	buf.format_into(fmt_str, ...args);
	print(buf._str.as_str());
}


function print_uint_to_reverse_buffer(it: *uint8, val: uint64, base: consteval uint64) -> *uint8
{
	if (val == 0u)
	{
		--it;
		*it = '0' as uint32 as uint8;
		return it;
	}
	while (val != 0u)
	{
		const digit_val = val % base;
		val /= base;
		if (digit_val < 10u)
		{
			--it;
			*it = ('0' + digit_val) as uint32 as uint8;
		}
		else
		{
			--it;
			*it = ('a' + digit_val - 10u) as uint32 as uint8;
		}
	}
	return it;
}

function decimal_length_u64(n: uint64) -> uint32
{
	return if (n < 10u64) { 1u }
		else if (n < 100u64) { 2u }
		else if (n < 1000u64) { 3u }
		else if (n < 10000u64) { 4u }
		else if (n < 100000u64) { 5u }
		else if (n < 1000000u64) { 6u }
		else if (n < 10000000u64) { 7u }
		else if (n < 100000000u64) { 8u }
		else if (n < 1000000000u64) { 9u }
		else if (n < 10000000000u64) { 10u }
		else if (n < 100000000000u64) { 11u }
		else if (n < 1000000000000u64) { 12u }
		else if (n < 10000000000000u64) { 13u }
		else if (n < 100000000000000u64) { 14u }
		else if (n < 1000000000000000u64) { 15u }
		else if (n < 10000000000000000u64) { 16u }
		else if (n < 100000000000000000u64) { 17u }
		else if (n < 1000000000000000000u64) { 18u }
		else if (n < 10000000000000000000u64) { 19u }
		else { 20u };
}

function print_uint_to_buffer(n: uint64, out: *uint8) -> *uint8
{
	const output_len = decimal_length_u64(n);
	let rev_out = out + output_len;
	// basically a copy of number printing in ryu::d2s
	while (n >= 10000u)
	{
		const c = n - 10000u * (n / 10000u);
		n /= 10000u;
		const c0 = (c % 100u) * 2u;
		const c1 = (c / 100u) * 2u;
		rev_out -= 4;
		memcpy(rev_out + 2, ryu::DIGIT_TABLE.begin() + c0, 2u);
		memcpy(rev_out,     ryu::DIGIT_TABLE.begin() + c1, 2u);
	}
	if (n >= 100u)
	{
		const c = (n % 100u) * 2u;
		n /= 100u;
		rev_out -= 2;
		memcpy(rev_out, ryu::DIGIT_TABLE.begin() + c, 2u);
	}
	if (n >= 10u)
	{
		const c = (n % 100u) * 2u;
		n /= 100u;
		rev_out -= 2;
		memcpy(rev_out, ryu::DIGIT_TABLE.begin() + c, 2u);
	}
	else
	{
		rev_out -= 1;
		*rev_out = ('0' + n) as uint32 as uint8;
	}
	return out + output_len;
}

consteval max_uint_string_length = 20uz;
static_assert(max_uint_string_length == {
	let uint64_max = ~0u64;
	let result = 0uz;
	while (uint64_max != 0u)
	{
		uint64_max /= 10u;
		++result;
	}
	result
});

function get_uint_as_string(n: uint64) -> [[max_uint_string_length: uint8], uint32]
{
	let result: [[max_uint_string_length: uint8], uint32];
	const end = print_uint_to_buffer(n, result[0].begin());
	result[1] = (end - result[0].begin()) as uint32;
	return result;
}

consteval max_int_string_length = 20uz;
static_assert(max_int_string_length == {
	// this is actually -int64_min, but its absolute value is larger than int64_max, so we use this instead
	let int64_max = 1u64 << 63u;
	let result = 0uz;
	while (int64_max != 0u)
	{
		int64_max /= 10u;
		++result;
	}
	result + 1u
});

function get_int_as_string(abs_val: uint64, is_negative: bool) -> [[max_int_string_length: uint8], uint32]
{
	let result: [[max_int_string_length: uint8], uint32];
	let out = result[0].begin();
	if (is_negative)
	{
		*out = '-' as uint32 as uint8;
		++out;
	}
	const end = print_uint_to_buffer(abs_val, out);
	result[1] = (end - result[0].begin()) as uint32;
	return result;
}

export function format_to(s: str, buffer: &format_buffer)
{
	buffer.write_into(s);
}

export function format_to(c: char, buffer: &format_buffer)
{
	buffer.write_into(c);
}

export function format_to(n: uint64, buffer: &format_buffer)
{
	const [result_buffer, size] = get_uint_as_string(n);
	const result_str = __builtin_str_from_ptrs(result_buffer.begin(), result_buffer.begin() + size);
	buffer.write_into(result_str);
}

export function format_to(n: int64, buffer: &format_buffer)
{
	// -n as uint64 works for int64_min
	const [result_buffer, size] = get_int_as_string(if (n < 0) { -n as uint64 } else { n as uint64 }, n < 0);
	const result_str = __builtin_str_from_ptrs(result_buffer.begin(), result_buffer.begin() + size);
	buffer.write_into(result_str);
}

export function format_to(p: *const void, buffer: &format_buffer)
{
	const val = __builtin_pointer_to_int(p);
	static_assert(typeof val == const uint64);
	let result_buffer: [2 + 16: uint8];
	let it = print_uint_to_reverse_buffer(result_buffer.end(), val, 16u);
	--it;
	*it = 'x' as uint32 as uint8;
	--it;
	*it = '0' as uint32 as uint8;
	const result_str = __builtin_str_from_ptrs(it, result_buffer.end());
	buffer.write_into(result_str);
}

export function format_to(b: bool, buffer: &format_buffer)
{
	if (b)
	{
		buffer.write_into("true");
	}
	else
	{
		buffer.write_into("false");
	}
}

export function format_to(x: float32, buffer: &format_buffer)
{
	let result_buffer: [15: uint8];
	const end = ryu::f2s_shortest(x, result_buffer.begin());
	const s = __builtin_str_from_ptrs(result_buffer.begin(), end);
	buffer.write_into(s);
}

export function format_to(x: float64, buffer: &format_buffer)
{
	let result_buffer: [24: uint8];
	const end = ryu::d2s_shortest(x, result_buffer.begin());
	const s = __builtin_str_from_ptrs(result_buffer.begin(), end);
	buffer.write_into(s);
}

export function format_to(arr: [: const auto], buffer: &format_buffer)
{
	let it = arr.begin();
	const end = arr.end();

	if (it == end)
	{
		buffer.write_into("[]");
		return;
	}

	buffer.write_into("[ ");

	buffer.format_into("{}", *it);
	++it;
	for (; it != end; ++it)
	{
		buffer.write_into(", ");
		it->format_to(buffer);
	}

	buffer.write_into(" ]");
}

function tuple_format_to_impl(buffer: &format_buffer, [first])
{
	buffer.format_into("{}", *first);
}

function tuple_format_to_impl(buffer: &format_buffer, [first, second, ...rest])
{
	buffer.format_into("{}, ", *first);
	tuple_format_to_impl(buffer, [ second, ...rest ]);
}

export function format_to(&const [...elems], buffer: &format_buffer)
{
	buffer.write_into("[ ");
	tuple_format_to_impl(buffer, [ ...&elems ]);
	buffer.write_into(" ]");
}
