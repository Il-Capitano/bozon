import string;
import print;
import utils;
import unicode;
import bit;
import ryu::d2s;
import ryu::f2s;
import ryu::digit_table;
import meta::comptime;

export struct format_buffer
{
	._str: string;
}

export function write_into(buffer: &format_buffer, s: str)
{
	buffer._str ..= s;
}

export function write_into(buffer: &format_buffer, c: char)
{
	buffer._str ..= c;
}

export function write_into(buffer: &format_buffer, c: char, count: usize)
{
	const size = buffer._str.size();
	if (c <= '\x7f')
	{
		buffer._str.resize(size + count, c);
	}
	else
	{
		const [encoded_char, byte_count] = encode_char_utf8(c);
		buffer._str.resize(size + count * byte_count);
		let it = buffer._str.data() + size;
		for (let i = 0uz; i < count; ++i)
		{
			memcpy(it, encoded_char.begin(), byte_count);
			it += byte_count;
		}
	}
}

export struct format_spec
{
	.fill: char;
	.align: char;
	.sign: char;
	.fmt_kind: char;
	.width: usize;
	.precision: usize;
	.zero_pad: bool;
}

export consteval precision_none = ((-1 as usize));

export function get_default_format_spec() -> format_spec
{
	return format_spec[ '\x00', '\x00', '\x00', '\x00', 0uz, precision_none, false ];
}

function is_valid_align(c: char) -> bool
{
	return c == '<' || c == '^' || c == '>';
}

function is_valid_sign(c: char) -> bool
{
	return c == '+' || c == '-' || c == ' ';
}

function is_number(c: char) -> bool
{
	return c >= '0' && c <= '9';
}

export function get_default_format_spec(fmt_spec: str) -> format_spec
{
	let result = get_default_format_spec();
	// syntax: [[fill]align][sign][0][width][.precision][kind]
	function get_number(it: &*const uint8, end: *const uint8) -> usize
	{
		let result = 0uz;
		while (it != end && {
			const c = *it as uint32 as char;
			c >= '0' && c <= '9'
		})
		{
			result *= 10u;
			result += (*it as uint32 as char - '0') as uint32;
			++it;
		}
		return result;
	}

	let it = fmt_spec.begin_ptr();
	const end = fmt_spec.end_ptr();

	if (it == end)
	{
		return result;
	}
	else if (it + 1 != end && is_valid_align(*(it + 1) as uint32 as char))
	{
		result.fill = *it as uint32 as char;
		++it; // fill
		result.align = *it as uint32 as char;
		++it; // align
	}
	else if (is_valid_align(*it as uint32 as char))
	{
		result.align = *it as uint32 as char;
		++it; // align
	}

	if (it != end && is_valid_sign(*it as uint32 as char))
	{
		result.sign = *it as uint32 as char;
		++it; // sign
	}
	if (it != end && *it == '0' as uint32)
	{
		result.zero_pad = true;
		++it;
	}
	if (it != end && is_number(*it as uint32 as char))
	{
		result.width = get_number(it, end);
	}
	if (it != end && *it == '.' as uint32)
	{
		++it; // '.'
		result.precision = get_number(it, end);
	}
	if (it != end && {
		const c = *it as uint32 as char;
		(c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')
	})
	{
		result.fmt_kind = *it as uint32 as char;
		++it; // kind
	}

	return result;
}

consteval function find_next_bracket(it: *const uint8, end: *const uint8) -> *const uint8
{
	for (; it != end; ++it)
	{
		if (*it == '{' as uint32 && (it + 1 == end || *(it + 1) != '{' as uint32))
		{
			return it;
		}
		else if (*it == '{' as uint32)
		{
			// next character must be '{' and can't be the end, so we can safely skip it
			++it;
		}
		else if (*it == '}' as uint32 && (it + 1 == end || *(it + 1) != '}' as uint32))
		{
			return it;
		}
		else if (*it == '}' as uint32)
		{
			// next character must be '}' and can't be the end, so we can safely skip it
			++it;
		}
	}

	return end;
}

consteval function string_contains(s: str, c: char) -> bool
{
	assert(c <= '\x7f');
	let it = s.begin_ptr();
	const end = s.end_ptr();
	for (; it != end; ++it)
	{
		if (*it == c as uint32)
		{
			return true;
		}
	}
	return false;
}

consteval function string_find(s: str, c: char) -> *const uint8
{
	assert(c <= '\x7f');
	let it = s.begin_ptr();
	const end = s.end_ptr();
	for (; it != end; ++it)
	{
		if (*it == c as uint32)
		{
			return it;
		}
	}
	return end;
}

consteval function check_format_spec_str(it: *const uint8, end: *const uint8, fmt_str: str)
{
	assert(it > fmt_str.begin_ptr());
	assert(it < fmt_str.end_ptr());
	const open_bracket_it = it - 1;
	assert(*open_bracket_it == '{' as uint32);
	if (it == end)
	{
		return;
	}

	if (*it != ':' as uint32)
	{
		const position = __builtin_str_from_ptrs(fmt_str.begin_ptr(), open_bracket_it).length();
		const message = format_unchecked_fmt(
			"invalid format string '{}'; expected ':' or '}}' after '{{' at position {} ('{}')",
			fmt_str, position, __builtin_str_from_ptrs(open_bracket_it, fmt_str.end_ptr())
		);
		meta::compile_error(message.as_str());
		return;
	}
	++it; // ':'
	if (it == end)
	{
		return;
	}
	// syntax: [[fill]align][sign][0][width][.precision][kind]
	function advance_number(it: &*const uint8, end: *const uint8)
	{
		while (it != end && {
			const c = *it as uint32 as char;
			c >= '0' && c <= '9'
		})
		{
			++it;
		}
	}

	if (it + 1 != end && is_valid_align(*(it + 1) as uint32 as char))
	{
		++it; // fill
		++it; // align
	}
	else if (is_valid_align(*it as uint32 as char))
	{
		++it; // align
	}

	if (it != end && is_valid_sign(*it as uint32 as char))
	{
		++it; // sign
	}
	advance_number(it, end); // [0][width]
	if (it != end && *it == '.' as uint32)
	{
		++it; // '.'
		if (it == end || {
			const c = *it as uint32 as char;
			c < '0' || c > '9'
		})
		{
			const dot_it = it - 1;
			const position = __builtin_str_from_ptrs(fmt_str.begin_ptr(), dot_it).length();
			const message = format_unchecked_fmt(
				"invalid format string '{}'; expected a number after '.' at position {} ('{}')",
				fmt_str, position, __builtin_str_from_ptrs(dot_it, fmt_str.end_ptr())
			);
			meta::compile_error(message.as_str());
			return;
		}
		advance_number(it, end); // precision
	}
	if (it != end && {
		const c = *it as uint32 as char;
		(c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')
	})
	{
		++it; // kind
	}

	if (it != end)
	{
		const position = __builtin_str_from_ptrs(fmt_str.begin_ptr(), it).length();
		const unexpected_chars = __builtin_str_from_ptrs(it, end);
		const fmt_str_end = __builtin_str_from_ptrs(it, fmt_str.end_ptr());
		const message = format_unchecked_fmt(
			"invalid format string '{}'; unexpected characters '{}' at position {} ('{}')",
			fmt_str, unexpected_chars, position, fmt_str_end
		);
		meta::compile_error(message.as_str());
		return;
	}
}

consteval function check_fmt_str(fmt_str: str)
{
	const begin = fmt_str.begin_ptr();
	const end   = fmt_str.end_ptr();
	let it = begin;

	while (true)
	{
		const next_bracket = find_next_bracket(it, end);
		if (next_bracket == end)
		{
			// break if we reached the end
			break;
		}

		switch (*next_bracket as uint32 as char)
		{
			'}' => {
				// stray closing bracket, report only as a warning
				it = next_bracket + 1;
				const position = __builtin_str_from_ptrs(begin, next_bracket).length();
				const message = format_unchecked_fmt(
					"invalid format string '{}'; stray '}}' at position {} ('{}')",
					fmt_str, position, __builtin_str_from_ptrs(next_bracket, end)
				);
				meta::compile_warning(message.as_str());
			},
			'{' => {
				it = next_bracket + 1;
				if (it == end || !string_contains(__builtin_str_from_ptrs(it, end), '}'))
				{
					const position = __builtin_str_from_ptrs(begin, next_bracket).length();
					const message = format_unchecked_fmt(
						"invalid format string '{}'; unclosed '{{' at position {} ('{}')",
						fmt_str, position, __builtin_str_from_ptrs(next_bracket, end)
					);
					meta::compile_error(message.as_str());
					return;
				}
				const closing_bracket_it = string_find(__builtin_str_from_ptrs(it, end), '}');
				assert(closing_bracket_it != end);
				check_format_spec_str(it, closing_bracket_it, fmt_str);
				it = closing_bracket_it + 1;
			},
			else => unreachable
		}
	}
}

consteval function count_args_in_str(fmt_str: str) -> usize
{
	let it = fmt_str.begin_ptr();
	const end = fmt_str.end_ptr();

	let result = 0uz;
	while (true)
	{
		const next_bracket = find_next_bracket(it, end);
		if (next_bracket == end)
		{
			break;
		}
		else if (*next_bracket == '{' as uint32)
		{
			++result;
		}
		it = next_bracket + 1;
	}
	return result;
}

consteval function remove_escaped_brackets(s: str) -> str
{
	let result = string();
	result.reserve(s.size());

	let it = s.begin_ptr();
	let prev_begin = it;
	const end = s.end_ptr();
	for (; it != end; ++it)
	{
		if (
			(*it == '{' as uint32 && it + 1 != end && *(it + 1) == '{' as uint32)
			|| (*it == '}' as uint32 && it + 1 != end && *(it + 1) == '}' as uint32)
		)
		{
			// escaped '{' or '}'
			result ..= __builtin_str_from_ptrs(prev_begin, it + 1);
			prev_begin = it + 2;
			// second increment will happen at end of the for loop
			++it;
		}
	}
	result ..= __builtin_str_from_ptrs(prev_begin, end);

	return result.as_str().meta::create_global_string();
}

consteval function get_fmt_spec(inner_str: str) -> str
{
	if (inner_str == "")
	{
		return "";
	}
	assert(inner_str.starts_with(":"));
	return __builtin_str_from_ptrs(inner_str.begin_ptr() + 1, inner_str.end_ptr());
}

consteval function get_slices_and_fmt_specs(fmt_str: str, slices: [: str], fmt_specs: [: str])
{
	let it = fmt_str.begin_ptr();
	let prev_begin = it;
	const end = fmt_str.end_ptr();
	let index = 0uz;

	let contains_escaped_bracket = false;
	for (; it != end; ++it)
	{
		if (
			(*it == '{' as uint32 && it + 1 != end && *(it + 1) == '{' as uint32)
			|| (*it == '}' as uint32 && it + 1 != end && *(it + 1) == '}' as uint32)
		)
		{
			// escaped '{' or '}'
			// second increment will happen at end of the for loop
			++it;
			contains_escaped_bracket = true;
		}
		else if (*it == '{' as uint32)
		{
			if (contains_escaped_bracket)
			{
				const s = __builtin_str_from_ptrs(prev_begin, it);
				slices[index] = remove_escaped_brackets(s);
			}
			else
			{
				slices[index] = __builtin_str_from_ptrs(prev_begin, it);
			}
			const closing_bracket_it = string_find(__builtin_str_from_ptrs(it, end), '}');
			assert(closing_bracket_it != end);
			fmt_specs[index] = get_fmt_spec(__builtin_str_from_ptrs(it + 1, closing_bracket_it));

			contains_escaped_bracket = false; // reset value
			index += 1u;
			prev_begin = closing_bracket_it + 1;
			// other increment will happen at the next start of the loop
			it = closing_bracket_it;
		}
	}
	slices[index] = __builtin_str_from_ptrs(prev_begin, it);
}

consteval function get_slices_and_fmt_specs(fmt_str: str, args_count: consteval usize)
	-> [[args_count + 1u: str], [if (args_count == 0u) { 1u } else { args_count }: str]]
{
	let result: [[args_count + 1u: str], [if (args_count == 0u) { 1u } else { args_count }: str]];
	get_slices_and_fmt_specs(fmt_str, result[0], result[1]);
	return result;
}

consteval function get_indices(start: consteval usize, end: consteval usize) -> [(if (end - start == 0u) { 1u } else { end - start }): usize]
{
	let result: [(if (end - start == 0u) { 1u } else { end - start }): usize];
	for (let [i, counter] = [ 0uz, start]; counter != end; ++i, ++counter)
	{
		result[i] = counter;
	}
	return result;
}

function format_into_impl(
	buffer: &format_buffer,
	index: consteval [1: usize],
	slices: [: const str],
	fmt_specs: [: const str],
	arg_ptrs: &const [...*const auto]
)
{
	consteval index = index[0];
	buffer.write_into(slices[index]);
	assert(arg_ptrs[index] != null);
	arg_ptrs[index]->format_to(buffer, fmt_specs[index]);
}

function format_into_impl(
	buffer: &format_buffer,
	indices: consteval auto,
	slices: [: const str],
	fmt_specs: [: const str],
	arg_ptrs: &const [...*const auto]
)
{
	consteval index = indices[0];
	buffer.write_into(slices[index]);
	arg_ptrs[index]->format_to(buffer, fmt_specs[index]);
	consteval rest_indices = get_indices(indices[1], indices[indices.size() - 1u] + 1u);
	buffer.format_into_impl(rest_indices, slices, fmt_specs, arg_ptrs);
}

export function format_into(buffer: &format_buffer, fmt_str: consteval str, args: ...#const auto)
{
	const arg_ptrs = [ ...&args, null as *const int32 ];
	consteval args_count = count_args_in_str(fmt_str);
	consteval indices = get_indices(0uz, args_count);
	consteval [slices, fmt_specs] = get_slices_and_fmt_specs(fmt_str, args_count);
	if (slices.size() > 1u)
	{
		buffer.format_into_impl(indices, slices, fmt_specs, arg_ptrs);
	}
	buffer.write_into(slices[args_count]);
}

function format_unchecked_fmt(fmt_str: consteval str, args: ...#const auto) -> string
{
	let buffer = format_buffer[ string() ];
	buffer.format_into(fmt_str, ...args);
	return buffer._str;
}

export function format(fmt_str: consteval str, args: ...#const auto) -> string
{
	(consteval check_fmt_str(fmt_str));
	return format_unchecked_fmt(fmt_str, ...args);
}

export function printf(fmt_str: consteval str, args: ...#const auto)
{
	(consteval check_fmt_str(fmt_str));
	let buf = format_buffer[ string() ];
	buf.format_into(fmt_str, ...args);
	print(buf._str.as_str());
}


function print_uint_to_reverse_buffer(it: *uint8, val: uint64, base: consteval uint64) -> *uint8
{
	if (val == 0u)
	{
		--it;
		*it = '0' as uint32 as uint8;
		return it;
	}
	while (val != 0u)
	{
		const digit_val = val % base;
		val /= base;
		if (digit_val < 10u)
		{
			--it;
			*it = ('0' + digit_val) as uint32 as uint8;
		}
		else
		{
			--it;
			*it = ('a' + digit_val - 10u) as uint32 as uint8;
		}
	}
	return it;
}

function decimal_length_u64(n: uint64) -> uint32
{
	return if (n < 10u64) { 1u }
		else if (n < 100u64) { 2u }
		else if (n < 1000u64) { 3u }
		else if (n < 10000u64) { 4u }
		else if (n < 100000u64) { 5u }
		else if (n < 1000000u64) { 6u }
		else if (n < 10000000u64) { 7u }
		else if (n < 100000000u64) { 8u }
		else if (n < 1000000000u64) { 9u }
		else if (n < 10000000000u64) { 10u }
		else if (n < 100000000000u64) { 11u }
		else if (n < 1000000000000u64) { 12u }
		else if (n < 10000000000000u64) { 13u }
		else if (n < 100000000000000u64) { 14u }
		else if (n < 1000000000000000u64) { 15u }
		else if (n < 10000000000000000u64) { 16u }
		else if (n < 100000000000000000u64) { 17u }
		else if (n < 1000000000000000000u64) { 18u }
		else if (n < 10000000000000000000u64) { 19u }
		else { 20u };
}

function print_uint_decimal_to_buffer(n: uint64, out: *uint8) -> *uint8
{
	const output_len = decimal_length_u64(n);
	let rev_out = out + output_len;
	// basically a copy of number printing in ryu::d2s
	while (n >= 10000u)
	{
		const c = n - 10000u * (n / 10000u);
		n /= 10000u;
		const c0 = (c % 100u) * 2u;
		const c1 = (c / 100u) * 2u;
		rev_out -= 4;
		memcpy(rev_out + 2, ryu::DIGIT_TABLE.begin() + c0, 2u);
		memcpy(rev_out,     ryu::DIGIT_TABLE.begin() + c1, 2u);
	}
	if (n >= 100u)
	{
		const c = (n % 100u) * 2u;
		n /= 100u;
		rev_out -= 2;
		memcpy(rev_out, ryu::DIGIT_TABLE.begin() + c, 2u);
	}
	if (n >= 10u)
	{
		const c = (n % 100u) * 2u;
		n /= 100u;
		rev_out -= 2;
		memcpy(rev_out, ryu::DIGIT_TABLE.begin() + c, 2u);
	}
	else
	{
		rev_out -= 1;
		*rev_out = ('0' + n) as uint32 as uint8;
	}
	return out + output_len;
}

function print_uint_base_to_buffer(n: uint64, out: *uint8, base: consteval uint64) -> *uint8
{
	if (n == 0u)
	{
		*out = '0' as uint32 as uint8;
		return out + 1;
	}
	static_assert(base == 2u || base == 8u);
	consteval bit_width = if (base == 2u) { 1u64 } else { 3u64 };
	consteval max_output_len = if (base == 2u) { 64u64 } else { 22u64 };
	const output_len = (max_output_len - clz(n) / bit_width) as int32;
	let i = output_len;
	while (i > 0)
	{
		--i;
		consteval mask = base - 1u;
		const c = '0' + ((n >> (i * bit_width as int32)) & mask);
		*(out + i) = c as uint32 as uint8;
	}
	return out + output_len;
}

function print_uint_hex_to_buffer(n: uint64, out: *uint8) -> *uint8
{
	if (n == 0u)
	{
		*out = '0' as uint32 as uint8;
		return out + 1;
	}
	const output_len = (16u - clz(n) / 4u) as int32;
	consteval table: [16: uint8] = [
		'0' as uint32 as uint8, '1' as uint32 as uint8,
		'2' as uint32 as uint8, '3' as uint32 as uint8,
		'4' as uint32 as uint8, '5' as uint32 as uint8,
		'6' as uint32 as uint8, '7' as uint32 as uint8,
		'8' as uint32 as uint8, '9' as uint32 as uint8,
		'a' as uint32 as uint8, 'b' as uint32 as uint8,
		'c' as uint32 as uint8, 'd' as uint32 as uint8,
		'e' as uint32 as uint8, 'f' as uint32 as uint8
	];
	let i = output_len;
	while (i > 0)
	{
		--i;
		const c = table[(n >> (i * 4)) & 0b1111u64];
		*(out + i) = c;
	}
	return out + output_len;
}

function print_uint_HEX_to_buffer(n: uint64, out: *uint8) -> *uint8
{
	if (n == 0u)
	{
		*out = '0' as uint32 as uint8;
		return out + 1;
	}
	const output_len = (16u - clz(n) / 4u) as int32;
	consteval table: [16: uint8] = [
		'0' as uint32 as uint8, '1' as uint32 as uint8,
		'2' as uint32 as uint8, '3' as uint32 as uint8,
		'4' as uint32 as uint8, '5' as uint32 as uint8,
		'6' as uint32 as uint8, '7' as uint32 as uint8,
		'8' as uint32 as uint8, '9' as uint32 as uint8,
		'A' as uint32 as uint8, 'B' as uint32 as uint8,
		'C' as uint32 as uint8, 'D' as uint32 as uint8,
		'E' as uint32 as uint8, 'F' as uint32 as uint8
	];
	let i = output_len;
	while (i > 0)
	{
		--i;
		const c = table[(n >> (i * 4)) & 0b1111u64];
		*(out + i) = c;
	}
	return out + output_len;
}

// binary printing has the max number of possible chars
consteval max_uint_string_length = 64uz;

function get_uint_decimal_as_string(n: uint64) -> [[max_uint_string_length: uint8], uint32]
{
	let result: [[max_uint_string_length: uint8], uint32];
	const end = print_uint_decimal_to_buffer(n, result[0].begin());
	result[1] = (end - result[0].begin()) as uint32;
	return result;
}

function get_uint_base_as_string(n: uint64, base: consteval uint64) -> [[max_uint_string_length: uint8], uint32]
{
	static_assert(base == 2u || base == 8u);
	let result: [[max_uint_string_length: uint8], uint32];
	const end = print_uint_base_to_buffer(n, result[0].begin(), base);
	result[1] = (end - result[0].begin()) as uint32;
	return result;
}

function get_uint_hex_as_string(n: uint64, capital: bool) -> [[max_uint_string_length: uint8], uint32]
{
	let result: [[max_uint_string_length: uint8], uint32];
	const end = if (capital) {
		print_uint_HEX_to_buffer(n, result[0].begin())
	} else {
		print_uint_hex_to_buffer(n, result[0].begin())
	};
	result[1] = (end - result[0].begin()) as uint32;
	return result;
}

export function format_to(s: str, buffer: &format_buffer, fmt_spec: str)
{
	s.format_to(buffer, get_default_format_spec(fmt_spec));
}

export function format_to(s: str, buffer: &format_buffer, fmt_spec: format_spec)
{
	if (fmt_spec.align == '\x00')
	{
		fmt_spec.align = '<';
	}
	if (fmt_spec.fill == '\x00')
	{
		fmt_spec.fill = ' ';
	}
	switch (fmt_spec.align)
	{
		'<' => {
			const len = s.length();
			buffer.write_into(s);
			if (len < fmt_spec.width)
			{
				buffer.write_into(fmt_spec.fill, fmt_spec.width - len);
			}
		},
		'^' => {
			const len = s.length();
			if (len < fmt_spec.width)
			{
				const diff = fmt_spec.width - len;
				// if the spacing is uneven, prefer left alignment
				buffer.write_into(fmt_spec.fill, diff / 2u);
				buffer.write_into(s);
				buffer.write_into(fmt_spec.fill, (diff + 1u) / 2u);
			}
			else
			{
				buffer.write_into(s);
			}
		},
		'>' => {
			const len = s.length();
			if (len < fmt_spec.width)
			{
				buffer.write_into(fmt_spec.fill, fmt_spec.width - len);
			}
			buffer.write_into(s);
		},
		else => unreachable
	}
}

export function format_to(c: char, buffer: &format_buffer, fmt_spec: str)
{
	c.format_to(buffer, get_default_format_spec(fmt_spec));
}

export function format_to(c: char, buffer: &format_buffer, fmt_spec: format_spec)
{
	const [encoded_char, byte_count] = encode_char_utf8(c);
	const s = __builtin_str_from_ptrs(encoded_char.begin(), encoded_char.begin() + byte_count);
	s.format_to(buffer, fmt_spec);
}

function format_number(number_str: str, buffer: &format_buffer, fmt_spec: format_spec, put_sign: bool)
{
	if (fmt_spec.align == '\x00')
	{
		fmt_spec.align = '>';
	}
	if (fmt_spec.fill == '\x00')
	{
		fmt_spec.fill = ' ';
	}
	switch (fmt_spec.align)
	{
		'<' => {
			const len = number_str.length() + put_sign as uint32;
			if (put_sign)
			{
				buffer.write_into(fmt_spec.sign);
			}
			buffer.write_into(number_str);
			if (len < fmt_spec.width)
			{
				buffer.write_into(fmt_spec.fill, fmt_spec.width - len);
			}
		},
		'^' => {
			const len = number_str.length() + put_sign as uint32;
			if (len < fmt_spec.width)
			{
				const diff = fmt_spec.width - len;
				// if the spacing is uneven, prefer right alignment
				if (fmt_spec.zero_pad)
				{
					if (put_sign)
					{
						buffer.write_into(fmt_spec.sign);
					}
					buffer.write_into('0', (diff + 1u) / 2u);
					buffer.write_into(number_str);
				}
				else
				{
					buffer.write_into(fmt_spec.fill, (diff + 1u) / 2u);
					if (put_sign)
					{
						buffer.write_into(fmt_spec.sign);
					}
					buffer.write_into(number_str);
				}
				buffer.write_into(fmt_spec.fill, diff / 2u);
			}
			else
			{
				if (put_sign)
				{
					buffer.write_into(fmt_spec.sign);
				}
				buffer.write_into(number_str);
			}
		},
		'>' => {
			const len = number_str.length() + put_sign as uint32;
			if (len < fmt_spec.width)
			{
				if (fmt_spec.zero_pad)
				{
					if (put_sign)
					{
						buffer.write_into(fmt_spec.sign);
					}
					buffer.write_into('0', fmt_spec.width - len);
					buffer.write_into(number_str);
				}
				else
				{
					buffer.write_into(fmt_spec.fill, fmt_spec.width - len);
					if (put_sign)
					{
						buffer.write_into(fmt_spec.sign);
					}
					buffer.write_into(number_str);
				}
			}
			else
			{
				if (put_sign)
				{
					buffer.write_into(fmt_spec.sign);
				}
				buffer.write_into(number_str);
			}
		},
		else => unreachable
	}
}

export function format_to(n: uint64, buffer: &format_buffer, fmt_spec: str)
{
	n.format_to(buffer, get_default_format_spec(fmt_spec));
}

export function format_to(n: uint64, buffer: &format_buffer, fmt_spec: format_spec)
{
	const [result_buffer, size] = switch (fmt_spec.fmt_kind) {
		'b', 'B' => {
			get_uint_base_as_string(n, 2u)
		},
		'o', 'O' => {
			get_uint_base_as_string(n, 8u)
		},
		'x', 'X' => {
			get_uint_hex_as_string(n, fmt_spec.fmt_kind == 'X')
		},
		else => {
			get_uint_decimal_as_string(n)
		}
	};
	const result_str = __builtin_str_from_ptrs(result_buffer.begin(), result_buffer.begin() + size);
	const put_sign = fmt_spec.sign == '+' || fmt_spec.sign == ' ';
	format_number(result_str, buffer, fmt_spec, put_sign);
}

export function format_to(n: int64, buffer: &format_buffer, fmt_spec: str)
{
	n.format_to(buffer, get_default_format_spec(fmt_spec));
}

export function format_to(n: int64, buffer: &format_buffer, fmt_spec: format_spec)
{
	const put_sign = n < 0 || fmt_spec.sign == '+' || fmt_spec.sign == ' ';
	if (n < 0)
	{
		fmt_spec.sign = '-';
	}
	// -n as uint64 works for uint64_min as well
	const n = if (n < 0) { -n as uint64 } else { n as uint64 };
	const [result_buffer, size] = get_uint_decimal_as_string(n);
	const result_str = __builtin_str_from_ptrs(result_buffer.begin(), result_buffer.begin() + size);
	format_number(result_str, buffer, fmt_spec, put_sign);
}

function format_pointer(number_str: str, buffer: &format_buffer, fmt_spec: format_spec)
{
	if (fmt_spec.align == '\x00')
	{
		fmt_spec.align = '>';
	}
	if (fmt_spec.fill == '\x00')
	{
		fmt_spec.fill = ' ';
	}
	const prefix = if (fmt_spec.fmt_kind == 'P') { "0X" } else { "0x" };
	switch (fmt_spec.align)
	{
		'<' => {
			const len = number_str.length() + 2u;
			buffer.write_into(prefix);
			buffer.write_into(number_str);
			if (len < fmt_spec.width)
			{
				buffer.write_into(fmt_spec.fill, fmt_spec.width - len);
			}
		},
		'^' => {
			const len = number_str.length() + 2u;
			if (len < fmt_spec.width)
			{
				const diff = fmt_spec.width - len;
				// if the spacing is uneven, prefer right alignment
				if (fmt_spec.zero_pad)
				{
					buffer.write_into(prefix);
					buffer.write_into('0', (diff + 1u) / 2u);
					buffer.write_into(number_str);
				}
				else
				{
					buffer.write_into(fmt_spec.fill, (diff + 1u) / 2u);
					buffer.write_into(prefix);
					buffer.write_into(number_str);
				}
				buffer.write_into(fmt_spec.fill, diff / 2u);
			}
			else
			{
				buffer.write_into(prefix);
				buffer.write_into(number_str);
			}
		},
		'>' => {
			const len = number_str.length() + 2u;
			if (len < fmt_spec.width)
			{
				if (fmt_spec.zero_pad)
				{
					buffer.write_into(prefix);
					buffer.write_into('0', fmt_spec.width - len);
					buffer.write_into(number_str);
				}
				else
				{
					buffer.write_into(fmt_spec.fill, fmt_spec.width - len);
					buffer.write_into(prefix);
					buffer.write_into(number_str);
				}
			}
			else
			{
				buffer.write_into(prefix);
				buffer.write_into(number_str);
			}
		},
		else => unreachable
	}
}

export function format_to(p: *const void, buffer: &format_buffer, fmt_spec: str)
{
	p.format_to(buffer, get_default_format_spec(fmt_spec));
}

export function format_to(p: *const void, buffer: &format_buffer, fmt_spec: format_spec)
{
	const val = __builtin_pointer_to_int(p);
	static_assert(typeof val == const uint64);
	const [result_buffer, size] = get_uint_hex_as_string(val, fmt_spec.fmt_kind == 'P');
	const result_str = __builtin_str_from_ptrs(result_buffer.begin(), result_buffer.begin() + size);
	format_pointer(result_str, buffer, fmt_spec);
}

export function format_to(b: bool, buffer: &format_buffer, fmt_spec: str)
{
	b.format_to(buffer, get_default_format_spec(fmt_spec));
}

export function format_to(b: bool, buffer: &format_buffer, fmt_spec: format_spec)
{
	if (b)
	{
		"true".format_to(buffer, fmt_spec);
	}
	else
	{
		"false".format_to(buffer, fmt_spec);
	}
}

export function format_to(x: float32, buffer: &format_buffer, fmt_spec: str)
{
	x.format_to(buffer, get_default_format_spec(fmt_spec));
}

export function format_to(x: float32, buffer: &format_buffer, fmt_spec: format_spec)
{
	let result_buffer: [15: uint8];
	const end = ryu::f2s_shortest(x, result_buffer.begin());
	const s = __builtin_str_from_ptrs(result_buffer.begin(), end);
	buffer.write_into(s);
}

export function format_to(x: float64, buffer: &format_buffer, fmt_spec: str)
{
	x.format_to(buffer, get_default_format_spec(fmt_spec));
}

export function format_to(x: float64, buffer: &format_buffer, fmt_spec: format_spec)
{
	let result_buffer: [24: uint8];
	const end = ryu::d2s_shortest(x, result_buffer.begin());
	const s = __builtin_str_from_ptrs(result_buffer.begin(), end);
	buffer.write_into(s);
}

export function format_to(arr: [: const auto], buffer: &format_buffer, fmt_spec: str)
{
	arr.format_to(buffer, get_default_format_spec(fmt_spec));
}

export function format_to(arr: [: const auto], buffer: &format_buffer, fmt_spec: format_spec)
{
	let it = arr.begin();
	const end = arr.end();

	if (it == end)
	{
		buffer.write_into("[]");
		return;
	}

	buffer.write_into("[ ");

	it->format_to(buffer, fmt_spec);
	++it;
	for (; it != end; ++it)
	{
		buffer.write_into(", ");
		it->format_to(buffer, fmt_spec);
	}

	buffer.write_into(" ]");
}

function tuple_format_to_impl(buffer: &format_buffer, [first], fmt_spec: format_spec)
{
	first->format_to(buffer, fmt_spec);
}

function tuple_format_to_impl(buffer: &format_buffer, [first, second, ...rest], fmt_spec: format_spec)
{
	first->format_to(buffer, fmt_spec);
	buffer.write_into(", ");
	tuple_format_to_impl(buffer, [ second, ...rest ], fmt_spec);
}

export function format_to(: &const [], buffer: &format_buffer, : str)
{
	buffer.write_into("[]");
}

export function format_to(: &const [], buffer: &format_buffer, : format_spec)
{
	buffer.write_into("[]");
}

export function format_to(t: &const [...auto], buffer: &format_buffer, fmt_spec: str)
{
	t.format_to(buffer, get_default_format_spec(fmt_spec));
}

export function format_to(&const [...elems], buffer: &format_buffer, fmt_spec: format_spec)
{
	buffer.write_into("[ ");
	tuple_format_to_impl(buffer, [ ...&elems ], fmt_spec);
	buffer.write_into(" ]");
}
