import libc::stdlib;

export function print   = __builtin_print_stdout;
export function println = __builtin_println_stdout;

export function log   = __builtin_print_stderr;
export function logln = __builtin_println_stderr;

@extern("print_float32", "c") export function print(x: float32);
@extern("print_float64", "c") export function print(x: float64);

@extern("println_float32", "c") export function println(x: float32);
@extern("println_float64", "c") export function println(x: float64);

function encode_char_utf8(c: char) -> [[4: uint8], uint32]
{
	let buffer: [4: uint8];
	if (c as uint32 < 1u << 7u)
	{
		buffer[0] = c as uint32 as uint8;
		return [buffer, 1u];
	}
	else if (c as uint32 < 1u << 11u)
	{
		buffer[0] = (((c as uint32 >> 6u) & 0b0001'1111) | 0b1100'0000) as uint8;
		buffer[1] = (((c as uint32 >> 0u) & 0b0011'1111) | 0b1000'0000) as uint8;
		return [buffer, 2u];
	}
	else if (c as uint32 < 1u << 16u)
	{
		buffer[0] = (((c as uint32 >> 12u) & 0b0000'1111) | 0b1110'0000) as uint8;
		buffer[1] = (((c as uint32 >>  6u) & 0b0011'1111) | 0b1000'0000) as uint8;
		buffer[2] = (((c as uint32 >>  0u) & 0b0011'1111) | 0b1000'0000) as uint8;
		return [buffer, 3u];
	}
	else
	{
		buffer[0] = (((c as uint32 >> 18u) & 0b0000'0111) | 0b1111'0000) as uint8;
		buffer[1] = (((c as uint32 >> 12u) & 0b0011'1111) | 0b1000'0000) as uint8;
		buffer[2] = (((c as uint32 >>  6u) & 0b0011'1111) | 0b1000'0000) as uint8;
		buffer[3] = (((c as uint32 >>  0u) & 0b0011'1111) | 0b1000'0000) as uint8;
		return [buffer, 4u];
	}
}

export function print(c: char)
{
	const buffer_and_size = encode_char_utf8(c);
	print(__builtin_str_from_ptrs(buffer_and_size[0].begin(), buffer_and_size[0].begin() + buffer_and_size[1]));
}

export function println(c: char)
{
	const buffer_and_size = encode_char_utf8(c);
	println(__builtin_str_from_ptrs(buffer_and_size[0].begin(), buffer_and_size[0].begin() + buffer_and_size[1]));
}

function print_uint_to_reverse_buffer(it: *uint8, val: uint64, base: consteval uint64) -> *uint8
{
	if (val == 0u)
	{
		--it;
		*it = '0' as uint32 as uint8;
		return it;
	}
	while (val != 0u)
	{
		const digit_val = val % base;
		val /= base;
		if (digit_val < 10u)
		{
			--it;
			*it = ('0' + digit_val) as uint32 as uint8;
		}
		else
		{
			--it;
			*it = ('a' + digit_val - 10u) as uint32 as uint8;
		}
	}
	return it;
}

export function print(p: *const void)
{
	const val = __builtin_pointer_to_int(p);
	static_assert(typeof val == const uint64);
	let buffer: [2 + 16: uint8];
	let it = print_uint_to_reverse_buffer(buffer.end(), val, 16u);
	--it;
	*it = 'x' as uint32 as uint8;
	--it;
	*it = '0' as uint32 as uint8;
	const result_str = __builtin_str_from_ptrs(it, buffer.end());
	print(result_str);
}

export function println(p: *const void)
{
	let val = __builtin_pointer_to_int(p);
	static_assert(typeof val == uint64);
	let buffer: [2 + 16 + 1: uint8];
	let it = buffer.end();
	--it;
	*it = '\n' as uint32 as uint8;
	it = print_uint_to_reverse_buffer(it, val, 16u);
	--it;
	*it = 'x' as uint32 as uint8;
	--it;
	*it = '0' as uint32 as uint8;
	const result_str = __builtin_str_from_ptrs(it, buffer.end());
	print(result_str);
}

export function print(b: bool)
{
	if (b)
	{
		print("true");
	}
	else
	{
		print("false");
	}
}

export function println(b: bool)
{
	if (b)
	{
		print("true\n");
	}
	else
	{
		print("false\n");
	}
}

consteval max_uint_string_length = {
	let uint64_max = ~0u64;
	let result = 0uz;
	while (uint64_max != 0u)
	{
		uint64_max /= 10u;
		++result;
	}
	result
};

function get_uint_as_string(n: uint64) -> [[max_uint_string_length: uint8], uint32]
{
	let result: [[max_uint_string_length: uint8], uint32];
	if (n < 10u)
	{
		result[0, max_uint_string_length - 1u] = ('0' + n) as uint32 as uint8;
		result[1] = 1u;
	}
	else
	{
		let it = result[0].end();
		while (n != 0u)
		{
			const digit = n % 10u;
			n /= 10u;
			--it;
			*it = ('0' + digit) as uint32 as uint8;
		}
		result[1] = (result[0].end() - it) as uint32;
	}
	return result;
}

export function print(n: uint64)
{
	const string_and_size = get_uint_as_string(n);
	const string = __builtin_str_from_ptrs(string_and_size[0].end() - string_and_size[1], string_and_size[0].end());
	print(string);
}

export function println(n: uint64)
{
	const string_and_size = get_uint_as_string(n);
	const string = __builtin_str_from_ptrs(string_and_size[0].end() - string_and_size[1], string_and_size[0].end());
	println(string);
}

consteval max_int_string_length = {
	// this is actually -int64_min, but its absolute value is larger than int64_max, so we use this instead
	let int64_max = 1u64 << 63u;
	let result = 0uz;
	while (int64_max != 0u)
	{
		int64_max /= 10u;
		++result;
	}
	result + 1u
};

function get_int_as_string(abs_val: uint64, is_negative: bool) -> [[max_int_string_length: uint8], uint32]
{
	let n = abs_val;
	let result: [[max_int_string_length: uint8], uint32];
	if (n < 10u)
	{
		result[0, max_uint_string_length - 1u] = ('0' + n) as uint32 as uint8;
		result[1] = 1u;
	}
	else
	{
		let it = result[0].end();
		while (n != 0u)
		{
			const digit = n % 10u;
			n /= 10u;
			--it;
			*it = ('0' + digit) as uint32 as uint8;
		}
		result[1] = (result[0].end() - it) as uint32;
	}
	if (is_negative)
	{
		*(result[0].end() - result[1] - 1u) = '-' as uint32 as uint8;
		++result[1];
	}
	return result;
}

export function print(n: int64)
{
	// -n as uint64 works for int64_min as well
	const string_and_size = get_int_as_string(if (n < 0) { -n as uint64 } else { n as uint64 }, n < 0);
	const string = __builtin_str_from_ptrs(string_and_size[0].end() - string_and_size[1], string_and_size[0].end());
	print(string);
}

export function println(n: int64)
{
	// -n as uint64 works for int64_min as well
	const string_and_size = get_int_as_string(if (n < 0) { -n as uint64 } else { n as uint64 }, n < 0);
	const string = __builtin_str_from_ptrs(string_and_size[0].end() - string_and_size[1], string_and_size[0].end());
	println(string);
}
