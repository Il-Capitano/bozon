import libc::stdlib;

export function print   = __builtin_print_stdout;
export function println = __builtin_println_stdout;

export function log   = __builtin_print_stderr;
export function logln = __builtin_println_stderr;

@extern("print_int64",    "c") export function print(n: int64)       -> void;
@extern("print_uint64",   "c") export function print(n: uint64)      -> void;
@extern("print_float32",  "c") export function print(x: float32)     -> void;
@extern("print_float64",  "c") export function print(x: float64)     -> void;

@extern("println_int64",    "c") export function println(n: int64)       -> void;
@extern("println_uint64",   "c") export function println(n: uint64)      -> void;
@extern("println_float32",  "c") export function println(x: float32)     -> void;
@extern("println_float64",  "c") export function println(x: float64)     -> void;

function encode_char_utf8(c: char) -> [[4: uint8], uint32]
{
	let buffer: [4: uint8];
	if (c as uint32 < 1u << 7u)
	{
		buffer[0] = c as uint32 as uint8;
		return [buffer, 1u];
	}
	else if (c as uint32 < 1u << 11u)
	{
		buffer[0] = (((c as uint32 >> 6u) & 0b0001'1111) | 0b1100'0000) as uint8;
		buffer[1] = (((c as uint32 >> 0u) & 0b0011'1111) | 0b1000'0000) as uint8;
		return [buffer, 2u];
	}
	else if (c as uint32 < 1u << 16u)
	{
		buffer[0] = (((c as uint32 >> 12u) & 0b0000'1111) | 0b1110'0000) as uint8;
		buffer[1] = (((c as uint32 >>  6u) & 0b0011'1111) | 0b1000'0000) as uint8;
		buffer[2] = (((c as uint32 >>  0u) & 0b0011'1111) | 0b1000'0000) as uint8;
		return [buffer, 3u];
	}
	else
	{
		buffer[0] = (((c as uint32 >> 18u) & 0b0000'0111) | 0b1111'0000) as uint8;
		buffer[1] = (((c as uint32 >> 12u) & 0b0011'1111) | 0b1000'0000) as uint8;
		buffer[2] = (((c as uint32 >>  6u) & 0b0011'1111) | 0b1000'0000) as uint8;
		buffer[3] = (((c as uint32 >>  0u) & 0b0011'1111) | 0b1000'0000) as uint8;
		return [buffer, 4u];
	}
}

export function print(c: char)
{
	const buffer_and_size = encode_char_utf8(c);
	print(__builtin_str_from_ptrs(buffer_and_size[0].begin(), buffer_and_size[0].begin() + buffer_and_size[1]));
}

export function println(c: char)
{
	const buffer_and_size = encode_char_utf8(c);
	println(__builtin_str_from_ptrs(buffer_and_size[0].begin(), buffer_and_size[0].begin() + buffer_and_size[1]));
}

function print_uint_to_reverse_buffer(it: *uint8, val: uint64, base: consteval uint64) -> *uint8
{
	if (val == 0u)
	{
		--it;
		*it = '0' as uint32 as uint8;
		return it;
	}
	while (val != 0u)
	{
		const digit_val = val % base;
		val /= base;
		if (digit_val < 10u)
		{
			--it;
			*it = ('0' + digit_val) as uint32 as uint8;
		}
		else
		{
			--it;
			*it = ('a' + digit_val - 10u) as uint32 as uint8;
		}
	}
	return it;
}

export function print(p: *const void)
{
	const val = __builtin_pointer_to_int(p);
	static_assert(typeof val == const uint64);
	let buffer: [2 + 16: uint8];
	let it = print_uint_to_reverse_buffer(buffer.end(), val, 16u);
	--it;
	*it = 'x' as uint32 as uint8;
	--it;
	*it = '0' as uint32 as uint8;
	const result_str = __builtin_str_from_ptrs(it, buffer.end());
	print(result_str);
}

export function println(p: *const void)
{
	let val = __builtin_pointer_to_int(p);
	static_assert(typeof val == uint64);
	let buffer: [2 + 16 + 1: uint8];
	let it = buffer.end();
	--it;
	*it = '\n' as uint32 as uint8;
	it = print_uint_to_reverse_buffer(it, val, 16u);
	--it;
	*it = 'x' as uint32 as uint8;
	--it;
	*it = '0' as uint32 as uint8;
	const result_str = __builtin_str_from_ptrs(it, buffer.end());
	print(result_str);
}

export function print(b: bool)
{
	if (b)
	{
		print("true");
	}
	else
	{
		print("false");
	}
}

export function println(b: bool)
{
	if (b)
	{
		print("true\n");
	}
	else
	{
		print("false\n");
	}
}
