// Copyright 2019 Ulf Adams
//
// The contents of this file may be used under the terms of the Apache License,
// Version 2.0.
//
//    (See accompanying file LICENSE-Apache or copy at
//     http://www.apache.org/licenses/LICENSE-2.0)
//
// Alternatively, the contents of this file may be used under the terms of
// the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE-Boost or copy at
//     https://www.boost.org/LICENSE_1_0.txt)
//
// Unless required by applicable law or agreed to in writing, this software
// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.

import common;
import f2s_intrinsics;
import f2s_full_table;

import std::utils;

export consteval s2f_SUCCESS         = 0u;
export consteval s2f_INPUT_TOO_SHORT = 1u;
export consteval s2f_INPUT_TOO_LONG  = 2u;
export consteval s2f_MALFORMED_INPUT = 3u;

consteval FLOAT_MANTISSA_BITS = 23;
consteval FLOAT_EXPONENT_BITS = 8;
consteval FLOAT_EXPONENT_BIAS = 127;


function floor_log2(value: uint32) -> uint32
{
	return 31u - __builtin_clz_u32(value);
}

// The max function is already defined on Windows.
function max32(a: int32, b: int32) -> int32
{
	return if (a < b) { b } else { a };
}

function int32Bits2Float(bits: uint32) -> float32
{
	let f: float32;
	std::memcpy(&f, &bits, sizeof float32);
	return f;
}

export function s2f_n(buffer: *const uint8, len: int32, result: *float32) -> uint32
{
	if (len == 0)
	{
		return s2f_INPUT_TOO_SHORT;
	}
	let m10digits = 0;
	let e10digits = 0;
	let dotIndex = len;
	let eIndex = len;
	let m10 = 0u32;
	let e10 = 0i32;
	let signedM = false;
	let signedE = false;
	let i = 0;
	if (*(buffer + i) == '-' as uint32 as uint8)
	{
		signedM = true;
		++i;
	}
	for (;
		i < len && {
			let c = *(buffer + i) as uint32 as char;
			(c >= '0' && c <= '9') || c == '.'
		};
		++i
	)
	{
		let c = *(buffer + i) as uint32 as char;
		if (c == '.')
		{
			if (dotIndex != len)
			{
				return s2f_MALFORMED_INPUT;
			}
			dotIndex = i;
		}
		else
		{
			if (m10digits >= 9)
			{
				return s2f_INPUT_TOO_LONG;
			}
			m10 = 10u * m10 + (c - '0') as uint32;
			if (m10 != 0u)
			{
				++m10digits;
			}
		}
	}
	if (i < len && ((*(buffer + i) as uint32 as char == 'e') || (*(buffer + i) as uint32 as char == 'E')))
	{
		eIndex = i;
		++i;
		if (i < len && ((*(buffer + i) as uint32 as char == '-') || (*(buffer + i) as uint32 as char == '+')))
		{
			signedE = *(buffer + i) as uint32 as char == '-';
			++i;
		}
		for (; i < len; ++i)
		{
			let c = *(buffer + i) as uint32 as char;
			if ((c < '0') || (c > '9'))
			{
				return s2f_MALFORMED_INPUT;
			}
			if (e10digits > 3)
			{
				// TODO: Be more lenient. Return +/-Infinity or +/-0 instead.
				return s2f_INPUT_TOO_LONG;
			}
			e10 = 10 * e10 + (c - '0');
			if (e10 != 0)
			{
				++e10digits;
			}
		}
	}
	if (i < len)
	{
		return s2f_MALFORMED_INPUT;
	}
	if (signedE)
	{
		e10 = -e10;
	}
	if (dotIndex < eIndex)
	{
		e10 -= eIndex - dotIndex - 1;
	}
	if (m10 == 0u)
	{
		if (signedM)
		{
			*result = -0.0f32;
		}
		else
		{
			*result = 0.0f32;
		}
		return s2f_SUCCESS;
	}

	if ((m10digits + e10 <= -46) || (m10 == 0u))
	{
		// Number is less than 1e-46, which should be rounded down to 0; return +/-0.0.
		let ieee = signedM as uint32 << (FLOAT_EXPONENT_BITS + FLOAT_MANTISSA_BITS) as uint32;
		*result = int32Bits2Float(ieee);
		return s2f_SUCCESS;
	}
	if (m10digits + e10 >= 40)
	{
		// Number is larger than 1e+39, which should be rounded to +/-Infinity.
		let ieee = (signedM as uint32 << (FLOAT_EXPONENT_BITS + FLOAT_MANTISSA_BITS) as uint32) | (0xffu32 << FLOAT_MANTISSA_BITS as uint32);
		*result = int32Bits2Float(ieee);
		return s2f_SUCCESS;
	}

	// Convert to binary float m2 * 2^e2, while retaining information about whether the conversion
	// was exact (trailingZeros).
	let e2: int32;
	let m2: uint32;
	let trailingZeros: bool;
	if (e10 >= 0)
	{
		const e10 = e10 as uint32;
		// The length of m * 10^e in bits is:
		//   log2(m10 * 10^e10) = log2(m10) + e10 log2(10) = log2(m10) + e10 + e10 * log2(5)
		//
		// We want to compute the FLOAT_MANTISSA_BITS + 1 top-most bits (+1 for the implicit leading
		// one in IEEE format). We therefore choose a binary output exponent of
		//   log2(m10 * 10^e10) - (FLOAT_MANTISSA_BITS + 1).
		//
		// We use floor(log2(5^e10)) so that we get at least this many bits; better to
		// have an additional bit than to not have enough bits.
		e2 = (floor_log2(m10) + e10 + log2pow5(e10) - (FLOAT_MANTISSA_BITS + 1) as uint32) as int32;

		// We now compute [m10 * 10^e10 / 2^e2] = [m10 * 5^e10 / 2^(e2-e10)].
		// To that end, we use the FLOAT_POW5_SPLIT table.
		const j = e2 - e10 as int32 - ceil_log2pow5(e10) as int32 + FLOAT_POW5_BITCOUNT;
		// assert(j >= 0);
		m2 = mulPow5divPow2(m10, e10, j as uint32);

		// We also compute if the result is exact, i.e.,
		//   [m10 * 10^e10 / 2^e2] == m10 * 10^e10 / 2^e2.
		// This can only be the case if 2^e2 divides m10 * 10^e10, which in turn requires that the
		// largest power of 2 that divides m10 + e10 is greater than e2. If e2 is less than e10, then
		// the result must be exact. Otherwise we use the existing multipleOfPowerOf2 function.
		trailingZeros = e2 < e10 as int32 || (e2 - e10 as int32 < 32 && multipleOfPowerOf2_32(m10, e2 as uint32 - e10));
	}
	else
	{
		const me10 = -e10 as uint32;
		e2 = floor_log2(m10) as int32 + e10 - ceil_log2pow5(me10) as int32 - (FLOAT_MANTISSA_BITS + 1);

		// We now compute [m10 * 10^e10 / 2^e2] = [m10 / (5^(-e10) 2^(e2-e10))].
		const j = e2 - e10 + ceil_log2pow5(me10) as int32 - 1 + FLOAT_POW5_INV_BITCOUNT;
		m2 = mulPow5InvDivPow2(m10, me10, j as uint32);

		// We also compute if the result is exact, i.e.,
		//   [m10 / (5^(-e10) 2^(e2-e10))] == m10 / (5^(-e10) 2^(e2-e10))
		//
		// If e2-e10 >= 0, we need to check whether (5^(-e10) 2^(e2-e10)) divides m10, which is the
		// case iff pow5(m10) >= -e10 AND pow2(m10) >= e2-e10.
		//
		// If e2-e10 < 0, we have actually computed [m10 * 2^(e10 e2) / 5^(-e10)] above,
		// and we need to check whether 5^(-e10) divides (m10 * 2^(e10-e2)), which is the case iff
		// pow5(m10 * 2^(e10-e2)) = pow5(m10) >= -e10.
		trailingZeros = (e2 < e10 || (e2 - e10 < 32 && multipleOfPowerOf2_32(m10, (e2 - e10) as uint32)))
			&& multipleOfPowerOf5_32(m10, me10);
	}

	// Compute the final IEEE exponent.
	let ieee_e2 = max32(0, e2 + FLOAT_EXPONENT_BIAS + floor_log2(m2) as int32) as uint32;

	if (ieee_e2 > 0xfe)
	{
		// Final IEEE exponent is larger than the maximum representable; return +/-Infinity.
		const ieee = (signedM as uint32 << (FLOAT_EXPONENT_BITS + FLOAT_MANTISSA_BITS) as uint32) | (0xffu32 << FLOAT_MANTISSA_BITS as uint32);
		*result = int32Bits2Float(ieee);
		return s2f_SUCCESS;
	}

	// We need to figure out how much we need to shift m2. The tricky part is that we need to take
	// the final IEEE exponent into account, so we need to reverse the bias and also special-case
	// the value 0.
	const shift = if (ieee_e2 == 0u) {
		1 - e2 - FLOAT_EXPONENT_BIAS - FLOAT_MANTISSA_BITS
	} else {
		ieee_e2 as int32 - e2 - FLOAT_EXPONENT_BIAS - FLOAT_MANTISSA_BITS
	};
	// assert(shift >= 0);

	// We need to round up if the exact value is more than 0.5 above the value we computed. That's
	// equivalent to checking if the last removed bit was 1 and either the value was not just
	// trailing zeros or the result would otherwise be odd.
	//
	// We need to update trailingZeros given that we have the exact output exponent ieee_e2 now.
	trailingZeros &= (m2 & ((1u32 << (shift - 1) as uint32) - 1u)) == 0u;
	const lastRemovedBit = (m2 >> (shift - 1) as uint32) & 1u32;
	const roundUp = (lastRemovedBit != 0u) && (!trailingZeros || (((m2 >> shift as uint32) & 1u32) != 0u));

	let ieee_m2 = (m2 >> shift as uint32) + roundUp as uint32;
	// assert(ieee_m2 <= (1u << (FLOAT_MANTISSA_BITS + 1)));
	ieee_m2 &= (1u32 << FLOAT_MANTISSA_BITS as uint32) - 1u;
	if (ieee_m2 == 0u && roundUp)
	{
		// Rounding up may overflow the mantissa.
		// In this case we move a trailing zero of the mantissa into the exponent.
		// Due to how the IEEE represents +/-Infinity, we don't need to check for overflow here.
		++ieee_e2;
	}
	const ieee = (((signedM as uint32 << FLOAT_EXPONENT_BITS as uint32) | ieee_e2) << FLOAT_MANTISSA_BITS as uint32) | ieee_m2;
	*result = int32Bits2Float(ieee);
	return s2f_SUCCESS;
}

function c_strlen(c_str: *const uint8) -> int32
{
	if (c_str == null)
	{
		return 0;
	}

	let result = 0;
	while (*c_str != 0u)
	{
		++result;
		++c_str;
	}
	return result;
}

export function s2f(buffer: *const uint8, result: *float32) -> uint32
{
	return s2f_n(buffer, c_strlen(buffer), result);
}

export function s2f_str(s: str, result: *float32) -> uint32
{
	return s2f_n(__builtin_str_begin_ptr(s), s.size() as int32, result);
}
