import libc::stdlib;
import meta::comptime;

export function memcpy  = __builtin_memcpy;
export function memmove = __builtin_memmove;
export function memset  = __builtin_memset;

export function assert(b: bool)
{
	if (!b) unreachable;
}

@symbol_name("exit") export function exit(code: int32) -> void;

@no_comptime_checking
export function malloc(T: typename, n: usize) -> *T
{
	static_assert(&T != T, "type in malloc can't be a reference type");
	static_assert(const T != T, "type in malloc can't be const");
	static_assert(consteval T != T, "type in malloc can't be consteval");

	if (meta::is_comptime())
	{
		return meta::malloc(T, n);
	}
	else
	{
		return __builtin_pointer_cast(*T, libc::malloc(n));
	}
}

@no_comptime_checking
export function free(p: *void)
{
	if (meta::is_comptime())
	{
		meta::free(p);
	}
	else
	{
		libc::free(p);
	}
}

export function swap(a: &auto, b: &auto)
{
	static_assert(typeof a == typeof b, "different types in swap");
	const tmp = a;
	a = b;
	b = tmp;
}

consteval function is_integer_type(T: typename) -> bool
{
	return T == int8 || T == int16 || T == int32 || T == int64
		|| T == uint8 || T == uint16 || T == uint32 || T == uint64;
}

export struct range_t<T: typename>
{
	static_assert(is_integer_type(T), "invalid type for std::range_t");

	type value_type = T;

	._begin: T;
	._end: T;
}

export struct range_iterator_t<T: typename>
{
	static_assert(is_integer_type(T), "invalid type for std::range_iterator_t");

	type value_type = T;

	._value: T;
}

export function range(end) -> range_t<typeof end>
{
	type T = typeof end;
	return range_t<T>[ 0 as T, end ];
}

export function range(begin, end) -> range_t<typeof begin>
{
	static_assert(typeof begin == typeof end, "begin and end have different types in std::range");
	type T = typeof begin;
	return range_t<T>[ begin, end ];
}

export function begin(range: range_t) -> range_iterator_t<(typeof range).value_type>
{
	type T = (typeof range).value_type;
	return range_iterator_t<T>[ range._begin ];
}

export function end(range: range_t) -> range_iterator_t<(typeof range).value_type>
{
	type T = (typeof range).value_type;
	return range_iterator_t<T>[ range._end ];
}

export operator * (it: range_iterator_t) -> (typeof it).value_type
{
	return it._value;
}

export operator ++ (it: &range_iterator_t) -> typeof it
{
	++it._value;
	return it;
}

export operator == (lhs: range_iterator_t, rhs: range_iterator_t) -> bool
{
	static_assert(typeof lhs == typeof rhs);
	return lhs._value == rhs._value;
}

export operator != (lhs: range_iterator_t, rhs: range_iterator_t) -> bool
{
	static_assert(typeof lhs == typeof rhs);
	return lhs._value != rhs._value;
}
