import std::meta::comptime;
import std::meta::types;
import std::libc::stdlib;

function malloc(T: typename, n: usize) -> *T
{
	static_assert(!std::meta::is_reference(T), "type in 'malloc' can't be a reference type");
	static_assert(!std::meta::is_move_reference(T), "type in 'malloc' can't be a move reference type");
	static_assert(!std::meta::is_const(T), "type in 'malloc' can't be 'const'");
	static_assert(!std::meta::is_consteval(T), "type in 'malloc' can't be 'consteval'");

	const result = if (std::meta::is_comptime()) {
		std::meta::malloc(T, n)
	} else {
		const malloc_result = std::libc::malloc(n * sizeof T);
		if (malloc_result == null)
		{
			unreachable;
		}
		__builtin_pointer_cast(*T, malloc_result.get_value())
	};

	for (let [it, const end] = [ result, result + n ]; it != end; ++it)
	{
		__builtin_inplace_construct(it, T());
	}

	return result;
}

function free(p: ?*void)
{
	if (std::meta::is_comptime())
	{
		std::meta::free(p);
	}
	else
	{
		std::libc::free(p);
	}
}

export struct resource_t
{
	.p: *int32;

	constructor()
	{
		return resource_t[ malloc(int32, 1) ];
	}

	destructor(&self)
	{
		free(self.p);
	}

	constructor(other: &const resource_t)
	{
		return resource_t[ malloc(int32, 1) ];
	}
}

export struct complex_resource_t
{
	.p: *int32;
	.instance_p: *int32;

	constructor()
	{
		return complex_resource_t[
			malloc(int32, 1),
			malloc(int32, 1),
		];
	}

	constructor(other: &const complex_resource_t)
	{
		return complex_resource_t[
			malloc(int32, 1),
			malloc(int32, 1),
		];
	}

	constructor(other: move complex_resource_t)
	{
		return complex_resource_t[
			other.p,
			malloc(int32, 1),
		];
	}

	destructor(&self)
	{
		free(self.p);
		free(self.instance_p);
	}

	destructor(move self)
	{
		free(self.instance_p);
	}
}
