import resource;
import counting_resource;

struct S
{
	.i: i32;
	.j: usize;
	.x: f32;
	.y: f64;
	.a: [20: u32];
	.s: str;
}

struct complex_S
{
	.r0: resource_t;
	.r1: complex_resource_t;
	.ra0: [10: complex_resource_t];
	.ra1: [100: complex_resource_t];
	.cr0: relocatable_counting_resource_t;
	.cr1: counting_resource_t;
	.cra0: [10: counting_resource_t];
	.cra1: [100: counting_resource_t];
}

function index_sequence(size: consteval usize) -> [size: usize]
{
	mut result = [size: usize]();
	for (let i in 0..size)
	{
		result[i] = i;
	}
	return result;
}

function test_tuple(Ts: ...typename)
{
	let t = [...Ts]();
	consteval [...index] = index_sequence(sizeof ...Ts);
	...(if (t[index] != Ts()) { unreachable; });
}

function main()
{
	test_tuple(i32, str, f32, f64, u64, [10: i32], [100: f32]);
	{
		let _ = [resource_t]();
		let _ = [complex_resource_t]();
		let _ = [relocatable_counting_resource_t]();
		let _ = [counting_resource_t]();
		let _ = [resource_t, complex_resource_t, relocatable_counting_resource_t, counting_resource_t]();
		let _ = [10: [resource_t, complex_resource_t, relocatable_counting_resource_t, counting_resource_t]]();
		let _ = [[10: resource_t], [10: complex_resource_t], [10: relocatable_counting_resource_t], [10: counting_resource_t]]();
	}

	{
		S();
		let s = S();
		if (s.i != i32()) unreachable;
		if (s.j != usize()) unreachable;
		if (s.x != f32()) unreachable;
		if (s.y != f64()) unreachable;
		if (s.a != [20: u32]()) unreachable;
		if (s.s != str()) unreachable;

		complex_S();
		let _ = complex_S();
	}

	if (!counting_resource_is_valid()) unreachable;
	if (!relocatable_counting_resource_is_valid()) unreachable;
}
