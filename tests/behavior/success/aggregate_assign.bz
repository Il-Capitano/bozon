import resource;
import counting_resource;

struct S
{
	.i: i32;
	.j: usize;
	.x: f32;
	.y: f64;
	.a: [20: u32];
	.s: str;
}

struct complex_S
{
	.r0: resource_t;
	.r1: complex_resource_t;
	.ra0: [10: complex_resource_t];
	.ra1: [100: complex_resource_t];
	.cr0: relocatable_counting_resource_t;
	.cr1: counting_resource_t;
	.cra0: [10: counting_resource_t];
	.cra1: [100: counting_resource_t];
}

function index_sequence(size: consteval usize) -> [size: usize]
{
	mut result = [size: usize]();
	for (let i in 0..size)
	{
		result[i] = i;
	}
	return result;
}

function get_value(T: typename, i: i32) -> T
{
	if consteval (__builtin_is_array(T))
	{
		return __builtin_create_initialized_array(T, get_value(__builtin_array_value_type(T), i));
	}
	else if consteval (T == str)
	{
		let strings: [??: str] = ["0", "1"];
		return strings[i];
	}
	else if consteval (T == f32 || T == f64)
	{
		return i as T + 0.123 as T;
	}
	else
	{
		return i as T;
	}
}

function test_tuple(Ts: ...typename)
{
	let mut a = [...get_value(Ts, 0)];
	let b = [...get_value(Ts, 1)];
	consteval [...index] = index_sequence(sizeof ...Ts);
	a = a;
	...(if (a[index] != get_value(Ts, 0)) { unreachable; });
	...(if (b[index] != get_value(Ts, 1)) { unreachable; });
	a = b;
	...(if (a[index] != get_value(Ts, 1)) { unreachable; });
	...(if (b[index] != get_value(Ts, 1)) { unreachable; });
}

function main()
{
	test_tuple(i32, str, f32, f64, u64, [10: i32], [100: f32]);
	{
		let mut r = [resource_t]();
		let new_r = (typeof r)();
		r = r;
		r = new_r;
		let mut r = [complex_resource_t]();
		let new_r = (typeof r)();
		r = r;
		r = new_r;
		let mut r = [relocatable_counting_resource_t]();
		let new_r = (typeof r)();
		r = r;
		r = new_r;
		let mut r = [counting_resource_t]();
		let new_r = (typeof r)();
		r = r;
		r = new_r;
		let mut r = [resource_t, complex_resource_t, relocatable_counting_resource_t, counting_resource_t]();
		let new_r = (typeof r)();
		r = r;
		r = new_r;
		let mut r = [10: [resource_t, complex_resource_t, relocatable_counting_resource_t, counting_resource_t]]();
		let new_r = (typeof r)();
		r = r;
		r = new_r;
		let mut r = [[10: resource_t], [10: complex_resource_t], [10: relocatable_counting_resource_t], [10: counting_resource_t]]();
		let new_r = (typeof r)();
		r = r;
		r = new_r;
	}

	{
		let mut s = S();
		s.i = 42;
		s.j = 99;
		s.x = 3.14f32;
		s.y = 2.71;
		s.a = __builtin_create_initialized_array([20: u32], 1024u32);
		s.s = "hello";
		s = s;
		if (s.i != 42) unreachable;
		if (s.j != 99) unreachable;
		if (s.x != 3.14f32) unreachable;
		if (s.y != 2.71) unreachable;
		if (s.a != __builtin_create_initialized_array([20: u32], 1024u32)) unreachable;
		if (s.s != "hello") unreachable;
		let new_s = S();
		s = new_s;
		if (s.i != S().i) unreachable;
		if (s.j != S().j) unreachable;
		if (s.x != S().x) unreachable;
		if (s.y != S().y) unreachable;
		if (s.a != S().a) unreachable;
		if (s.s != S().s) unreachable;

		let mut s = complex_S();
		let new_s = complex_S();
		s = s;
		s = new_s;
	}

	if (!counting_resource_is_valid()) unreachable;
	if (!relocatable_counting_resource_is_valid()) unreachable;
}
