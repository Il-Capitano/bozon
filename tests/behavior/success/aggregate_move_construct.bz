import resource;
import counting_resource;

struct S
{
	.i: int32;
	.j: usize;
	.x: float32;
	.y: float64;
	.a: [20: uint32];
	.s: str;
}

struct complex_S
{
	.r0: resource_t;
	.r1: complex_resource_t;
	.ra0: [10: complex_resource_t];
	.ra1: [100: complex_resource_t];
	.cr0: relocatable_counting_resource_t;
	.cr1: counting_resource_t;
	.cra0: [10: counting_resource_t];
	.cra1: [100: counting_resource_t];
}

function index_sequence(size: consteval usize) -> [size: usize]
{
	mut result = [size: usize]();
	for (let i in 0..size)
	{
		result[i] = i;
	}
	return result;
}

function test_tuple(Ts: ...typename)
{
	let t = [...Ts]();
	let t = move t;
	consteval [...index] = index_sequence(sizeof ...Ts);
	...(if (t[index] != Ts()) { unreachable; });
}

function main()
{
	test_tuple(int32, str, float32, float64, uint64, [10: int32], [100: float32]);
	{
		let r = [resource_t]();
		let _ = move r;
		let r = [complex_resource_t]();
		let _ = move r;
		let r = [relocatable_counting_resource_t]();
		let _ = move r;
		let r = [counting_resource_t]();
		let _ = move r;
		let r = [resource_t, complex_resource_t, relocatable_counting_resource_t, counting_resource_t]();
		let _ = move r;
		let r = [10: [resource_t, complex_resource_t, relocatable_counting_resource_t, counting_resource_t]]();
		let _ = move r;
		let r = [[10: resource_t], [10: complex_resource_t], [10: relocatable_counting_resource_t], [10: counting_resource_t]]();
		let _ = move r;
	}

	{
		let s = S();
		let s = move s;
		if (s.i != S().i) unreachable;
		if (s.j != S().j) unreachable;
		if (s.x != S().x) unreachable;
		if (s.y != S().y) unreachable;
		if (s.a != S().a) unreachable;
		if (s.s != S().s) unreachable;

		let s = complex_S();
		let _ = move s;
	}

	if (!counting_resource_is_valid()) unreachable;
	if (!relocatable_counting_resource_is_valid()) unreachable;
}
